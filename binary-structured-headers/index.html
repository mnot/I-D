<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Binary Structured HTTP Field Values</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:title" content="Binary Structured HTTP Field Values"><meta property="og:description" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.It also defines how to use Structured Fields for many existing fields -- thereby &#34;backporting&#34; them -- when supported by both peers."><meta property="og:url" content="https://mnot.github.io/I-D/binary-structured-headers/"><meta property="og:site_name" content="mnot's Internet Drafts"><link rel="stylesheet" type="text/css" href="../Tools/style.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #sidebar {
        margin-top: -10px;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      .toc ul {
        list-style: none;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1, h2, h3 {
        margin-top: 1.2em;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Binary Structured Fields" href="#rfc.section.2"><link rel="Chapter" title="3 Using Binary Structured Fields in HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 Using Binary Structured Fields with Existing Fields" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 References" href="#rfc.section.7"><link rel="Appendix" title="A Data Supporting Directly Represented Field Mappings" href="#rfc.section.A"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-binary-structured-headers-03"><meta name="dcterms.issued" content="2021-04-24"><meta name="dcterms.abstract" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.It also defines how to use Structured Fields for many existing fields -- thereby &#34;backporting&#34; them -- when supported by both peers."><meta name="description" content="This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.It also defines how to use Structured Fields for many existing fields -- thereby &#34;backporting&#34; them -- when supported by both peers."></head><body><script async="True" defer="True" src="https://hypothes.is/embed.js"></script><div class="container" id="top"><div class="row"><div class="col-lg-4 order-last d-none d-lg-block" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top"></a></div><br clear="all"><div class=""><div class="toc "><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#fields">Binary Structured Fields</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#binlit">The Binary Literal Representation</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#list-field-values">List Field Values</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></li><li><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#item-field-values">Item Field Values</a></li><li><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#literal">String Literal Field Values</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Item Types</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li><li><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">Binary Structured Fields Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#frame">The BINHEADERS Frame</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#backport">Using Binary Structured Fields with Existing Fields</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#direct">Directly Represented Fields</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#aliased">Aliased Fields</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#urls">URLs</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dates">Dates</a></li><li><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#etags">ETags</a></li><li><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#links">Links</a></li><li><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#cookies">Cookies</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a href="#data-supporting-directly-represented-field-mappings">Data Supporting Directly Represented Field Mappings</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-lg-8 order-first main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Fastly</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">April 24, 2021</td></tr><tr><td class="text-left">Expires: October 26, 2021</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Binary Structured HTTP Field Values</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers" class="smpl">draft-nottingham-binary-structured-headers</a>-<a href="https://tools.ietf.org/html/draft-nottingham-binary-structured-headers-03" class="smpl">03</a></div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</p></div><div id="rfc.abstract.p.2"><p>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.3"><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</a>.</p></div><div id="rfc.note.1.p.4"><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.5"><p>See also the draft's current status in the IETF datatracker, at <a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on October 26, 2021.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2021 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><div class="toc d-lg-none"><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#fields">Binary Structured Fields</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#binlit">The Binary Literal Representation</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#list-field-values">List Field Values</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></li><li><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#item-field-values">Item Field Values</a></li><li><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#literal">String Literal Field Values</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Item Types</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li><li><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">Binary Structured Fields Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#frame">The BINHEADERS Frame</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#backport">Using Binary Structured Fields with Existing Fields</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#direct">Directly Represented Fields</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#aliased">Aliased Fields</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#urls">URLs</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dates">Dates</a></li><li><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#etags">ETags</a></li><li><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#links">Links</a></li><li><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#cookies">Cookies</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.section.A">Appendix A.</a>&nbsp;&nbsp;&nbsp;<a href="#data-supporting-directly-represented-field-mappings">Data Supporting Directly Represented Field Mappings</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>Structured Field Values for HTTP <a href="#RFC8941"><cite title="Structured Field Values for HTTP">[RFC8941]</cite></a> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <a href="#fields" title="Binary Structured Fields">Section&nbsp;2</a>, and specifies its use in HTTP/2 -- specifically, as part of HPACK Literal Header Field Representations (<a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>) -- in <a href="#negotiate" title="Using Binary Structured Fields in HTTP/2">Section&nbsp;3</a>.</p></div><div id="rfc.section.1.p.2"><p><a href="#backport" title="Using Binary Structured Fields with Existing Fields">Section&nbsp;4</a> defines how to convey existing fields as Structured Fields, when supported by two peers.</p></div><div id="rfc.section.1.p.3"><p>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div><div id="rfc.section.1.1.p.2"><p>This specification describes formats using the convention described in Section 1.3 of <a href="#I-D.ietf-quic-transport"><cite title="QUIC: A UDP-Based Multiplexed and Secure Transport">[I-D.ietf-quic-transport]</cite></a>.</p></div></section></section><section id="fields"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#fields">Binary Structured Fields</a></h2><div id="rfc.section.2.p.1"><p>This section defines a binary serialisation for the Structured Field Types defined in <a href="#RFC8941"><cite title="Structured Field Values for HTTP">[RFC8941]</cite></a>.</p></div><div id="rfc.section.2.p.2"><p>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Literal Representation (<a href="#binlit" title="The Binary Literal Representation">Section&nbsp;2.1</a>), which is a replacement for the String Literal Representation in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>.</p></div><div id="rfc.section.2.p.3"><p>Binary representations of the remaining types are defined in <a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>.</p></div><section id="binlit"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#binlit">The Binary Literal Representation</a></h3><div id="rfc.section.2.1.p.1"><p>The Binary Literal Representation is a replacement for the String Literal Representation defined in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.2, for use in BINHEADERS frames (<a href="#frame" title="The BINHEADERS Frame">Section&nbsp;3.2</a>).</p></div><div id="rfc.section.2.1.p.2" class="avoidbreakafter"><p>All Binary Literal Representations of Field Values share the following header:</p></div><div id="rfc.section.2.1.p.3"><pre>
Binary Structured Field Value {
  Top Level Type (3),
  Length (5..),
}
</pre></div><div id="rfc.section.2.1.p.4" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.1.p.5"><ul><li>Top Level Type: Three bits indicating the top-level type of the field value.</li><li>Length: The number of octets used to represent the payload, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 5-bit prefix.</li></ul></div><div id="rfc.section.2.1.p.6" class="avoidbreakafter"><p>The following top-level types are defined:</p></div><section id="list-field-values"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;<a href="#list-field-values">List Field Values</a></h4><div id="rfc.section.2.1.1.p.1"><p>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>; members that are inner-lists are represented as per <a href="#inner-list" title="Inner Lists">Section&nbsp;2.2.1</a>.</p></div><div id="rfc.section.2.1.1.p.2"><pre>
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
</pre></div><div id="rfc.section.2.1.1.p.3" class="avoidbreakafter"><p>A List Field Value's fields are:</p></div><div id="rfc.section.2.1.1.p.4"><ul><li>Length: The number of octets used to represent the entire List, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 5-bit prefix</li><li>Item: One or more Item(s) (<a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>)</li></ul></div></section><section id="dictionary-field-values"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;<a href="#dictionary-field-values">Dictionary Field Values</a></h4><div id="rfc.section.2.1.2.p.1"><p>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</p></div><div id="rfc.section.2.1.2.p.2"><p>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</p></div><div id="rfc.section.2.1.2.p.3"><pre>
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
</pre></div><div id="rfc.section.2.1.2.p.4" class="avoidbreakafter"><p>A Dictionary Field Value's fields are:</p></div><div id="rfc.section.2.1.2.p.5"><ul><li>Length: The number of octets used to represent the entire Dictionary, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 5-bit prefix</li><li>Dictionary Member: one or more Dictionary Member(s)</li></ul></div><div id="rfc.section.2.1.2.p.6"><pre>
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

</pre></div><div id="rfc.section.2.1.2.p.7" class="avoidbreakafter"><p>A Dictionary Member's fields are:</p></div><div id="rfc.section.2.1.2.p.8"><ul><li>Name Length: The number of octets used to represent the Member Name, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 8-bit prefix</li><li>Member Name: Name Length octets of the member-name, ASCII-encoded</li><li>Item: An Item (<a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>)</li><li>Parameters: Optional Parameters (<a href="#parameter" title="Parameters">Section&nbsp;2.2.2</a>)</li></ul></div><div id="rfc.section.2.1.2.p.9"><p>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</p></div></section><section id="item-field-values"><h4 id="rfc.section.2.1.3"><a href="#rfc.section.2.1.3">2.1.3.</a>&nbsp;<a href="#item-field-values">Item Field Values</a></h4><div id="rfc.section.2.1.3.p.1"><p>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>.</p></div><div id="rfc.section.2.1.3.p.2"><pre>
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
</pre></div><div id="rfc.section.2.1.3.p.3" class="avoidbreakafter"><p>An Item Field Value's fields are:</p></div><div id="rfc.section.2.1.3.p.4"><ul><li>Length: The number of octets used to represent the Item (including Parameters, if present), encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 5-bit prefix</li><li>Item: An Item (<a href="#types" title="Binary Item Types">Section&nbsp;2.2</a>)</li><li>Parameters: Optional Parameters (<a href="#parameter" title="Parameters">Section&nbsp;2.2.2</a>)</li></ul></div><div id="rfc.section.2.1.3.p.5"><p>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</p></div></section><section id="literal"><h4 id="rfc.section.2.1.4"><a href="#rfc.section.2.1.4">2.1.4.</a>&nbsp;<a href="#literal">String Literal Field Values</a></h4><div id="rfc.section.2.1.4.p.1"><p>String Literals (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.2.</p></div><div id="rfc.section.2.1.4.p.2"><pre>
String Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.1.4.p.3" class="avoidbreakafter"><p>A String Literal Field Value's fields are:</p></div><div id="rfc.section.2.1.4.p.4"><ul><li>Length: The number of octets used to represent the string literal, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 5-bit prefix</li><li>Payload: The raw octets of the field value</li></ul></div></section></section><section id="types"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#types">Binary Item Types</a></h3><div id="rfc.section.2.2.p.1"><p>Every Item starts with a 5-bit type field that identifies the format of its payload.</p></div><div id="rfc.section.2.2.p.2"><pre>
Item {
  Type (5)
}
</pre></div><div id="rfc.section.2.2.p.3"><p>Some Binary Item Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</p></div><section id="inner-list"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#inner-list">Inner Lists</a></h4><div id="rfc.section.2.2.1.p.1" class="avoidbreakafter"><p>The Inner List data type (type=0x1) has a payload in the format:</p></div><div id="rfc.section.2.2.1.p.2"><pre>
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
</pre></div><div id="rfc.section.2.2.1.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.1.p.4"><ul><li>Length: The number of octets used to represent the members, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 3-bit prefix</li><li>Item(s): Length octets containing the Item(s) in the List</li></ul></div><div id="rfc.section.2.2.1.p.5"><p>An Item in an Inner List MUST NOT be an Inner List (0x1).</p></div><div id="rfc.section.2.2.1.p.6"><p>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<a href="#parameter" title="Parameters">Section&nbsp;2.2.2</a>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</p></div></section><section id="parameter"><h4 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;<a href="#parameter">Parameters</a></h4><div id="rfc.section.2.2.2.p.1" class="avoidbreakafter"><p>The Parameters data type (type=0x2) has a payload in the format:</p></div><div id="rfc.section.2.2.2.p.2"><pre>
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
</pre></div><div id="rfc.section.2.2.2.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.2.p.4"><ul><li>Length: The number of octets used to represent the payload, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 3-bit prefix</li><li>Parameter(s): Length octets</li></ul></div><div id="rfc.section.2.2.2.p.5" class="avoidbreakafter"><p>Each Parameter conveys a key and a value:</p></div><div id="rfc.section.2.2.2.p.6"><pre>
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Item (..)
}
</pre></div><div id="rfc.section.2.2.2.p.7" class="avoidbreakafter"><p>A parameter's fields are:</p></div><div id="rfc.section.2.2.2.p.8"><ul><li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 8-bit prefix</li><li>Parameter Name: Parameter Name Length octets of the parameter-name</li><li>Item: The parameter value, a Binary Item Type</li></ul></div><div id="rfc.section.2.2.2.p.9"><p>The Item in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</p></div><div id="rfc.section.2.2.2.p.10"><p>Parameters are always associated with the Binary Item Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Item in a container, and MUST NOT follow another Parameters.</p></div></section><section id="integers"><h4 id="rfc.section.2.2.3"><a href="#rfc.section.2.2.3">2.2.3.</a>&nbsp;<a href="#integers">Integers</a></h4><div id="rfc.section.2.2.3.p.1" class="avoidbreakafter"><p>The Integer data type (type=0x3) has a payload in the format:</p></div><div id="rfc.section.2.2.3.p.2"><pre>
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
</pre></div><div id="rfc.section.2.2.3.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.3.p.4"><ul><li>Sign: sign bit; 0 is negative, 1 is positive</li><li>Payload: The integer, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 2-bit prefix</li></ul></div></section><section id="floats"><h4 id="rfc.section.2.2.4"><a href="#rfc.section.2.2.4">2.2.4.</a>&nbsp;<a href="#floats">Floats</a></h4><div id="rfc.section.2.2.4.p.1" class="avoidbreakafter"><p>The Float data type (type=0x4) have a payload in the format:</p></div><div id="rfc.section.2.2.4.p.2"><pre>
Float {
  Item Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
</pre></div><div id="rfc.section.2.2.4.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.4.p.4"><ul><li>Sign: sign bit; 0 is negative, 1 is positive</li><li>Integer: The integer component, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 2-bit prefix.</li><li>Fractional: The fractional component, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 8-bit prefix.</li></ul></div></section><section id="strings"><h4 id="rfc.section.2.2.5"><a href="#rfc.section.2.2.5">2.2.5.</a>&nbsp;<a href="#strings">Strings</a></h4><div id="rfc.section.2.2.5.p.1" class="avoidbreakafter"><p>The String data type (type=0x5) has a payload in the format:</p></div><div id="rfc.section.2.2.5.p.2"><pre>
String {
  Item Type (5) = 5,
  Length (3..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.5.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.5.p.4"><ul><li>Length: The number of octets used to represent the string, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 3-bit prefix.</li><li>Payload: Length octets, ASCII-encoded.</li></ul></div></section><section id="token"><h4 id="rfc.section.2.2.6"><a href="#rfc.section.2.2.6">2.2.6.</a>&nbsp;<a href="#token">Tokens</a></h4><div id="rfc.section.2.2.6.p.1" class="avoidbreakafter"><p>The Token data type (type=0x6) has a payload in the format:</p></div><div id="rfc.section.2.2.6.p.2"><pre>
Token {
  Item Type (5) = 6,
  Length (3..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.6.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.6.p.4"><ul><li>Length: The number of octets used to represent the token, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 3-bit prefix.</li><li>Payload: Length octets, ASCII-encoded.</li></ul></div></section><section id="byte-sequences"><h4 id="rfc.section.2.2.7"><a href="#rfc.section.2.2.7">2.2.7.</a>&nbsp;<a href="#byte-sequences">Byte Sequences</a></h4><div id="rfc.section.2.2.7.p.1" class="avoidbreakafter"><p>The Byte Sequence data type (type=0x7) has a payload in the format:</p></div><div id="rfc.section.2.2.7.p.2"><pre>
Byte Sequence {
  Item Type (5) = 7,
  Length (3..),
  Payload (..)
}
</pre></div><div id="rfc.section.2.2.7.p.3" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.2.7.p.4"><ul><li>Length: The number of octets used to represent the byte sequence, encoded as per <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.1, with a 3-bit prefix.</li><li>Payload: Length octets.</li></ul></div></section><section id="booleans"><h4 id="rfc.section.2.2.8"><a href="#rfc.section.2.2.8">2.2.8.</a>&nbsp;<a href="#booleans">Booleans</a></h4><div id="rfc.section.2.2.8.p.1" class="avoidbreakafter"><p>The Boolean data type (type=0x8) has a payload of two bits:</p></div><div id="rfc.section.2.2.8.p.2"><pre>
Boolean {
  Item Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
</pre></div><div id="rfc.section.2.2.8.p.3"><p>If Payload is 0, the value is False; if Payload is 1, the value is True.</p></div></section></section></section><section id="negotiate"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#negotiate">Using Binary Structured Fields in HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <a href="#backport" title="Using Binary Structured Fields with Existing Fields">Section&nbsp;4</a>).</p></div><div id="rfc.section.3.p.2"><p>Peers advertise and discover this support using a HTTP/2 setting defined in <a href="#setting" title="Binary Structured Fields Setting">Section&nbsp;3.1</a>, and convey Binary Structured Fields in a frame type defined in <a href="#frame" title="The BINHEADERS Frame">Section&nbsp;3.2</a>.</p></div><section id="setting"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#setting">Binary Structured Fields Setting</a></h3><div id="rfc.section.3.1.p.1"><p>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</p></div><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS from a peer indicates that:</p></div><div id="rfc.section.3.1.p.3"><ol type="1"><li>The peer supports the Binary Item Types defined in <a href="#fields" title="Binary Structured Fields">Section&nbsp;2</a>.</li><li>The peer will process the BINHEADERS frames as defined in <a href="#frame" title="The BINHEADERS Frame">Section&nbsp;3.2</a>.</li><li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <a href="#RFC8941"><cite title="Structured Field Values for HTTP">[RFC8941]</cite></a>).</li><li>The peer will likewise transform all fields defined as Aliased Fields (<a href="#aliased" title="Aliased Fields">Section&nbsp;4.2</a>) into their non-aliased forms as necessary.</li></ol></div><div id="rfc.section.3.1.p.4"><p>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0. Future extensions to Structured Fields might use it to indicate support for new types.</p></div></section><section id="frame"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#frame">The BINHEADERS Frame</a></h3><div id="rfc.section.3.2.p.1"><p>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</p></div><div id="rfc.section.3.2.p.2"><p>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.2, it uses the Binary Literal Representation defined in <a href="#binlit" title="The Binary Literal Representation">Section&nbsp;2.1</a>.</p></div><div id="rfc.section.3.2.p.3"><p>Fields that are Structured Fields can have their values represented using the Binary Literal Representation corresponding to that field's top-level type -- List, Dictionary, or Item; their values will then be serialised as a stream of Binary Item Types.</p></div><div id="rfc.section.3.2.p.4"><p>Additionally, any field (including those defined as Structured Fields) can be serialised as a String Literal (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>), which accommodates fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as Binary Item Types for some other reason.</p></div><div id="rfc.section.3.2.p.5"><p>Note that Field Names are always serialised as String Literals (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>).</p></div><div id="rfc.section.3.2.p.6"><p>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Fields Types, and String Literals (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>) to their string counterparts.</p></div><div id="rfc.section.3.2.p.7"><p>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Item Types. In this case, the field types used are informed by the implementations knowledge of the individual field semantics; see <a href="#backport" title="Using Binary Structured Fields with Existing Fields">Section&nbsp;4</a>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Fields are conveyed in BINHEADERS as String Literals (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>).</p></div><div id="rfc.section.3.2.p.8"><p>Field values are stored in the HPACK <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> dynamic table without Huffman encoding, although specific Binary Item Types might specify the use of such encodings.</p></div><div id="rfc.section.3.2.p.9"><p>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Item Types; field names are encoded as they are in HPACK.</p></div></section></section><section id="backport"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#backport">Using Binary Structured Fields with Existing Fields</a></h2><div id="rfc.section.4.p.1"><p>Any field can potentially be parsed as a Structured Field according to the algorithms in <a href="#RFC8941"><cite title="Structured Field Values for HTTP">[RFC8941]</cite></a> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</p></div><div id="rfc.section.4.p.2"><p>This section identifies fields that will usually succeed in <a href="#direct" title="Directly Represented Fields">Section&nbsp;4.1</a>, and those that can be mapped into Structured Fields by using an alias field name in <a href="#aliased" title="Aliased Fields">Section&nbsp;4.2</a>.</p></div><section id="direct"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#direct">Directly Represented Fields</a></h3><div id="rfc.section.4.1.p.1"><p>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <a href="#RFC8941"><cite title="Structured Field Values for HTTP">[RFC8941]</cite></a>, and thus can usually be serialised using the corresponding Binary Item Types.</p></div><div id="rfc.section.4.1.p.2"><p>When one of these fields' values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>).</p></div><div id="rfc.section.4.1.p.3"><ul><li>Accept - List</li><li>Accept-Encoding - List</li><li>Accept-Language - List</li><li>Accept-Patch - List</li><li>Accept-Ranges - List</li><li>Access-Control-Allow-Credentials - Item</li><li>Access-Control-Allow-Headers - List</li><li>Access-Control-Allow-Methods - List</li><li>Access-Control-Allow-Origin - Item</li><li>Access-Control-Max-Age - Item</li><li>Access-Control-Request-Headers - List</li><li>Access-Control-Request-Method - Item</li><li>Age - Item</li><li>Allow - List</li><li>ALPN - List</li><li>Alt-Svc - Dictionary</li><li>Alt-Used - Item</li><li>Cache-Control - Dictionary</li><li>Connection - List</li><li>Content-Encoding - List</li><li>Content-Language - List</li><li>Content-Length - Item</li><li>Content-Type - Item</li><li>Expect - Item</li><li>Expect-CT - Dictionary</li><li>Forwarded - Dictionary</li><li>Host - Item</li><li>Keep-Alive - Dictionary</li><li>Origin - Item</li><li>Pragma - Dictionary</li><li>Prefer - Dictionary</li><li>Preference-Applied - Dictionary</li><li>Retry-After - Item (see caveat below)</li><li>Surrogate-Control - Dictionary</li><li>TE - List</li><li>Trailer - List</li><li>Transfer-Encoding - List</li><li>Vary - List</li><li>X-Content-Type-Options - Item</li><li>X-XSS-Protection - List</li></ul></div><div id="rfc.section.4.1.p.4"><p>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>).</p></div></section><section id="aliased"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#aliased">Aliased Fields</a></h3><div id="rfc.section.4.2.p.1"><p>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</p></div><div id="rfc.section.4.2.p.2" class="avoidbreakafter"><p>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</p></div><div id="rfc.section.4.2.p.3"><pre>
Date: Sun, 06 Nov 1994 08:49:37 GMT
</pre></div><div id="rfc.section.4.2.p.4" class="avoidbreakafter"><p>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</p></div><div id="rfc.section.4.2.p.5"><pre>
SF-Date: 784072177
</pre></div><div id="rfc.section.4.2.p.6"><p>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>).</p></div><div id="rfc.section.4.2.p.7"><p>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <a href="#negotiate" title="Using Binary Structured Fields in HTTP/2">Section&nbsp;3</a>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</p></div><div id="rfc.section.4.2.p.8"><p>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</p></div><div id="rfc.section.4.2.p.9"><ul><li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <a href="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</a></li></ul></div><section id="urls"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;<a href="#urls">URLs</a></h4><div id="rfc.section.4.2.1.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</p></div><div id="rfc.section.4.2.1.p.2"><ul><li>Content-Location - SF-Content-Location</li><li>Location - SF-Location</li><li>Referer - SF-Referer</li></ul></div><div id="rfc.section.4.2.1.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Location:</p></div><div id="rfc.section.4.2.1.p.4"><pre>
SF-Location: "https://example.com/foo"
</pre></div><div id="rfc.section.4.2.1.p.5"><p>TOOD: list of strings, one for each path segment, to allow better compression in the future?</p></div></section><section id="dates"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;<a href="#dates">Dates</a></h4><div id="rfc.section.4.2.2.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</p></div><div id="rfc.section.4.2.2.p.2"><ul><li>Date - SF-Date</li><li>Expires - SF-Expires</li><li>If-Modified-Since - SF-IMS</li><li>If-Unmodified-Since - SF-IUS</li><li>Last-Modified - SF-LM</li></ul></div><div id="rfc.section.4.2.2.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Expires:</p></div><div id="rfc.section.4.2.2.p.4"><pre>
SF-Expires: 1571965240
</pre></div></section><section id="etags"><h4 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;<a href="#etags">ETags</a></h4><div id="rfc.section.4.2.3.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</p></div><div id="rfc.section.4.2.3.p.2"><ul><li>ETag - SF-ETag</li></ul></div><div id="rfc.section.4.2.3.p.3" class="avoidbreakafter"><p>For example, a (non-Binary) ETag:</p></div><div id="rfc.section.4.2.3.p.4"><pre>
SF-ETag: "abcdef"; w=?1
</pre></div><div id="rfc.section.4.2.3.p.5"><p>If-None-Match is a list of the structure described above.</p></div><div id="rfc.section.4.2.3.p.6"><ul><li>If-None-Match - SF-INM</li></ul></div><div id="rfc.section.4.2.3.p.7" class="avoidbreakafter"><p>For example, a (non-binary) If-None-Match:</p></div><div id="rfc.section.4.2.3.p.8"><pre>
SF-INM: "abcdef"; w=?1, "ghijkl"
</pre></div></section><section id="links"><h4 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;<a href="#links">Links</a></h4><div id="rfc.section.4.2.4.p.1"><p>The field-value of the Link header field <a href="#RFC8288"><cite title="Web Linking">[RFC8288]</cite></a> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</p></div><div id="rfc.section.4.2.4.p.2"><ul><li>Link: SF-Link</li></ul></div><div id="rfc.section.4.2.4.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Link:</p></div><div id="rfc.section.4.2.4.p.4"><pre>
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
</pre></div></section><section id="cookies"><h4 id="rfc.section.4.2.5"><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;<a href="#cookies">Cookies</a></h4><div id="rfc.section.4.2.5.p.1"><p>The field-value of the Cookie and Set-Cookie fields <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</p></div><div id="rfc.section.4.2.5.p.2"><p>Set-Cookie: SF-Set-Cookie Cookie: SF-Cookie</p></div><div id="rfc.section.4.2.5.p.3"><pre>
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
</pre></div><div id="rfc.section.4.2.5.p.4"><ul><li>ISSUE: explicitly convert Expires to an integer? <a href="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</a></li><li>ISSUE: dictionary keys cannot contain UC alpha. <a href="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</a></li><li>ISSUE: explicitly allow non-string content. <a href="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</a></li></ul></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><ul><li>ISSUE: todo</li></ul></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</p></div><div id="rfc.section.6.p.2"><p>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of String Literals (<a href="#literal" title="String Literal Field Values">Section&nbsp;2.1.4</a>). Therefore, implementation divergence from this strictness can have security impact.</p></div></section><section><div id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Normative References</h2><dl class="dl-horizontal"><dt id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</dt><dd>Iyengar, J. and M. , “<a href="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">QUIC: A UDP-Based Multiplexed and Secure Transport</a>”, Internet-Draft&nbsp;draft-ietf-quic-transport-34 (<a href="https://datatracker.ietf.org/doc/draft-ietf-quic-transport">work in progress</a>), January&nbsp;2021, &lt;<a href="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt</a>&gt;.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC7541">[RFC7541]</dt><dd>Peon, R. and H. Ruellan, “<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>”, RFC&nbsp;7541, <a href="http://dx.doi.org/10.17487/RFC7541">DOI&nbsp;10.17487/RFC7541</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="RFC8288">[RFC8288]</dt><dd>Nottingham, M., “<a href="https://tools.ietf.org/html/rfc8288">Web Linking</a>”, RFC&nbsp;8288, <a href="http://dx.doi.org/10.17487/RFC8288">DOI&nbsp;10.17487/RFC8288</a>, October&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8288">https://www.rfc-editor.org/info/rfc8288</a>&gt;.</dd><dt id="RFC8941">[RFC8941]</dt><dd>Nottingham, M. and P-H. Kamp, “<a href="https://tools.ietf.org/html/rfc8941">Structured Field Values for HTTP</a>”, RFC&nbsp;8941, <a href="http://dx.doi.org/10.17487/RFC8941">DOI&nbsp;10.17487/RFC8941</a>, February&nbsp;2021, &lt;<a href="https://www.rfc-editor.org/info/rfc8941">https://www.rfc-editor.org/info/rfc8941</a>&gt;.</dd></dl></div></section><section id="data-supporting-directly-represented-field-mappings"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">Appendix A.</a>&nbsp;<a href="#data-supporting-directly-represented-field-mappings">Data Supporting Directly Represented Field Mappings</a></h2><div id="rfc.section.A.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.section.A.p.2" class="avoidbreakafter"><p>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <a href="https://httparchive.org">https://httparchive.org</a> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <a href="#direct" title="Directly Represented Fields">Section&nbsp;4.1</a>, with the indicated number of successful header instances, failures, and the resulting failure rate:</p></div><div id="rfc.section.A.p.3"><ul><li>accept: 9,198 / 10 = 0.109%</li><li>accept-encoding: 34,157 / 74 = 0.216%</li><li>accept-language: 381,034 / 512 = 0.134%</li><li>accept-patch: 5 / 0 = 0.000%</li><li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li><li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li><li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li><li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li><li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li><li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li><li>access-control-request-headers: 39,328 / 624 = 1.562%</li><li>access-control-request-method: 146,259 / 13,821 = 8.634%</li><li>age: 71,281,684 / 172,398 = 0.241%</li><li>allow: 351,704 / 1,886 = 0.533%</li><li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li><li>cache-control: 264,805,256 / 782,896 = 0.295%</li><li>connection: 105,876,072 / 2,915 = 0.003%</li><li>content-encoding: 139,799,523 / 379 = 0.000%</li><li>content-language: 2,367,162 / 728 = 0.031%</li><li>content-length: 296,624,718 / 787,843 = 0.265%</li><li>content-type: 341,918,716 / 795,676 = 0.232%</li><li>expect: 0 / 47 = 100.000%</li><li>expect-ct: 26,569,605 / 29,114 = 0.109%</li><li>forwarded: 119 / 35 = 22.727%</li><li>host: 25,333 / 1,441 = 5.382%</li><li>keep-alive: 43,061,546 / 796 = 0.002%</li><li>origin: 24,335 / 1,539 = 5.948%</li><li>pragma: 46,820,588 / 81,700 = 0.174%</li><li>preference-applied: 57 / 0 = 0.000%</li><li>retry-after: 605,844 / 6,195 = 1.012%</li><li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li><li>surrogate-control: 121,118 / 861 = 0.706%</li><li>te: 1 / 0 = 0.000%</li><li>trailer: 282 / 0 = 0.000%</li><li>transfer-encoding: 13,952,661 / 0 = 0.000%</li><li>vary: 150,787,199 / 41,313 = 0.027%</li><li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li><li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li></ul></div><div id="rfc.section.A.p.4"><p>This data set focuses on response headers, although some request headers are present (because, the Web).</p></div><div id="rfc.section.A.p.5"><p><span class="tt">alt-svc</span> has a high failure rate because some currently-used ALPN tokens (e.g., <span class="tt">h3-Q43</span>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <span class="tt">h3</span> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</p></div><div id="rfc.section.A.p.6"><p><span class="tt">forwarded</span> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <span class="tt">for=192.168.1.1</span>.</p></div><div id="rfc.section.A.p.7"><p><span class="tt">strict-transport-security</span> has a high failure rate because the <span class="tt">includeSubDomains</span> flag does not conform to the key syntax.</p></div><div id="rfc.section.A.p.8" class="avoidbreakafter"><p>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</p></div><div id="rfc.section.A.p.9"><ul><li>date: 354,652,447</li><li>server: 311,275,961</li><li>last-modified: 263,832,615</li><li>expires: 199,967,042</li><li>status: 192,423,509</li><li>etag: 172,058,269</li><li>timing-allow-origin: 64,407,586</li><li>x-cache: 41,740,804</li><li>p3p: 39,490,058</li><li>x-frame-options: 34,037,985</li></ul></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>Prahran, VIC<br>Australia<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></div></div></div><script src="../Tools/node_modules/jquery/dist/jquery.min.js"></script><script src="../Tools/node_modules/bootstrap/dist/js/bootstrap.min.js"></script></body></html>