<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfc2629xslt/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-site-wide-headers-00" category="info">

  <front>
    <title>Site-Wide HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2016"/>

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document specifies an alternative way for Web sites to send HTTP response header fields that apply to large numbers of resources, to improve efficiency.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP response headers are being used for an increasing amount of metadata that applies to an entire site, or large portions of it.</t>

<t>For example, <spanx style="verb">Strict-Transport-Security</spanx> <xref target="RFC6797"/> and <spanx style="verb">Public-Key-Pins</spanx> <xref target="RFC7469"/> both define headers that are explicitly scoped to an entire origin <xref target="RFC6454"/>, and number of similar headers are under consideration.</t>

<t>Likewise, some HTTP header fields only sensibly have a single value per origin; for example, <spanx style="verb">Server</spanx>.</t>

<t>Furthermore, some headers are used uniformly across an origin. For example, a site might have a <spanx style="verb">Content-Security-Policy</spanx> <xref target="W3C.CR-CSP2-20150721"/> header that doesn’t vary across the site, or only varies slightly from resource to resource.</t>

<t>HTTP/2’s HPACK <xref target="RFC7541"/> header compression mechanism was designed to reduce bandwidth usage for often-repeated headers, both in responses and requests. However, it limits the amount of compression contents usable for a connection (by default, 4K), which sites are beginning to exceed, thereby reducing the efficiency of HPACK itself.</t>

<t>For example, it is not uncommon for a CSP response header field to exceed 1K (and has been observed to be greater than 3K on popular sites). This forces site administrators to make an awkward choice; put the large header in the HPACK table, thereby crowding out other headers, or omit it, requiring its full content to be sent on every applicable response.</t>

<t>This document defines a way to specify one or more sets of HTTP response header fields in a well-known resource <xref target="RFC5785"/> that, when their use is negotiated, are appended to HTTP responses by the user agent. This allows common response headers to be omitted both from on-the-wire responses and the HPACK compression table, making both more efficient.</t>

<t>This approach is preferable to increasing the HTTP/2 SETTINGS_HEADER_TABLE_SIZE (<xref target="RFC7540"/>, Section 6.5.2), because increasing that setting incurs a per-connection overhead on the server, whereas using the technique documented here does not.</t>

<section anchor="example" title="Example">

<t>If a user agent has a fresh copy of the well-known resource for an origin (see <xref target="well-known"/>), either because it performed a GET, or HTTP/2 Server Push was used:</t>

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: text/site-headers
Cache-Control: max-age=3600
ETag: "abc123"
Content-Length: 1234

# a
Strict-Transport-Security: max-age=15768000 ; includeSubDomains
Server: Apache/2.4.7 (Ubuntu)
Public-Key-Pins: max-age=604800; 
  pin-sha256="ZitlqPmA9wodcxkwOW/c7ehlNFk8qJ9FsocodG6GzdjNM=";
  pin-sha256="XRXP987nz4rd1/gS2fJSNVfyrZbqa00T7PeRXUPd15w="; 
  report-uri="/lib/key-pin.cgi"
]]></artwork></figure>

<t>and the user agent makes the request:</t>

<figure><artwork><![CDATA[
GET /images/foo.jpg HTTP/1.1
Host: www.example.com
SM: "abc123"
]]></artwork></figure>

<t>this indicates that the user agent has processed the well-known resource, and therefore that the server can omit the nominated response header fields on the wire, instead referring to them with the <spanx style="verb">HS</spanx> response header field:</t>

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: image/jpeg
Vary: SM, Accept-Encoding
Cache-Control: max-age=3600
HS: "a"
Transfer-Encoding: chunked
]]></artwork></figure>

<t>Upon receipt of that response, the user agent will consider it equivalent to:</t>

<figure><artwork><![CDATA[
HTTP/1.1 200 OK
Content-Type: image/jpeg
Vary: SM, Accept-Encoding
Cache-Control: max-age=3600
Connection: close
Strict-Transport-Security: max-age=15768000 ; includeSubDomains
Server: Apache/2.4.7 (Ubuntu)
Public-Key-Pins: max-age=604800; 
  pin-sha256="ZitlqPmA9wodcxkwOW/c7ehlNFk8qJ9FsocodG6GzdjNM=";
  pin-sha256="XRXP987nz4rd1/gS2fJSNVfyrZbqa00T7PeRXUPd15w="; 
  report-uri="/lib/key-pin.cgi"
]]></artwork></figure>

<t>If a request omits the <spanx style="verb">SM</spanx> header field, or its field-value does not match the current ETag of the well-known resource, all of the header fields above will be sent by the server in the response.</t>

</section>
<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

<t>This document uses the following ABNF rules from <xref target="RFC5234"/>: <spanx style="verb">DQUOTE</spanx>, <spanx style="verb">ALPHA</spanx>. From <xref target="RFC7230"/>: <spanx style="verb">OWS</spanx>, <spanx style="verb">RWS</spanx>, <spanx style="verb">CRLF</spanx>, <spanx style="verb">header-field</spanx>. From <xref target="RFC7232"/>: <spanx style="verb">entity-tag</spanx>.</t>

</section>
</section>
<section anchor="server" title="Server Operation">

<t>When a server wishes to use site-wide HTTP headers, it places a file in the format specified in <xref target="type"/> at the well-known URI specified in <xref target="well-known"/>.</t>

<t>Then, when a request has a <spanx style="verb">SM</spanx> request header field (as per <xref target="sm"/>) that matches the current ETag of the well-known resource, the set of response header fields referred to by the <spanx style="verb">HS</spanx> response header field (see <xref target="hs"/>) for the requested resource are omitted from the corresponding response.</t>

<t>Servers SHOULD include <spanx style="verb">SM</spanx> in the field-value of the <spanx style="verb">Vary</spanx> response header field for all cacheable (as per <xref target="RFC7234"/>) responses of resources that behave in this manner, whether or not headers have been actually appended. This assures correct cache operation, and also advertises support for this specification.</t>

<t>Servers MAY use HTTP/2 Server Push (<xref target="RFC7540"/>, Section 8.2) to proactively send the well-known resource to user agents (e.g., if they emit <spanx style="verb">SM: *</spanx>, indicating that they do not have a fresh copy of the well-known resource).</t>

<section anchor="selecting" title="Selecting Site-Wide Headers">

<t>Because this mechanism effectively hides response header fields from intermediaries that do not implement it, care ought to be take in selecting the headers to use it upon.</t>

<t>For example, the <spanx style="verb">Cache-Control</spanx> and <spanx style="verb">Vary</spanx> headers are poor candidates, because they are often used by intermediaries for HTTP caching <xref target="RFC7234"/>.</t>

<t>Likewise, HTTP/1 headers that affect message framing and connection behaviour (e.g., <spanx style="verb">Content-Length</spanx>, <spanx style="verb">Transfer-Encoding</spanx>, <spanx style="verb">Connection</spanx>) MUST NOT be included in the well-known resource.</t>

</section>
<section anchor="hs" title="The “HS” HTTP Response Header Field">

<t>The <spanx style="verb">HS</spanx> HTTP response header field indicates the header set in the well-known location file (see <xref target="type"/>) that should be applied to the response it occurs within.</t>

<figure><artwork><![CDATA[
HS = DQUOTE 1*ALPHA DQUOTE
]]></artwork></figure>

<t>For example:</t>

<figure><artwork><![CDATA[
HS: "12345678"
]]></artwork></figure>

</section>
</section>
<section anchor="client" title="User Agent Operation">

<t>User agents that support this specification SHOULD always emit a <spanx style="verb">SM</spanx> header field in requests, carrying either the <spanx style="verb">ETag</spanx> of the well-known resource currently held for the origin, or <spanx style="verb">*</spanx> to indicate that they support this specification, but do not have a fresh (as per <xref target="RFC7234"/>) copy of it.</t>

<t>User agents might discover that an origin supports this specification when it returns a response containing the <spanx style="verb">HS</spanx> response header field, or they might learn of it when the well-known location’s current contents are sent via a HTTP/2 Server Push.</t>

<t>In either case, user agents SHOULD send a <spanx style="verb">SM</spanx> request header field on all requests to such an origin.</t>

<t>Upon receiving a response to such a request containing the <spanx style="verb">HS</spanx> response header field, user agents MUST locate the header-set referred to by its field-value in the stored well-known response, remove any surrounding white space, and append it to the response headers, stripping the <spanx style="verb">HS</spanx> response header field.</t>

<t>If the corresponding header-set cannot be found in the well-known location, the response MUST be considered invalid and MUST NOT be used; the user agent MAY retry the request without the <spanx style="verb">SM</spanx> request header field if its method was safe, or may take alternative recovery strategies.</t>

<section anchor="sm" title="The “SM” HTTP Request Header Field">

<t>The <spanx style="verb">SM</spanx> HTTP request header field indicates that the user agent has a fresh (as per <xref target="RFC7234"/>) copy of the well-known resource (see <xref target="well-known"/>) for the request’s origin (<xref target="RFC6454"/>).</t>

<figure><artwork><![CDATA[
SM = "*" / entity-tag
]]></artwork></figure>

<t>Its value is the <spanx style="verb">entity-tag</spanx> <xref target="RFC7232"/> of the freshest valid well-known location response held by the user agent. If none is held, it should be <spanx style="verb">*</spanx> (without quotes).</t>

<t>For example:</t>

<figure><artwork><![CDATA[
SM: "abc123"
SM: *
]]></artwork></figure>

</section>
</section>
<section anchor="well-known" title="The “site-headers” well-known URI">

<t>The well-known URI <xref target="RFC5785"/> “site-headers” is a resource that, when fetched, returns a file in the “text/site-headers” format (see <xref target="type"/>).</t>

<t>Its media type SHOULD be generated as <spanx style="verb">text/site-headers</spanx>, although user agents SHOULD NOT reject responses with other types (particularly, <spanx style="verb">application/octet-stream</spanx> and <spanx style="verb">text/plain</spanx>).</t>

<t>Its representation MUST contain an <spanx style="verb">ETag</spanx> response header <xref target="RFC7232"/>.</t>

<t>User agents SHOULD consider it to be valid for its freshness lifetime (as per <xref target="RFC7234"/>). If it does not have an explicit freshness lifetime, they SHOULD consider it to have a heuristic freshness lifetime of 60 seconds.</t>

<section anchor="type" title="The “text/site-headers” Media Type">

<t>The <spanx style="verb">text/site-headers</spanx> media type is used to indicate that a file contains one or more sets of HTTP header fields, as defined in <xref target="RFC7230"/>, Section 3.</t>

<figure><artwork><![CDATA[
site-headers = 1*( header-header header-set )
header-header = "#" 1*RWS set-name OWS CRLF
set-name = 1*ALPHA
header-set = OWS *( header-field CRLF ) OWS
]]></artwork></figure>

<t>Each set of HTTP header fields is started by a header-header, which is indicated by an octothorp (“#”) followed by the name of the header set. The following lines, up until the next line beginning with an octothorp or the end of the file are considered to be the header-set’s contents.</t>

<t>As in HTTP itself, implementations need to be forgiving about line endings; specifically, bare CR MUST be considered to be a line ending.</t>

<t>For example:</t>

<figure><artwork><![CDATA[
# foo
Strict-Transport-Security: max-age=15768000 ; includeSubDomains
Server: Apache/2.4.7 (Ubuntu)
Public-Key-Pins: max-age=604800;
  pin-sha256="ZitlqPmA9wodcxkwOW/c7ehlNFk8qJ9FsocodG6GzdjNM=";
  pin-sha256="XRXP987nz4rd1/gS2fJSNVfyrZbqa00T7PeRXUPd15w="; 
  report-uri="/lib/key-pin.cgi"
# bar
Strict-Transport-Security: max-age=15768000 ; includeSubDomains
Server: Apache/2.4.7 (Ubuntu)
Public-Key-Pins: max-age=604800;
  pin-sha256="ZitlqPmA9wodcxkwOW/c7ehlNFk8qJ9FsocodG6GzdjNM=";
  pin-sha256="XRXP987nz4rd1/gS2fJSNVfyrZbqa00T7PeRXUPd15w="; 
  report-uri="/lib/key-pin.cgi"
Content-Security-Policy: default-src 'self'; img-src 'self'
  *.staticflickr.com; frame-ancestors 'none';
  report-uri https://mnot.report-uri.io/r/default/csp/enforce
]]></artwork></figure>

<t>This file specifies two sets of HTTP headers, “foo” and “bar”. Note that the <spanx style="verb">Public-Key-Pins</spanx> and <spanx style="verb">Content-Security-Policy</spanx> header fields are line-folded; as in HTTP, this form of header is deprecated in this format, and SHOULD NOT be used (except in documentation, as we see here).</t>

<section anchor="parsing-textsite-headers" title="Parsing “text/site-headers”">

<t>Given a stream of Unicode characters:</t>

<t><list style="numbers">
  <t>Let <spanx style="verb">header-sets</spanx> be an empty mapping.</t>
  <t>Consume all characters from up to and including the first octothorp (“#”).</t>
  <t>Consume all <spanx style="verb">WSP</spanx> characters.</t>
  <t>Let <spanx style="verb">set-name</spanx> be all characters up to but not including the next <spanx style="verb">WSP</spanx>, <spanx style="verb">CR</spanx> or <spanx style="verb">LF</spanx>.</t>
  <t>Consume all <spanx style="verb">WSP</spanx>, <spanx style="verb">CR</spanx> and <spanx style="verb">LF characters</spanx>.</t>
  <t>Let <spanx style="verb">header-set</spanx> be all characters up to but not including the next <spanx style="verb">CR</spanx> or <spanx style="verb">LF</spanx> character followed by an octothorp (“#”), or the end of the file.</t>
  <t>Trim all <spanx style="verb">WSP</spanx> from the end of <spanx style="verb">header-set</spanx>.</t>
  <t>Let the value of the <spanx style="verb">set-name</spanx> entry in <spanx style="verb">header-sets</spanx> be <spanx style="verb">header-set</spanx> (removing any existing value).</t>
  <t>If there is more <spanx style="verb">input</spanx>, return to step 2.</t>
  <t>Otherwise, return <spanx style="verb">header-sets</spanx>.</t>
</list></t>

<t>This returns a mapping of <spanx style="verb">set-name</spanx> to a HTTP <spanx style="verb">header-set</spanx>, as defined in <xref target="RFC7230"/>, Section 3. It SHOULD be parsed as defined there.</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TBD</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<section anchor="injecting-headers" title="Injecting Headers">

<t>Site-wide headers allow a single resource to inject HTTP response headers for an entire origin. Accordingly, the ability to write to that resource needs to be carefully controlled by the origin server.</t>

</section>
<section anchor="inappropriate-headers" title="Inappropriate Headers">

<t>As noted in <xref target="selecting"/>, there are a variety of HTTP response headers which are inappropriate for use as site-wide headers, and some (e.g., <spanx style="verb">Content-Length</spanx>) can cause both interoperability and security issues.</t>

</section>
<section anchor="differing-views-of-headers" title="Differing Views of Headers">

<t>Because headers sent via this mechanism will not be seen by user agents and intermediaries that do not implement this specification, they will potentially have a different view of the response headers.</t>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC6454' target='http://www.rfc-editor.org/info/rfc6454'>
<front>
<title>The Web Origin Concept</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='December' />
<abstract><t>This document defines the concept of an &quot;origin&quot;, which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named &quot;Origin&quot;, that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6454'/>
<seriesInfo name='DOI' value='10.17487/RFC6454'/>
</reference>



<reference  anchor='RFC5785' target='http://www.rfc-editor.org/info/rfc5785'>
<front>
<title>Defining Well-Known Uniform Resource Identifiers (URIs)</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<author initials='E.' surname='Hammer-Lahav' fullname='E. Hammer-Lahav'><organization /></author>
<date year='2010' month='April' />
<abstract><t>This memo defines a path prefix for &quot;well-known locations&quot;, &quot;/.well-known/&quot;, in selected Uniform Resource Identifier (URI) schemes.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5785'/>
<seriesInfo name='DOI' value='10.17487/RFC5785'/>
</reference>



<reference  anchor='RFC5234' target='http://www.rfc-editor.org/info/rfc5234'>
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials='D.' surname='Crocker' fullname='D. Crocker' role='editor'><organization /></author>
<author initials='P.' surname='Overell' fullname='P. Overell'><organization /></author>
<date year='2008' month='January' />
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='STD' value='68'/>
<seriesInfo name='RFC' value='5234'/>
<seriesInfo name='DOI' value='10.17487/RFC5234'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7232' target='http://www.rfc-editor.org/info/rfc7232'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.</t></abstract>
</front>
<seriesInfo name='RFC' value='7232'/>
<seriesInfo name='DOI' value='10.17487/RFC7232'/>
</reference>



<reference  anchor='RFC7234' target='http://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor='RFC6797' target='http://www.rfc-editor.org/info/rfc6797'>
<front>
<title>HTTP Strict Transport Security (HSTS)</title>
<author initials='J.' surname='Hodges' fullname='J. Hodges'><organization /></author>
<author initials='C.' surname='Jackson' fullname='C. Jackson'><organization /></author>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2012' month='November' />
<abstract><t>This specification defines a mechanism enabling web sites to declare themselves accessible only via secure connections and/or for users to be able to direct their user agent(s) to interact with given sites only over secure connections.  This overall policy is referred to as HTTP Strict Transport Security (HSTS).  The policy is declared by web sites via the Strict-Transport-Security HTTP response header field and/or by other means, such as user agent configuration, for example. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6797'/>
<seriesInfo name='DOI' value='10.17487/RFC6797'/>
</reference>



<reference  anchor='RFC7469' target='http://www.rfc-editor.org/info/rfc7469'>
<front>
<title>Public Key Pinning Extension for HTTP</title>
<author initials='C.' surname='Evans' fullname='C. Evans'><organization /></author>
<author initials='C.' surname='Palmer' fullname='C. Palmer'><organization /></author>
<author initials='R.' surname='Sleevi' fullname='R. Sleevi'><organization /></author>
<date year='2015' month='April' />
<abstract><t>This document defines a new HTTP header that allows web host operators to instruct user agents to remember (&quot;pin&quot;) the hosts' cryptographic identities over a period of time.  During that time, user agents (UAs) will require that the host presents a certificate chain including at least one Subject Public Key Info structure whose fingerprint matches one of the pinned fingerprints for that host.  By effectively reducing the number of trusted authorities who can authenticate the domain during the lifetime of the pin, pinning may reduce the incidence of man-in-the-middle attacks due to compromised Certification Authorities.</t></abstract>
</front>
<seriesInfo name='RFC' value='7469'/>
<seriesInfo name='DOI' value='10.17487/RFC7469'/>
</reference>



<reference anchor='W3C.CR-CSP2-20150721'
           target='http://www.w3.org/TR/2015/CR-CSP2-20150721'>
<front>
<title>Content Security Policy Level 2</title>

<author initials='M.' surname='West' fullname='Mike West'>
    <organization />
</author>

<author initials='A.' surname='Barth' fullname='Adam Barth'>
    <organization />
</author>

<author initials='D.' surname='Veditz' fullname='Daniel Veditz'>
    <organization />
</author>

<date month='July' day='21' year='2015' />
</front>

<seriesInfo name='World Wide Web Consortium CR' value='CR-CSP2-20150721' />
<format type='HTML' target='http://www.w3.org/TR/2015/CR-CSP2-20150721' />
</reference>



<reference  anchor='RFC7541' target='http://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>



  </back>
</rfc>

