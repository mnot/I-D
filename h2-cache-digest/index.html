<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Cache Digests for HTTP/2</title><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      #rfc\.toc > ul li {
        list-style: none;
      }
      .container .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .container .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .container .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The CACHE_DIGEST Frame" href="#rfc.section.2"><link rel="Chapter" title="3 IANA Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" href="#rfc.section.5" title="5 References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Oku, K."><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-kazuho-h2-cache-digest-00"><meta name="dcterms.issued" content="2016-06-08"><meta name="dcterms.abstract" content="This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients."><meta name="description" content="This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients."></head><body><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc..toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#the-cachedigest-frame">The CACHE_DIGEST Frame</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#client-behavior">Client Behavior</a><ul><li><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#computing">Computing the Digest-Value</a></li><li><a href="#rfc.section.2.1.2">2.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#hash">Computing a Hash Value</a></li></ul></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#server-behavior">Server Behavior</a><ul><li><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#querying">Querying the Digest for a Value</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">K. Oku</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">DeNA Co, Ltd.</td></tr><tr><td class="text-left">Intended status: Informational</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Expires: December 10, 2016</td><td class="text-right">June 8, 2016</td></tr></tbody></table><div id="rfc.title"><h1>Cache Digests for HTTP/2</h1><div class="filename">draft-kazuho-h2-cache-digest-00</div></div></header><hr><h2 id="rfc..abstract"><a href="#rfc..abstract">Abstract</a></h2><div class="lead"><p>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents. Servers can then use this to inform their choices of what to push to clients.</p></div><section id="rfc.note.1"><h2><a href="#rfc.note.1">Note to Readers</a></h2><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/h2-cache-digest">https://github.com/mnot/I-D/labels/h2-cache-digest</a>.</p><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/h2-cache-digest/">https://mnot.github.io/I-D/h2-cache-digest/</a>.</p><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/h2-cache-digest">https://github.com/mnot/I-D/commits/gh-pages/h2-cache-digest</a>.</p></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on December 10, 2016.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2016 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></section><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP/2 <a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a> allows a server to “push” synthetic request/response pairs into a client’s cache optimistically. While there is strong interest in using this facility to improve perceived Web browsing performance, it is sometimes counterproductive because the client might already have cached the “pushed” response.</p></div><div id="rfc.section.1.p.2"><p>When this is the case, the bandwidth used to “push” the response is effectively wasted, and represents opportunity cost, because it could be used by other, more relevant responses. HTTP/2 allows a stream to be cancelled by a client using a RST_STREAM frame in this situation, but there is still at least one round trip of potentially wasted capacity even then.</p></div><div id="rfc.section.1.p.3"><p>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache’s contents using a Golumb-Rice Coded Set. Servers can then use this to inform their choices of what to push to clients.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.1.1.p.2"><p>A CACHE_DIGEST frame can be sent from a client to a server on any stream in the “open” state, and conveys a digest of the contents of the client’s cache for associated stream.</p></div></section></section><section id="the-cachedigest-frame"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#the-cachedigest-frame">The CACHE_DIGEST Frame</a></h2><div id="rfc.section.2.p.1"><p>The CACHE_DIGEST frame type is 0xf1. NOTE: This is an experimental value; if standardised, a permanent value will be assigned.</p></div><div id="rfc.figure.u.1"><pre>
+-----------------------------------------------+
|              Digest-Value? (\*)              ...
+-----------------------------------------------+
</pre></div><div id="rfc.section.2.p.2" class="avoidbreakafter"><p>The CACHE_DIGEST frame payload has the following fields:</p></div><div id="rfc.section.2.p.3"><ul><li><strong>Digest-Value</strong>: A sequence of octets containing the digest as computed in <a href="#computing" title="Computing the Digest-Value">Section&nbsp;2.1.1</a>.</li></ul></div><div id="rfc.section.2.p.4" class="avoidbreakafter"><p>The CACHE_DIGEST frame defines the following flags:</p></div><div id="rfc.section.2.p.5"><ul><li><strong>RESET</strong> (0x1): When set, indicates that any and all cache digests for the applicable origin held by the recipient MUST be considered invalid.</li><li><strong>COMPLETE</strong> (0x2): When set, indicates that the currently valid set of cache digests held by the server constitutes a complete representation of the cache’s state regarding that origin, for the type of cached response indicated by the <span class="tt">STALE</span> flag.</li><li><strong>VALIDATORS</strong> (0x3): When set, indicates that the <span class="tt">validators</span> boolean in <a href="#computing" title="Computing the Digest-Value">Section&nbsp;2.1.1</a> is true.</li><li><strong>STALE</strong> (0x4): When set, indicates that all cached responses represented in the digest-value are stale <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> at the point in them that the digest was generated; otherwise, all are fresh.</li></ul></div><section id="client-behavior"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#client-behavior">Client Behavior</a></h3><div id="rfc.section.2.1.p.1"><p>In typical use, a client will send one or more CACHE_DIGESTs immediately after the first request on a connection for a given origin, on the same stream, because there is usually a short period of inactivity then, and servers can benefit most when they understand the state of the cache before they begin pushing associated assets (e.g., CSS, JavaScript and images). Clients MAY send CACHE_DIGEST at other times.</p></div><div id="rfc.section.2.1.p.2"><p>If the cache’s state is cleared, lost, or the client otherwise wishes the server to stop using previously sent CACHE_DIGESTs, it can send a CACHE_DIGEST with the RESET flag set.</p></div><div id="rfc.section.2.1.p.3"><p>When generating CACHE_DIGEST, a client MUST NOT include cached responses whose URLs do not share origins <a href="#RFC6454"><cite title="The Web Origin Concept">[RFC6454]</cite></a> with the request of the stream that the frame is sent upon.</p></div><div id="rfc.section.2.1.p.4"><p>CACHE_DIGEST allows the client to indicate whether the set of URLs used to compute the digest represent fresh or stale stored responses, using the STALE flag. Clients MAY decide whether to only sent CACHE_DIGEST frames representing their fresh stored responses, their stale stored responses, or both.</p></div><div id="rfc.section.2.1.p.5"><p>Clients can choose to only send a subset of the suitable stored responses of each type (fresh or stale). However, when the CACHE_DIGEST frames sent represent the complete set of stored responses of a given type, the last such frame SHOULD have a COMPLETE flag set, to indicate to the server that it has all relevant state of that type. Note that for the purposes of COMPLETE, responses cached since the beginning of the connection or the last RESET flag on a CACHE_DIGEST frame need not be included.</p></div><div id="rfc.section.2.1.p.6"><p>CACHE_DIGEST can be computed to include cached responses’ ETags, as indicated by the VALIDATORS flag. This information can be used by servers to decide what kinds of responses to push to clients; for example, a stale response that hasn’t changed could be refreshed with a 304 (Not Modified) response; one that has changed can be replaced with a 200 (OK) response, whether the cached response was fresh or stale.</p></div><div id="rfc.section.2.1.p.7"><p>CACHE_DIGEST has no defined meaning when sent from servers, and SHOULD be ignored by clients.</p></div><section id="computing"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;<a href="#computing">Computing the Digest-Value</a></h4><div id="rfc.section.2.1.1.p.1" class="avoidbreakafter"><p>Given the following inputs:</p></div><div id="rfc.section.2.1.1.p.2"><ul><li><span class="tt">validators</span>, a boolean indicating whether validators (<a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a>) are to be included in the digest;</li><li><span class="tt">URLs'</span>, an array of (string <span class="tt">URL</span>, string <span class="tt">ETag</span>) tuples, each corresponding to the Effective Request URI (<a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 5.5) of a cached response <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a> and its entity-tag <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a> (if <span class="tt">validators</span> is true and if the ETag is available; otherwise, null);</li><li><span class="tt">P</span>, an integer that MUST be a power of 2 smaller than 2**32, that indicates the probability of a false positive that is acceptable, expressed as <span class="tt">1/P</span>.</li></ul></div><div id="rfc.section.2.1.1.p.3" class="avoidbreakafter"><p><span class="tt">digest-value</span> can be computed using the following algorithm:</p></div><div id="rfc.section.2.1.1.p.4"><ol><li>Let N be the count of <span class="tt">URLs</span>’ members, rounded to the nearest power of 2 smaller than 2**32.</li><li>Let <span class="tt">hash-values</span> be an empty array of integers.</li><li>Append 0 to <span class="tt">hash-values</span>.</li><li>For each (<span class="tt">URL</span>, <span class="tt">ETag</span>) in <span class="tt">URLs</span>, compute a hash value (<a href="#hash" title="Computing a Hash Value">Section&nbsp;2.1.2</a>) and append the result to <span class="tt">hash-values</span>.</li><li>Sort <span class="tt">hash-values</span> in ascending order.</li><li>Let <span class="tt">digest-value</span> be an empty array of bits.</li><li>Write log base 2 of <span class="tt">N</span> to <span class="tt">digest-value</span> using 5 bits.</li><li>Write log base 2 of <span class="tt">P</span> to <span class="tt">digest-value</span> using 5 bits.</li><li>For each <span class="tt">V</span> in <span class="tt">hash-values</span>: <ol><li>Let <span class="tt">W</span> be the value following <span class="tt">V</span> in <span class="tt">hash-values</span>.</li><li>If <span class="tt">W</span> and <span class="tt">V</span> are equal, continue to the next <span class="tt">V</span>.</li><li>Let <span class="tt">D</span> be the result of <span class="tt">W - V - 1</span>.</li><li>Let <span class="tt">Q</span> be the integer result of <span class="tt">D / P</span>.</li><li>Let <span class="tt">R</span> be the result of <span class="tt">D modulo P</span>.</li><li>Write <span class="tt">Q</span> ‘0’ bits to <span class="tt">digest-value</span>.</li><li>Write 1 ‘1’ bit to <span class="tt">digest-value</span>.</li><li>Write <span class="tt">R</span> to <span class="tt">digest-value</span> as binary, using log2(<span class="tt">P</span>5) bits.</li><li>If <span class="tt">V</span> is the second-to-last member of <span class="tt">hash-values</span>, stop iterating through <span class="tt">hash-values</span> and continue to the next step.</li></ol></li><li>If the length of <span class="tt">digest-value</span> is not a multiple of 8, pad it with 0s until it is.</li></ol></div></section><section id="hash"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2</a>&nbsp;<a href="#hash">Computing a Hash Value</a></h4><div id="rfc.section.2.1.2.p.1"><p>Given: * <span class="tt">URL</span>, an array of characters * <span class="tt">ETag</span>, an array of characters * <span class="tt">validators</span>, a boolean * <span class="tt">N</span>, an integer * <span class="tt">P</span>, an integer</p></div><div id="rfc.section.2.1.2.p.2" class="avoidbreakafter"><p><span class="tt">hash-value</span> can be computed using the following algorithm:</p></div><div id="rfc.section.2.1.2.p.3"><ol><li>Let <span class="tt">key</span> be <span class="tt">URL</span> converted to an ASCII string by percent-encoding as appropriate <a href="#RFC3986"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>.</li><li>If <span class="tt">validators</span> is true and <span class="tt">ETag</span> is not null: <ol><li>Append <span class="tt">ETag</span> to <span class="tt">key</span> as an ASCII string, including both the <span class="tt">weak</span> indicator (if present) and double quotes, as per <a href="#RFC7232"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests">[RFC7232]</cite></a> Section 2.3.</li></ol></li><li>Let <span class="tt">hash-value</span> be the SHA-256 message digest <a href="#RFC6234"><cite title="US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)">[RFC6234]</cite></a> of <span class="tt">key</span>, expressed as an integer.</li><li>Truncate <span class="tt">hash-value</span> to log2( <span class="tt">N</span> * <span class="tt">P</span> ) bits.</li></ol></div></section></section><section id="server-behavior"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#server-behavior">Server Behavior</a></h3><div id="rfc.section.2.2.p.1"><p>In typical use, a server will query (as per <a href="#querying" title="Querying the Digest for a Value">Section&nbsp;2.2.1</a>) the CACHE_DIGESTs received on a given connect to inform what it pushes to that client;</p></div><div id="rfc.section.2.2.p.2"><ul><li>If a given URL has a match in a current CACHE_DIGEST with the STALE flag unset, it need not be pushed, because it is fresh in cache;</li><li>If a given URL and ETag combination has a match in a current CACHE_DIGEST with the STALE flag set, the client has a stale copy in cache, and a validating response can be pushed;</li><li>If a given URL has no match in any current CACHE_DIGEST, the client does not have a cached copy, and a complete response can be pushed.</li></ul></div><div id="rfc.section.2.2.p.3"><p>Servers MAY use all CACHE_DIGESTs received for a given origin as current, as long as they do not have the RESET flag set; a CACHE_DIGEST frame with the RESET flag set MUST clear any previously stored CACHE_DIGESTs for its origin. Servers MUST treat an empty Digest-Value with a RESET flag set as effectively clearing all stored digests for that origin.</p></div><div id="rfc.section.2.2.p.4"><p>Clients are not likely to send updates to CACHE_DIGEST over the lifetime of a connection; it is expected that servers will separately track what cacheable responses have been sent previously on the same connection, using that knowledge in conjunction with that provided by CACHE_DIGEST.</p></div><section id="querying"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;<a href="#querying">Querying the Digest for a Value</a></h4><div id="rfc.section.2.2.1.p.1"><p>Given: * <span class="tt">digest-value</span>, an array of bits * <span class="tt">URL</span>, an array of characters * <span class="tt">ETag</span>, an array of characters * <span class="tt">validators</span>, a boolean</p></div><div id="rfc.section.2.2.1.p.2" class="avoidbreakafter"><p>we can determine whether there is a match in the digest using the following algorithm:</p></div><div id="rfc.section.2.2.1.p.3"><ol><li>Read the first 5 bits of <span class="tt">digest-value</span> as an integer; let <span class="tt">N</span> be two raised to the power of that value.</li><li>Read the next 5 bits of <span class="tt">digest-value</span> as an integer; let <span class="tt">P</span> be two raised to the power of that value.</li><li>Let <span class="tt">hash-value</span> be the result of computing a hash value (<a href="#hash" title="Computing a Hash Value">Section&nbsp;2.1.2</a>).</li><li>Let <span class="tt">C</span> be -1.</li><li>Read ‘0’ bits from <span class="tt">digest-value</span> until a ‘1’ bit is found; let <span class="tt">Q</span> bit the number of ‘0’ bits. Discard the ‘1’.</li><li>Read log2(<span class="tt">P</span>) bits from <span class="tt">digest-value</span> after the ‘1’ as an integer; let <span class="tt">R</span> be its value.</li><li>Let <span class="tt">D</span> be <span class="tt">Q</span> * <span class="tt">P</span> + <span class="tt">R</span>.</li><li>Increment <span class="tt">C</span> by <span class="tt">D</span> + 1.</li><li>If <span class="tt">C</span> is equal to <span class="tt">hash-value</span>, return ‘true’.</li><li>Otherwise, return to step 5 and continue processing; if no match is found before <span class="tt">digest-value</span> is exhausted, return ‘false’.</li></ol></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.3.p.1"><p>This draft currently has no requirements for IANA. If the CACHE_DIGEST frame is standardised, it will need to be assigned a frame type.</p></div></section><section id="security-considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.4.p.1"><p>The contents of a User Agent’s cache can be used to re-identify or “fingerprint” the user over time, even when other identifiers (e.g., Cookies <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>) are cleared.</p></div><div id="rfc.section.4.p.2"><p>CACHE_DIGEST allows such cache-based fingerprinting to become passive, since it allows the server to discover the state of the client’s cache without any visible change in server behaviour.</p></div><div id="rfc.section.4.p.3"><p>As a result, clients MUST mitigate for this threat when the user attempts to remove identifiers (e.g., “clearing cookies”). This could be achieved in a number of ways; for example: by clearing the cache, by changing one or both of N and P, or by adding new, synthetic entries to the digest to change its contents.</p></div><div id="rfc.section.4.p.4"><p>TODO: discuss how effective the suggested mitigations actually would be.</p></div><div id="rfc.section.4.p.5"><p>Additionally, User Agents SHOULD NOT send CACHE_DIGEST when in “privacy mode.”</p></div></section><section id="rfc.references"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a> Normative References</h3><dl class="dl-horizontal"><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC3986">[RFC3986]</dt><dd>Berners-Lee, T., Fielding, R., and L. Masinter, “<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>”, STD&nbsp;66, RFC&nbsp;3986, <a href="http://dx.doi.org/10.17487/RFC3986">DOI&nbsp;10.17487/RFC3986</a>, January&nbsp;2005, &lt;<a href="http://www.rfc-editor.org/info/rfc3986">http://www.rfc-editor.org/info/rfc3986</a>&gt;.</dd><dt id="RFC6234">[RFC6234]</dt><dd>Eastlake 3rd, D. and T. Hansen, “<a href="https://tools.ietf.org/html/rfc6234">US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a>”, RFC&nbsp;6234, <a href="http://dx.doi.org/10.17487/RFC6234">DOI&nbsp;10.17487/RFC6234</a>, May&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6234">http://www.rfc-editor.org/info/rfc6234</a>&gt;.</dd><dt id="RFC6454">[RFC6454]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>”, RFC&nbsp;6454, <a href="http://dx.doi.org/10.17487/RFC6454">DOI&nbsp;10.17487/RFC6454</a>, December&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6454">http://www.rfc-editor.org/info/rfc6454</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7232">[RFC7232]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7232">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>”, RFC&nbsp;7232, <a href="http://dx.doi.org/10.17487/RFC7232">DOI&nbsp;10.17487/RFC7232</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7232">http://www.rfc-editor.org/info/rfc7232</a>&gt;.</dd><dt id="RFC7234">[RFC7234]</dt><dd>Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="http://www.rfc-editor.org/info/rfc7540">http://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a> Informative References</h3><dl class="dl-horizontal"><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6265">http://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd></dl></section></section><section id="acknowledgements"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.A.p.1"><p>Thanks to Adam Langley and Giovanni Bajo for their explorations of Golumb-coded sets. In particular, see <a href="http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters">http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters</a>, which refers to sample code.</p></div><div id="rfc.section.A.p.2"><p>Thanks to Stefan Eissing for his suggestions.</p></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><p><b>Kazuho Oku</b><br>DeNA Co, Ltd.<br>EMail: <a href="mailto:kazuhooku@gmail.com">kazuhooku@gmail.com</a></p><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></p></section></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script></body></html>