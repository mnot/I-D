{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-09T00:20:04.017521+00:00",
  "repo": "mnot/I-D",
  "labels": [
    {
      "name": "http-problem",
      "description": null,
      "color": "444444"
    },
    {
      "name": "rfc5988bis",
      "description": null,
      "color": "0052cc"
    },
    {
      "name": "Key",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "alt-svc",
      "description": null,
      "color": "009800"
    },
    {
      "name": "safe-hint",
      "description": null,
      "color": "eb6420"
    },
    {
      "name": "wpd",
      "description": null,
      "color": "5319e7"
    },
    {
      "name": "json-home",
      "description": null,
      "color": "bfdadc"
    },
    {
      "name": "ecc",
      "description": null,
      "color": "bfd4f2"
    },
    {
      "name": "onion",
      "description": null,
      "color": "bfe5bf"
    },
    {
      "name": "for-the-users",
      "description": null,
      "color": "5319e7"
    },
    {
      "name": "h2-vpn",
      "description": null,
      "color": "d4c5f9"
    },
    {
      "name": "tmi",
      "description": null,
      "color": "e11d21"
    },
    {
      "name": "http-options-resources",
      "description": null,
      "color": "f7c6c7"
    },
    {
      "name": "h2-cache-digest",
      "description": null,
      "color": "fef2c0"
    },
    {
      "name": "bcp56bis",
      "description": null,
      "color": "b60205"
    },
    {
      "name": "variants",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "structured-headers",
      "description": null,
      "color": "45aad8"
    },
    {
      "name": "well-known",
      "description": null,
      "color": "af62d1"
    },
    {
      "name": "link-hint",
      "description": "",
      "color": "c2e0c6"
    },
    {
      "name": "secret-token",
      "description": "",
      "color": "ce7644"
    },
    {
      "name": "cache-header",
      "description": "",
      "color": "4680ba"
    },
    {
      "name": "proxy-status",
      "description": "",
      "color": "bfd4f2"
    },
    {
      "name": "rfc7320bis",
      "description": "",
      "color": "0e8a16"
    },
    {
      "name": "binary-structured-headers",
      "description": "",
      "color": "cc475f"
    },
    {
      "name": "retrofit",
      "description": "",
      "color": "1d76db"
    },
    {
      "name": "availability-hints",
      "description": "",
      "color": "F5A522"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU0NDg1NzQx",
      "title": "Feedback from d lutterkort",
      "url": "https://github.com/mnot/I-D/issues/1",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "I like where this is going - if you want to use the body, you should\nalso define an XML version of this; if a client requests\napplication/xml, and the server encounters a problem, it seems weird to\nsend JSON back.\n\nWhy serialise this into a Link header ? Why not Problem-describedby,\nProblem-title etc. ? For simple clients, that's much easier to deal\nwith.\n\nI would have the following rules, so that clients have firmer ground to\nstand on:\n     \\* Always send the problem back in the header\n     \\* If client asked for JSON or XML, send a body back that contains\n       the problem details as described in the draft; applications can\n       add more to that if they want to.\n",
      "createdAt": "2012-05-09T03:00:23Z",
      "updatedAt": "2013-11-25T23:14:12Z",
      "closedAt": "2013-11-25T23:14:12Z",
      "comments": [
        {
          "author": "nickl-",
          "authorAssociation": "NONE",
          "body": "I assume he is referring to HTTP Problem, brilliant stuff, we were just this week debating over what to use and to what extent we could be more helpful instead of just 4xx while staying compliant. Tolerant applications, lets not change that please!  \n\n@mnot you're on a roll! Love the json home page too awesome stuff! Keep up the good work!\n\nThe gentleman has a point though as to why don't we have simpler messages in plain text even? What happened to \ntext/uri-list defined in [RFC2483](http://pretty-rfc.herokuapp.com/RFC2483) I am not going to argue about it's contents only that the mime type still exists and it is really wicked in it's simplicity.  \n\n>  As for all text/\\* formats, lines are terminated with a CRLF pair.\n> \n>   In applications where one URI has been mapped to a list of URIs, the\n>     first line of the text/uri-list response SHOULD be a comment giving\n>     the original URI.\n> \n>   An example of the format is given below:\n\n```\n      # urn:isbn:0-201-08372-8\n      http://www.huh.org/books/foo.html\n      http://www.huh.org/books/foo.pdf\n      ftp://ftp.foo.org/books/foo.txt\n```\n\nEven markdown will render those absolute urls as links so why not include this as an option. The saddest part is that we have this mime type but can't use it, chrome spits it right out at the first sight of text/uri-list. Sad indeed...\n\nDon't slow down now viva le revolution! Shout if you need a hand with anything.\n",
          "createdAt": "2012-06-24T01:26:00Z",
          "updatedAt": "2012-06-24T01:26:00Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "not that this makes a real difference because it's all up to the server anyway, but i would expect that problem reports might be more interesting/rich for 5xx errors than for 4xx errors. for 5xx, servers could actually report on a specific problem they experienced; for 4xx, they could merely report on a violated constraint/precondition (which of course might be very useful as well).\n",
          "createdAt": "2012-10-25T18:15:28Z",
          "updatedAt": "2012-10-25T18:15:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "We didn't end up going in this direction, so closing the issue.\n",
          "createdAt": "2013-11-25T23:14:12Z",
          "updatedAt": "2013-11-25T23:14:12Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU1MzU0NzA1",
      "title": "Mime type name inconsistent in http problem section 9",
      "url": "https://github.com/mnot/I-D/issues/2",
      "state": "CLOSED",
      "author": "pezra",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "listed as `application/json-problem` but then the sub-type is declared as `problem+json`\n",
      "createdAt": "2012-06-29T15:46:03Z",
      "updatedAt": "2017-02-24T05:58:56Z",
      "closedAt": "2012-07-03T19:04:37Z",
      "comments": [
        {
          "author": "pezra",
          "authorAssociation": "NONE",
          "body": "Fwiw, i very much prefer `application/problem+json`.\n",
          "createdAt": "2012-06-29T16:10:28Z",
          "updatedAt": "2012-06-29T16:10:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Fixed, thanks. +json doesn't quite yet exist.\n",
          "createdAt": "2012-07-03T19:04:37Z",
          "updatedAt": "2012-07-03T19:04:37Z"
        },
        {
          "author": "pezra",
          "authorAssociation": "NONE",
          "body": "By what definition does '+json' not exist? Its meaning is convention rather than normative, but there is absolutely no confusion about its meaning. In what sense does 'json-' exist if '+json' doesn't?\n",
          "createdAt": "2012-07-03T20:16:52Z",
          "updatedAt": "2012-07-03T20:16:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See:\n  http://trac.tools.ietf.org/html/draft-ietf-appsawg-media-type-suffix-regs-01\n\nThis registers the convention; it's not final yet.\n",
          "createdAt": "2012-07-03T20:34:54Z",
          "updatedAt": "2012-07-03T20:34:54Z"
        },
        {
          "author": "pezra",
          "authorAssociation": "NONE",
          "body": "In that case i'd say jump on board the rough consensus.\n\nOn Tuesday, July 3, 2012, Mark Nottingham wrote:\n\n> See:\n> \n> http://trac.tools.ietf.org/html/draft-ietf-appsawg-media-type-suffix-regs-01\n> \n> This registers the convention; it's not final yet.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/mnot/I-D/issues/2#issuecomment-6745782\n",
          "createdAt": "2012-07-03T20:39:44Z",
          "updatedAt": "2012-07-03T20:39:44Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NjE3OTc5",
      "title": "[json-home] post draft-02",
      "url": "https://github.com/mnot/I-D/issues/3",
      "state": "CLOSED",
      "author": "nickl-",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "# Well done!\n\nI was totally caught by surprise to see the document number ++, you made my day. =)\n\nYou can consider me an early adopter so I did some research trying to imagine where this might end up and  this is the resulting document for your perusal. \n\nThe following considerations were made and  guidelines followed:\n1. I only reused items from existing specifications which I consider to be suitable additions. ymmv\n2. The relevant references have been added sparingly with my illegal comments. Should you require more detail, I can oblige.\n3. I chose to use URNs (RFC2141) instead to differentiate, between type identifiers and links. \n4. I've added a header \"property\" as per RFC6415, with general links which relate to all resources.\n\nThe result is speculative only in hope to be utilized as a basis for further discussion which I'll continue on list @apps-discuss unless you have another preference. \n\n``` json\n\n{\n  \"expires\":\"2012-06-07T09:30:00Z\", \n  \"urn:fooapi:property\": {             // urn RFC2141 RFC6415 \n    \"titles\":{\n      \"default\":\"FOO Api\",\n      \"en-us\":\"FOO Api\"\n    },\n    \"type\": \"http://protocol.example.net/version\",                     \n    \"copyright\": \"http://example.com/copyright\",                       \n    \"version\": \"0.1.0\",                                                \n    \"license\":{                                   //RFC 4946 \n      \"type\": \"application/rdf+xml\",\n      \"href\": \"http://creativecommons.org/licenses/by-nc/2.5/rdf\"\n    },\n    \"disclosure\": {                               //RFC 6579\n      \"href\": \"http://example.org/ipr/meta-spec\",\n      \"title\": \"Patent Disclosures List\"\n    },\n    \"hub\": {\"href\": \"http://example.com/hub\"},                         \n    \"monitor\": {                                  //RFC 5989\n      \"href\": \"http://www.example.com/pet-profiles/alpacas/\",          \n      \"hinst\":{\n        \"allow\": [\"GET\", \"SUBSCRIBE\", \"PUBLISH\"]\n    },\n    \"lrdd\": {\"href-template\": \"http://example.com/lrdd{?uri}\"},     \n    \"author\": {\"href-template\": \"http://example.com/author{?uri}\"}, \n    \"edit\": {\n      \"href\": \"http://example.com/edit{?uri}\",\n      \"hints\": { \"allow\": [\"GET\"], \"representations\": [\"text/html\"]}\n     }\n  },\n  \"resources\": {\n    \"urn:fooapi:widgets\": {\n      \"href\": \"/widgets/\",\n      \"paging\": {          //RFC 5005 5988\n        \"link\": {         \n          \"rel\": \"prev\",\n          \"title\": \"Prev\",\n          \"hreflang\": \"en\",\n          \"media\": \"all\",\n          \"charset\": \"utf-8\",\n          \"type\": \"application/json\",\n          \"href-template\": \"{?offset,limit}\",\n          \"href\": \"?offset=0&limit=10\"\n        },\n        \"link\": {        \n          \"rel\": \"next\",\n          \"title\": \"Next\",\n          \"hreflang\": \"en\",\n          \"media\": \"all\",\n          \"charset\": \"utf-8\",\n          \"type\": \"application/json\",\n          \"href-template\": \"{?offset,limit}\",\n          \"href\": \"?offset=20&limit=10\"\n        },\n        \"link\": {        \n          \"rel\": \"section\",\n          \"title\": \"Section\",\n          \"hreflang\": \"en\",\n          \"media\": \"all\",\n          \"charset\": \"utf-8\",\n          \"type\": \"application/json\",\n          \"href-template\": \"{?section}\",\n          \"href\": \"?section=10\"\n        },\n        \"start\": \"http://example.com/start\",\n        \"current\": { \"href\": \"./\"},\n        \"last\": \"http://example.com/last\",\n        \"first\": \"http://example.com/first\"\n      },\n      \"hints\": {\n        \"allow\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n        \"representations\": [\"application/json\",\"text/html\"],\n        \"accept-language\": [\"en\"],\n        \"accept-post\": [\"application/json\"]\n      }\n    },\n    \"urn:fooapi:widget\": {\n      \"titles\":{\n        \"default\":\"The Widgets API\", \n        \"nl\":\"Het Widgets API\", \n      }, \n      \"href-template\": \"/widgets/{widgetId}\",\n      \"href-vars\": {\n        \"productRoomId\": \"urn:fooapi:param@widgets\"\n      },\n      \"revisions\": {        //RFC 5829\n        \"version-history\": \"/widgets/{widgetId}/revisions\",           \n        \"latest-version\": \"/widgets/{widgetId}/latest\",               \n        \"working-copy\": \"/widgets/{widgetId}/draft\",                  \n        \"working-copy-of\": \"/widgets/{widgetId}/draft-of\" ,           \n        \"predecessor-version\": \"/widgets/{widgetId}/prev\",         \n        \"successor-version\": \"/widgets/{widgetId}/next\"              \n      },\n      \"hints\": {\n        \"allow\": [\"GET\", \"PUT\", \"DELETE\", \"PATCH\"],\n        \"representations\": [\"application/json\", \"text/html\", \"application/json-home\"],\n        \"accept-patch\": [\"application/json-patch\"],\n        \"accept-put\": [\"application/json\"],\n        \"accept-ranges\": [\"bytes\"],\n        \"prefer\": [\"return-asynch\", \"return-minimal\", \"return-representation\", \"wait\", \"strict\", \"lenient\"],\n        \"docs\": \"http://example.com/docs\", // help?? [W3C.REC-html401-19991224](http://www.w3.org/TR/html5/links.html#link-type-help)\n        \"precondition-req\": [\"etag\", \"last-modified\"],\n        \"auth-req\": [{ \"scheme\": \"Basic\",\"realms\": [\"private\"]}],\n        \"status\": \"development\"\n      }\n    }\n  }\n}\n```\n",
      "createdAt": "2012-07-14T04:39:11Z",
      "updatedAt": "2017-02-24T05:59:28Z",
      "closedAt": "2012-09-05T06:05:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Cool, thanks!\n\nThis makes me think that it'd be interesting to allow links between resources to be expressed in the home doc as well.\n\nWill talk more on the list.\n",
          "createdAt": "2012-09-05T06:05:41Z",
          "updatedAt": "2012-09-05T06:05:41Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU2NzkxNjQx",
      "title": "Http-key",
      "url": "https://github.com/mnot/I-D/issues/6",
      "state": "CLOSED",
      "author": "jasnell",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Draft looks ok initially... a couple of points, however:\n1. Consider using the name Cache-Key instead of just Key. There are many types of keys and it's better to be clear and specific.\n2. The predicate syntax seems rather complicated. In theory it's fine but I'm having a difficult time imagining people using this in practice even for simple cases and can imagine a number of ways where it could go wrong. Especially since we have a hard enough time getting people to use vary properly as it is.\n",
      "createdAt": "2012-09-11T14:07:46Z",
      "updatedAt": "2017-02-24T05:59:15Z",
      "closedAt": "2012-11-13T12:02:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It's _not_ just a cache key; just as Vary does, it identifies the aspects of the request that helped select the response.\n\nAlso, Key is shorter. IIRC Roy has strong feelings about that...\n\nWRT predicate syntax - do you have a concrete suggestion? Roy originally talked about a regex-like syntax (not full regex), but the http parameter syntax uses existing parsers.\n",
          "createdAt": "2012-09-12T00:04:16Z",
          "updatedAt": "2012-09-12T00:04:16Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm.. well, Key is rather ambiguous really. Not sure what alternative name could work, however, so I guess I'll leave that one alone for now.\n\nOn the predicate syntax... I guess the thing that I'm struggling with the most is whether people will go through the trouble of actually using the predicates properly. As I said, we can barely get people to use Vary properly and that's just header field names, let alone value matching of specific parameters and so forth. \n\nQuestion: what if we're selecting a Header field that uses a non-ascii encoding? For example Link with a UTF-8 title parameter. How would that work exactly? Given that different fields allow for different encoding schemes, would I just use something like w*=\"...\" and depend on the implementation to decode everything prior to matching? \n\nComment: I do see that you changed the case for 'c' and 'n' .. thanks for that .. \n",
          "createdAt": "2012-09-12T00:51:57Z",
          "updatedAt": "2012-09-12T00:51:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hopefully, Key will be automagically generated by implementations, rather than be set by hand by authors. I do think we might have a semicolon-delimited selector (i.e., use everything before the first parameter, stripping whitespace) in the next draft, so that this fairly common syntactic convention can be easily dealt with correctly. Slightly more out there would be qvalue comparison, but I don't know if we need that yet.\n\nWRT non-ascii encoding -- while it's out there, I don't think it's likely in a selecting request header, and if it is, someone can always do an extension modifier.\n",
          "createdAt": "2012-09-13T04:00:07Z",
          "updatedAt": "2012-09-13T04:00:07Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWUxNTE0MzcwNw==",
      "title": "Key: support \"OR\" operator",
      "url": "https://github.com/mnot/I-D/issues/21",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "> a cache that implements the Key header field MUST NOT use a stored response unless all of the selecting header fields nominated by the Key header field match in both the original request (i.e., that associated with the stored response) and the presented request.\n\nAbove behavior dictates \"AND\" operation on all of the Key parameters. What about \"OR\"? For example, what if I wanted the response to be cached for multiple UA's - e.g. Android, iPhone. \n\n> Key: user-agent;s=\"Android\";s=\"iPhone\"  (Android AND iPhone)\n> Key: user-agent;s=\"Android\";o;s=\"iPhone\" (Android OR iPhone)\n\nFirst example is an implicit AND, and wouldn't be satisfied for any UA.. Whereas, what we're actually after is the second case, where we want the cache to serve the response to multiple different UA's. Q: is there a reason why \"OR\" is omitted in current spec? Could / should we add a parameter (\"o\" in above example) to support this?\n",
      "createdAt": "2013-06-04T22:01:08Z",
      "updatedAt": "2015-10-19T05:13:48Z",
      "closedAt": "2015-10-19T05:13:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "On both of these, it seems like the use case is UA sniffing. I thought the purpose of Client-Hints was to move away from that.\n\nMy biggest concern is complexity; it gives the spec and implementers more opportunity to stuff things up.\n",
          "createdAt": "2013-06-05T00:27:25Z",
          "updatedAt": "2013-06-05T00:27:25Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "Well, I would argue that \"OR\" has nothing to with CH or UA sniffing. Another example could be: cache and return this response for any user with \"cookie A\" _or_ \"cookie B\". I understand the concern over complexity, but I think this is a pretty big gap. Also, implementation wise, if you're implementing AND.. adding OR seems trivial - it's an extra early return statement for cases where any one of the conditions matches?\n",
          "createdAt": "2013-06-05T00:46:56Z",
          "updatedAt": "2013-06-05T00:46:56Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "(dropped the algorithm part ...)\n\nRe, CH: UA is not going away either, and there are still cases where you may want to target specific versions of a browser. I do think OR is a necessary piece. \n",
          "createdAt": "2013-06-06T21:40:28Z",
          "updatedAt": "2013-06-06T21:40:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving discussion to https://github.com/httpwg/http-extensions/issues/104\n",
          "createdAt": "2015-10-19T05:13:41Z",
          "updatedAt": "2015-10-19T05:13:41Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWUxNTk1NjgyMg==",
      "title": "problem: media type",
      "url": "https://github.com/mnot/I-D/issues/23",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "application/problem+json has been suggested.\n",
      "createdAt": "2013-06-25T01:12:26Z",
      "updatedAt": "2013-12-10T18:52:02Z",
      "closedAt": "2013-12-09T05:48:30Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe better (because more concise) than api-problem+*, but i easily could go either way.\n",
          "createdAt": "2013-11-26T00:37:15Z",
          "updatedAt": "2013-11-26T00:37:15Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "looks good, thanks!\n",
          "createdAt": "2013-12-10T18:52:02Z",
          "updatedAt": "2013-12-10T18:52:02Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWUxNTk1OTgyOQ==",
      "title": "Key: Clarify Cacheability",
      "url": "https://github.com/mnot/I-D/issues/24",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "From Eric Lawrence:\n\nThe spec doesn\u2019t clearly state what happens in the case that the original request didn\u2019t match the key on the response (There\u2019s language which implies that this rule means the response is not cacheable).\n",
      "createdAt": "2013-06-25T03:35:33Z",
      "updatedAt": "2015-09-02T03:59:51Z",
      "closedAt": "2015-09-02T03:59:51Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not relevant in -03 any more.\n",
          "createdAt": "2015-09-02T03:59:51Z",
          "updatedAt": "2015-09-02T03:59:51Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWUxNTk2MDEwNw==",
      "title": "Key: drop requirement to keep original request headers around",
      "url": "https://github.com/mnot/I-D/issues/25",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "This would greatly simplify the model and implementations (browsers are reluctant to keep all that extra state around).\n\nMain downside would be that \n\n```\nKey: Foo, Bar\n```\n\nand\n    Vary: Foo, Bar\n\nwouldn't mean the same thing any more (but I think that's just aesthetic).\n",
      "createdAt": "2013-06-25T03:50:12Z",
      "updatedAt": "2015-09-02T03:49:30Z",
      "closedAt": "2015-09-02T03:49:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Taken care of in -03-to-be.\n",
          "createdAt": "2015-09-02T03:49:30Z",
          "updatedAt": "2015-09-02T03:49:30Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWUxOTg0NzczNQ==",
      "title": "embedding of \"HTTP Problem\" data",
      "url": "https://github.com/mnot/I-D/issues/28",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "the HTTP problem draft currently defines standalone structures in JSON and XML, intended to be served as responses with their own media type. maybe it would be helpful to address the question whether the JSON or XML also could be embedded in other media types. i guess technically there's nothing the draft could do to disallow this. but it might be interesting to address this question openly and answer it, so that people wondering about this might find some guidance.\n",
      "createdAt": "2013-09-21T00:20:28Z",
      "updatedAt": "2013-12-09T05:46:16Z",
      "closedAt": "2013-12-09T05:46:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hm. In JSON, there isn't any name-spacing capability, so it would be done by referencing it in the docs of the \"parent\" format.\n\nIn XML, it should be done that way too, but of course namespaces would make that more technically apparent (even to apps that didn't read the docs, in theory).\n\nI think the question is whether we want to encourage this use; as you say, nothing in the draft stops it (or could). \n\nI'm not against it, _as long as_ there's an illustration of a reasonable use case along with it.\n",
          "createdAt": "2013-09-21T06:18:52Z",
          "updatedAt": "2013-09-21T06:18:52Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "embedding problem data in html would seem to be the most useful case... following a similar approach to what google has done as illustrated here https://developers.google.com/gmail/actions/embedding-schemas-in-emails.\n\nEssentially, you could embed problem data as json directly...\n\n```\n<html>\n  <body>\n    <script type=\"application/api-problem+json\">\n   {\n    \"describedBy\": \"http://example.com/probs/out-of-credit\",\n    \"title\": \"You do not have enough credit.\",\n    \"detail\": \"Your current balance is 30, but that costs 50.\",\n    \"supportId\": \"http://example.net/account/12345/msgs/abc\",\n    \"balance\": 30,\n    \"account\": \"http://example.net/account/12345\"\n   }\n    </script>\n  ...\n```\n\nOr one could easily come up with a microdata vocab for problems. Wouldn't be too difficult\n",
          "createdAt": "2013-09-21T15:22:32Z",
          "updatedAt": "2013-09-21T15:22:32Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Without the benefit of coffee... one could easily come up with something like...\n\n```\n<div class=\"problem\">\n  <span class=\"title\">Your <a class=\"account\" href=\"http://example.net/account/12345\">account</a> <a rel=\"describedBy\" href=\"http://example.com/probs/out-of-credit\">does not have enough credit</a>.</span>\n  <span class=\"detail\">Your current balance is <span class=\"balance\">30</span>, but that costs 50.</span>\n  <a rel=\"support\" href=\"http://example.net/account/12345/msgs/abc\">Click here</a> for more information.\n</div>\n```\n",
          "createdAt": "2013-09-21T15:30:54Z",
          "updatedAt": "2013-09-21T15:30:54Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i guess @jasnell just gave us some use case. in addition, we have something in a JSON API where people want to include a \"status\" section in pretty much all responses, including (some of the) information that the fixed back-end provides. that's something they'll do anyway, and my suggestion was to reuse HTTP Problem by referencing it in the API doc, instead of re-inventing pretty much the exact same structures. also, we could then use HTTP Problem problemType URIs consistently for all responses (embedded ones as well as the ones that actually serve an HTTP Problem media type), which i think is a nice touch and improves consistency.\n",
          "createdAt": "2013-09-21T16:32:38Z",
          "updatedAt": "2013-09-21T16:32:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm not sure that's so much of a use case as it is an example of how to do it... _Why_ would someone do this?\n",
          "createdAt": "2013-09-22T10:02:41Z",
          "updatedAt": "2013-09-22T10:02:41Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only _why_ I could offer is use of a consistent error reporting model across modes. Not critically important, by any means, but could be useful.\n",
          "createdAt": "2013-09-22T21:28:28Z",
          "updatedAt": "2013-09-22T21:28:28Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jasnell, that's exactly the reason why i had people being interested in this embedding model. if for some reason they decide they want to have this rather static \"status report\" section, then they can either come up with their own model, or adapt the draft's one. since we cannot prevent anybody from adapting it, it might as well be mentioned in the draft, maybe simply mentioning that the overall model (what is mandatory and optional, and how extensions can be used) should be preserved.\n",
          "createdAt": "2013-09-28T17:38:38Z",
          "updatedAt": "2013-09-28T17:38:38Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUyMzIyMDEwNw==",
      "title": "IRIs or URIs?",
      "url": "https://github.com/mnot/I-D/issues/32",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "5988 specifies links in terms of IRIs. Is this the right thing, or should they be URIs?\n",
      "createdAt": "2013-11-25T03:08:14Z",
      "updatedAt": "2015-10-16T00:10:09Z",
      "closedAt": "2015-10-16T00:10:09Z",
      "comments": [
        {
          "author": "masinter",
          "authorAssociation": "NONE",
          "body": "http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-17#section-3.2.1\nand all before: \" Newly defined header fields SHOULD limit their field values to US-ASCII octets.\"\n\nAn IRI that isn't a URI contains non-ASCII characters. \"Link:\" is a (relatively) new header field, the octets should be recommended at least to be URIs, not IRIs.\n",
          "createdAt": "2013-11-25T05:15:09Z",
          "updatedAt": "2013-11-25T05:15:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Right. The counter-argument here is that links are conveyed in a lot more than HTTP headers; e.g., in HTML and Atom. The question is whether those formats should convert from IRI to URI _before_ considering them RFC5988 links.\n",
          "createdAt": "2013-11-25T06:07:33Z",
          "updatedAt": "2013-11-25T06:07:33Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "-1 to changing to URI only. I have implementations written to assume IRI. I see no justification for adding this limitation.\n",
          "createdAt": "2013-11-25T16:21:43Z",
          "updatedAt": "2013-11-25T16:21:43Z"
        },
        {
          "author": "masinter",
          "authorAssociation": "NONE",
          "body": "Fine..\n",
          "createdAt": "2013-11-25T20:59:05Z",
          "updatedAt": "2013-11-25T20:59:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Fundamentally, this issue is the time-worn URI/IRI issue -- is there any semantic difference between a IRI and the URI it can be transformed into?\n\nAIUI current IETF thinking is that IRIs are a \"presentation artefact\" -- i.e., they belong in UIs, not as protocol artefacts (keeping in mind that markup languages like HTML are considered UIs for authors). \n\nNot sure if we'll be able to resolve this until there's a definitive answer elsewhere, though.\n",
          "createdAt": "2013-11-25T23:12:42Z",
          "updatedAt": "2013-11-25T23:12:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I feel like this might be resolved with a note in the Internationalisation Considerations and/or Extension Relation Types sections to the effect of \"If you use an IRI for an extension relation type, be aware that it may cause problems.\" \n\nFor targets and contexts, we can't disallow IRIs; we can note that they need to be handled carefully in some systems.\n",
          "createdAt": "2014-10-28T01:17:40Z",
          "updatedAt": "2014-10-28T01:17:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Huh. Internationalisation Considerations in 5988 already says:\n\n> Relation types are defined as URIs, not IRIs, to aid in their comparison.  It is not expected that they will be displayed to end users.\n\nSo, I think we can close this one.\n",
          "createdAt": "2015-10-16T00:10:09Z",
          "updatedAt": "2015-10-16T00:10:09Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUyMzIyMDEzNQ==",
      "title": "Parameter ABNF",
      "url": "https://github.com/mnot/I-D/issues/33",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "See:\n  http://www.rfc-editor.org/errata_search.php?rfc=5988&eid=3158\n",
      "createdAt": "2013-11-25T03:09:33Z",
      "updatedAt": "2017-05-14T07:59:06Z",
      "closedAt": "2016-11-22T07:22:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke do you want to take a stab at a pull request here?\n",
          "createdAt": "2014-10-28T00:52:47Z",
          "updatedAt": "2014-10-28T00:52:47Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I can do that.\n",
          "createdAt": "2014-10-28T07:27:40Z",
          "updatedAt": "2014-10-28T07:27:40Z"
        },
        {
          "author": "prushforth",
          "authorAssociation": "NONE",
          "body": "I entered a (rejected) erratum on the subject of the acceptable syntax for the media type parameter, here: http://www.rfc-editor.org/errata_search.php?rfc=5988 , number 4344.  I believe the discussion relating to the basis for rejecting my suggestion is in this thread:\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2010JanMar/0153.html\n\nHopefully a resolution can be found by allowing media type parameters in quoted-mt values - otherwise I can see the \"=\" and \";\" characters causing parser issues.\n\nThanks\n",
          "createdAt": "2015-04-23T13:10:03Z",
          "updatedAt": "2015-04-23T13:10:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke ping\n",
          "createdAt": "2015-10-16T00:16:48Z",
          "updatedAt": "2015-10-16T00:16:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke ping?\n",
          "createdAt": "2016-04-26T07:26:55Z",
          "updatedAt": "2016-04-26T07:26:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this is not super-easy due to how the spec is structured, and because making things generic is indeed breaking a few edge cases. I'd start with something like:\n\n# Link Serialisation in HTTP Headers {#header}\n\nThe Link header field provides a means for serialising one or more links into HTTP headers.\n\nThe ABNF for the field value is given below:\n\n``` abnf2616\n    Link           = #link-value\n    link-value     = \"<\" URI-Reference \">\" OWS *( OWS \";\" OWS link-param )\n  link-param     = token \"=\" ( token / quoted-string )\n```\n\nThis specification defines the parameters \"rel\", \"anchor\", \"rev\", \"hreflang\",\n\"media\", \"title\", \"title*\", and \"type\".\n\nABNF for \"rel\" and \"rev\" parameter values:\n\n``` abnf2616\n    rel            = relation-typ *( 1*SP relation-type )\n    rev            = relation-typ *( 1*SP relation-type )\n\n    relation-type  = reg-rel-type | ext-rel-type\n    reg-rel-type   = LOALPHA *( LOALPHA | DIGIT | \".\" | \"-\" )\n    ext-rel-type   = URI\n```\n\nABNF for \"anchor\" parameter:\n\n``` abnf2616\n  anchor         = URI-Reference\n```\n\nABNF for \"hreflang\" parameter:\n\n``` abnf2616\n  hreflang       = Language-Tag\n```\n\nABNF for \"media\" parameter:\n\n``` abnf2616\n  media          = media_query_list\n```\n\nABNF for \"type\" parameter:\n\n``` abnf2616\n    type           = media-type\n```\n\nTODO:\n- integrate value ABNFs into parameter descriptions\n- explains what's changed by making things generic: (1) certain things can appear as token, (2) where 5988 specified quotes, it failed to discuss quoted-string handling, (3) media-type by definition would need to be quoted, as \"/\" is not a token character\n",
          "createdAt": "2016-11-16T01:25:40Z",
          "updatedAt": "2016-11-16T01:25:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Seems reasonable to me, thanks. I'll integrate and ref this issue, but keep it open to make sure I get it right.\n",
          "createdAt": "2016-11-16T04:36:12Z",
          "updatedAt": "2016-11-16T04:36:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "TODO:\n- [x] Change: certain things can appear as token\n- [x] Change: quoted string handling\n- [x] Change: media type needs to be quoted\n- [x] Specify RFC5987bis handling (see #180)\n- [x] import `media-type` or define it\n- [x] clean up imports (if necessary)\n- [x] integrate value ABNFs into parameter descriptions\n- [x] review the parsing algorithm to make sure it's still correct\n- [x] BWS around = ?\n",
          "createdAt": "2016-11-16T04:43:52Z",
          "updatedAt": "2016-11-22T07:22:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke thanks. You going to take a stab at `title` / `title*`, or wait for #180?\n",
          "createdAt": "2016-11-16T04:51:56Z",
          "updatedAt": "2016-11-16T04:51:56Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "well, the title value doesn't have an ABNF, for title\\* we can of course refer to rfc5987bis. \n",
          "createdAt": "2016-11-16T05:01:14Z",
          "updatedAt": "2016-11-16T05:01:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "```\n  title  = ( token / quoted-string )\n  title* = ext-value\n```\n\nwith an appropriate import? \n\nCan an ABNF rule name include \"*\"?\n\nAlso, 5987bis allows LWSP around `=` -- what about here (and on other link params)?\n",
          "createdAt": "2016-11-16T05:08:24Z",
          "updatedAt": "2016-11-16T05:08:24Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No; the param value ABNF should describe the syntax _after_ undoing quoted-string, thus for title there's no structure left to enforce.\n\nFor \"title*\", ext-value is correct.\n\nABNF rule names can not have \"*\", so maybe use \"title-star\".\n\nRFC5987bis doesn't contain this (ABNF about anything except ext-value) anymore. So it's up to the spec that uses the notation. Whether WSP around \"=\" is allowed varies a lot for the existing header fields. The best approach probably is to say \"BWS\" (-> https://greenbytes.de/tech/webdav/rfc7230.html#rule.whitespace)\n",
          "createdAt": "2016-11-16T05:19:33Z",
          "updatedAt": "2016-11-16T05:19:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I see. Will have a go.\n",
          "createdAt": "2016-11-16T05:27:50Z",
          "updatedAt": "2016-11-16T05:27:50Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, have a look at how we describe the syntax of cache-control directive values in RFC 7234... \n",
          "createdAt": "2016-11-16T05:30:30Z",
          "updatedAt": "2016-11-16T05:30:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke have a look. Still need to talk about 5987 encoding.\n",
          "createdAt": "2016-11-16T05:42:23Z",
          "updatedAt": "2016-11-16T05:42:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke currently:\n\n> \"<\" URI-Reference \">\" OWS *( OWS \";\" OWS link-param )\n\nIs the first `OWS` really necessary?\n\nAlso, thinking about putting BWS around URI-Reference.\n",
          "createdAt": "2016-11-16T06:55:15Z",
          "updatedAt": "2016-11-16T06:55:15Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1) No, it's not.\n\n2) BWS in front of doesn't make sense; leading whitespace is already consumed by parsing the message into field-name/field-value pairs (see https://greenbytes.de/tech/webdav/rfc7230.html#header.fields: \"header-field   = field-name \":\" OWS field-value OWS\").\n",
          "createdAt": "2016-11-16T07:03:38Z",
          "updatedAt": "2016-11-16T07:03:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I mean \n\n> \"<\" BWS URI-Reference BWS \">\"\n",
          "createdAt": "2016-11-16T07:12:14Z",
          "updatedAt": "2016-11-16T07:12:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, that looks like a really bad idea to me. Have you seen that in the wild?\n",
          "createdAt": "2016-11-16T10:19:00Z",
          "updatedAt": "2016-11-16T10:19:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not as such, but I suspect consumers will want to treat it leniently. Why does it look bad? Semantics seem clear...\n",
          "createdAt": "2016-11-17T06:17:04Z",
          "updatedAt": "2016-11-17T06:17:04Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, putting things into \"<\" and \">\" to me is quoting mechanism. Would you also say that \"a\" and \" a \" are equivalent? \n",
          "createdAt": "2016-11-17T06:23:45Z",
          "updatedAt": "2016-11-17T06:23:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "As URLs, yes. Remember, it's BWS.\n",
          "createdAt": "2016-11-17T06:28:37Z",
          "updatedAt": "2016-11-17T06:28:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, I just wrote code that uses the Link header field, based on RFC 5987. And it would break if the sender would add whitespace around the brackets. The proposed change IMHO violates the https://en.wikipedia.org/wiki/Principle_of_least_astonishment (while allowing whitespace around \"=\" does not...)\n",
          "createdAt": "2016-11-19T12:43:19Z",
          "updatedAt": "2016-11-19T12:44:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "RFC5988 is an Implied LWS spec, and \"<\" \">\" are separators. Your new code is too strict.",
          "createdAt": "2016-11-21T00:34:13Z",
          "updatedAt": "2016-11-21T00:34:22Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "They are in the RFC 2616 grammar, but in the Link header field they are used as quote characters, not separators.\r\n\r\nAlso, RFC 2616 states: \"Except where noted otherwise, linear white space (LWS) can be included between any two adjacent words (token or quoted-string), and between adjacent words and separators, without changing the interpretation of a field.\". However, the production in the spec is \r\n\r\n   \"<\" URI-Reference \">\"\r\n\r\nand URI-Reference is neither token nor quoted-string (if it was, there wouldn't have been any reason to add additional quoting).",
          "createdAt": "2016-11-21T06:47:37Z",
          "updatedAt": "2016-11-21T07:21:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "[Hmm](https://www.youtube.com/watch?v=ae8t-QKPVY4). OK.",
          "createdAt": "2016-11-22T06:50:34Z",
          "updatedAt": "2016-11-22T06:50:34Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Further notes:\r\n\r\n- \"_\" is not legal in a production name\r\n- use \"/\" instead of \"|\"",
          "createdAt": "2017-05-14T07:59:06Z",
          "updatedAt": "2017-05-14T07:59:06Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWUyMzIyMDE1Mg==",
      "title": "RFC2231 -> RFC5987",
      "url": "https://github.com/mnot/I-D/issues/34",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "See:\n  http://www.rfc-editor.org/errata_search.php?rfc=5988&eid=2630\n",
      "createdAt": "2013-11-25T03:10:29Z",
      "updatedAt": "2014-10-28T00:52:41Z",
      "closedAt": "2014-10-28T00:52:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Note that Julian might be working on RFC5987bis.\n",
          "createdAt": "2013-11-25T23:42:58Z",
          "updatedAt": "2013-11-25T23:42:58Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyMzIyMDE2Nw==",
      "title": "Case of registered relation names",
      "url": "https://github.com/mnot/I-D/issues/35",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "See:\n  http://www.rfc-editor.org/errata_search.php?rfc=5988&eid=3075\n",
      "createdAt": "2013-11-25T03:11:22Z",
      "updatedAt": "2014-10-28T00:52:41Z",
      "closedAt": "2014-10-28T00:52:41Z",
      "comments": [
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why is this an issue really? The spec already requires case-insensitive comparison of registered link relations.\n",
          "createdAt": "2013-11-25T16:24:02Z",
          "updatedAt": "2013-11-25T16:24:02Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWUyMzIyMDIxNA==",
      "title": "Link parameter registry",
      "url": "https://github.com/mnot/I-D/issues/36",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Is it time to add a registry for the namespace of link parameters?\n\nSee:\n- http://tools.ietf.org/html/draft-nottingham-link-hint\n- http://tools.ietf.org/html/rfc6690\n",
      "createdAt": "2013-11-25T03:14:11Z",
      "updatedAt": "2016-05-17T06:57:13Z",
      "closedAt": "2016-05-17T06:57:13Z",
      "comments": [
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+0 ... don't really see this as being critical at the moment. There really aren't a lot of extension link parameters being used just yet. \n",
          "createdAt": "2013-11-25T16:29:46Z",
          "updatedAt": "2013-11-25T16:29:46Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "it's kind of hard to say how many are used, right? one way to look at \"link parameters\" or \"link hints\" is to look at them as \"unary links\" that are associated with the target resource, i.e. they make a statement about the target resource and not one about the source. looking at it this way, they are \"just links\", and it would be useful to treat them similar to regular web links, i.e. to allow values to be registered and thus to allow people to find out which values are available for reuse.\n",
          "createdAt": "2016-03-24T20:14:34Z",
          "updatedAt": "2016-03-24T20:14:34Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Considering how this steps into the realm of API documentation formats such as [Hydra](http://www.hydra-cg.com/), I'm not sure. If, by \"registry\", you mean \"IANA registry\", I actually see harm in defining a registry that will duplicate some of the efforts and semantics of [schema.org](http://schema.org/) and other vocabularies used in technologies built with, for example, RDF (such as the already mentioned Hydra).\n",
          "createdAt": "2016-03-29T12:28:35Z",
          "updatedAt": "2016-03-29T12:28:35Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-03-29 14:28, Asbj\u00f8rn Ulsberg wrote:\n\n> Considering how this steps into the realm of API documentation formats\n> such as Hydra http://www.hydra-cg.com/, I'm not sure. If, by\n> \"registry\", you mean \"IANA registry\", I actually see harm in defining a\n> registry that will duplicate some of the efforts and semantics of\n> schema.org http://schema.org/ and other vocabularies used in\n> technologies built with, for example, RDF (such as the already mentioned\n> Hydra).\n\nif there are existing registries for standardized \"link hints\", then it \nwould be good to link to them from this issue so that we can find out \nwhat's in there. i am not aware of any such registry, but if there were \none, then this certainly should be taken into account for any future \nwork on link hints.\n\none possible scenario we just discussed with @hvdsomp was the ability to \nindicate the \"schema\" followed by a resource. using RFC 5988's \"media\" \nhint, you can hint at a resource being JSON, but there's no way to \nindicate which schema it is using (assuming that the JSON is not \ndescribed by a more expressive media type). currently there's no support \nfor this in web linking. with a new hint (and a registry so that the \navailable set can evolve), that would be possible. the very same \nfacility may be useful for RDF as well, btw.\n\nit would be good if such a mechanism wasn't just specific for one single \nrepresentation, but instead would be reusable on the web. mark's draft \nproposed such a thing and probably would be a good addition to what's \navailable in the web architecture toolbox.\n",
          "createdAt": "2016-03-29T12:56:10Z",
          "updatedAt": "2016-03-29T12:56:10Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@dret, I wouldn't say the registries (or ontologies) are \"link hints\" per se, but there's definitely some overlap between link hints and a full-fledged API documentation format such as Hydra.\n\nI think the idea of pointing to a `schema` resource is a good one. What does @lanthaler, @elf-pavlik, @tpluscode, @RubenVerborgh and others involved with @HydraCG think of this?\n",
          "createdAt": "2016-03-30T07:01:23Z",
          "updatedAt": "2016-03-30T07:01:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-03-30 09:01, Asbj\u00f8rn Ulsberg wrote:\n\n> @dret https://github.com/dret, I wouldn't say the registries (or\n> ontologies) are \"link hints\" per se, but there's definitely some overlap\n> between link hints and a full-fledged API documentation format such as\n> Hydra.\n\nthat's what i wanted to say: in some of these models, \"link hints\" may \nbe used that would also be useful outside of that particular context. \nhaving \"links hints\" as something external (just like link relations) \nwould help with that.\n\nmy main concern is how to differentiate link hints from links. in \nessence, a link hint for a link from a to b is nothing but a statement \nabout resource b, so you might as well see it as an annotation (or in \nfact, a link) for resource b. in this sense, a link hint is not all that \ndifferent from a regular link, it simply is serialized/delivered \ndifferently.\n\nhttps://github.com/dret/hyperpedia/blob/master/concepts.md#target-resource-hints \nis an approach to put that into the bigger context of hypermedia models, \nbut i am sure there are different ways to see this as well.\n\n> I think the idea of pointing to a |schema| resource is a good one. What\n> does @lanthaler https://github.com/lanthaler, @elf-pavlik\n> https://github.com/elf-pavlik, @tpluscode\n> https://github.com/tpluscode, @RubenVerborgh\n> https://github.com/RubenVerborgh and others involved with @HydraCG\n> https://github.com/HydraCG think of this?\n\nas with profiles, i'd rather frame that in terms of \"identifying a \nschema\", but that's a detail to be discussed later.\n",
          "createdAt": "2016-03-30T07:54:31Z",
          "updatedAt": "2016-03-30T07:54:31Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Let's see if we can classify the different link types. I see the `Link` header as having two separate purposes:\n1. Reference an external resource (loosely) related to the current resource. The related resource is usually an entirely self-contained entity in and of itself and may often have links back to the resource that referenced it.\n2. Reference an external resource _describing_ the current resource in one way or another. The external resource describes the current resource in terms of semantics, schema, documentation or some other form that wouldn't make much sense in and of itself.\n\nThe first purpose is what I assume you mean when saying \"links\" and the second is what \"link hints\", external schemas, profiles, etc. would do. Since an external resource can do everything \"link hints\" can do and more, I'm leaning towards favoring that approach over \"link hints\".\n",
          "createdAt": "2016-03-31T05:37:37Z",
          "updatedAt": "2016-03-31T05:37:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "For me, the underlying issue is that right now, target attributes for a link are defined by:\n- The link header \n- HTML\n- Atom\n- individual link relations \n\nin a pretty uncoordinated fashion. This is awkward, because it has the possibility of collision -- especially, a parameter that has different syntax or even semantics depending on what serialisation the link occurs within.\n\nOTOH new serialisations are pretty rare, and we've got this far. \n\nI'm inclined to leave them uncoordinated for now, but to add text advising those creating new link relations on how they should treat target attributes, and also reinforcing that those maintaining/creating serialisations should coordinate their efforts where possible.\n",
          "createdAt": "2016-05-13T00:27:57Z",
          "updatedAt": "2016-05-13T00:27:57Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> add text advising those creating new link relations on how they should treat target attributes, and also reinforcing that those maintaining/creating serialisations should coordinate their efforts where possible.\n\n:+1: Some \"best practice\" guidance in an informative section would be good.\n",
          "createdAt": "2016-05-13T06:15:59Z",
          "updatedAt": "2016-05-13T06:15:59Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWUyMzIyMDIzNQ==",
      "title": "Application Data Registry",
      "url": "https://github.com/mnot/I-D/issues/37",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "This isn't being used, and the use case it was created for doesn't seem to have materialised. Can / should we get rid of it?\n",
      "createdAt": "2013-11-25T03:15:28Z",
      "updatedAt": "2015-11-12T14:21:43Z",
      "closedAt": "2014-10-28T00:52:41Z",
      "comments": [
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Considering that (a) the draft is extremely vague about what exactly app data is, and (b) I have zero idea what app data would be used for.. I'm +1 on getting rid of it.\n",
          "createdAt": "2013-11-25T16:30:48Z",
          "updatedAt": "2013-11-25T16:30:48Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "+1 I never did understand what it was for :-)\n",
          "createdAt": "2013-12-13T14:31:05Z",
          "updatedAt": "2013-12-13T14:31:05Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "same here: not quite sure what the idea is, and never seen it used, so removing/deprecating would be a good idea.\n",
          "createdAt": "2015-11-06T07:55:10Z",
          "updatedAt": "2015-11-06T07:55:10Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Before deciding whether the registry should be removed, could you outline the arguments for creating it in the first place? What is its purpose?\n",
          "createdAt": "2015-11-06T08:19:29Z",
          "updatedAt": "2015-11-06T08:19:29Z"
        },
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": ":+1: for removing unneeded registry.\n",
          "createdAt": "2015-11-06T18:14:04Z",
          "updatedAt": "2015-11-06T18:14:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@asbjornu it was supposed to address the needs of the HTML WG in adding different kinds of information to the registry; they ended up not using it. Note that the current draft still allows the experts to add new fields to the registry; it's just not so formally coordinated (which IMO is unnecessary).\n",
          "createdAt": "2015-11-12T00:19:39Z",
          "updatedAt": "2015-11-12T00:19:39Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Thanks for the information. Good to know. :)\n",
          "createdAt": "2015-11-12T14:21:43Z",
          "updatedAt": "2015-11-12T14:21:43Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUyMzI2MTg1OA==",
      "title": "link relations for RDF",
      "url": "https://github.com/mnot/I-D/issues/39",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "when working with the SemWeb/RDF community, it becomes obvious that link relations (and any other registries that manage concepts through non-URI identifiers) are a challenge for that community. even if they want to (re-)use those concepts, they cannot legally do so within RDF, because RDF requires identifiers to be URIs.\nwould it make sense to include something in RFC 5988bis that would allow RDF representations to use registered link relations as URIs? It would not be pretty to do that, because then on the web, registered link relations would be strings, and on the semantic web, they would be some form of equivalent URI. but maybe such a solution would be better than not doing anything, and making it impossible for RDF-based models to properly use registered link relations at all?\n",
      "createdAt": "2013-11-25T18:17:04Z",
      "updatedAt": "2023-12-25T12:47:57Z",
      "closedAt": "2015-10-15T23:35:07Z",
      "comments": [
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "I see no reason why 5988bis could not indicate that all registered link relations could be resolved to a URI such as  http://www.iana.org/assignments/link-relations/{relname}  or something like that.  In 5988 even extension link relations are not required to actually be serialized as URIs as long as there is some process to generate a URI identifier.   \n",
          "createdAt": "2013-12-13T14:27:53Z",
          "updatedAt": "2013-12-13T14:27:53Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, this approach was attempted in RFC4287 (http://tools.ietf.org/search/rfc4287#section-4.2.7) but exceedingly few implementers would actually treat the registered short form as being equivalent to the absolute URI form. In fact,  Apache Abdera is the only implementation I'm aware of that did. So the real question is: would implementers actually pay attention to this and implement it? I'm not so sure.\n",
          "createdAt": "2013-12-13T16:25:53Z",
          "updatedAt": "2013-12-13T16:25:53Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i was aware of the RFC 4287 history. and i am not proposing to re-instate what was done there. on the web, link relations should be continued to use as they are. but one could say how registered link relations are identified on the semantic web, and that really was all i wanted to propose. the URI identifiers would be for RDF only.\n",
          "createdAt": "2013-12-13T21:10:42Z",
          "updatedAt": "2013-12-13T21:10:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "\"Registered Relation Types\" could say something like:\n\n> Applications that wish to refer to registered relation types with a URI MAY do so by resolving them [ref to 3986] with the base URI \"http://www.iana.org/assignments/relation/\". Note that processors will not consider such URIs to be equivalent to their corresponding registered relation.\n",
          "createdAt": "2014-10-28T00:42:50Z",
          "updatedAt": "2014-10-28T00:42:50Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'd be more cautious than that, mark. i would be very specific about the fact that the URI version _are not_ the same as the RFC5988 identifiers, just to make sure that the URIs do not start creeping into the web and then we have interoperability problems. all i would say is for those who for some reason have painted themselves into a corner where they need URIs, here is a prefix you might want to use. and maybe that's exactly what you're saying, and i have no specific suggestion how to improve on that. i just would try to make sure as much as possible that the \"URI aliases\" do not start leaking into the web.\n",
          "createdAt": "2014-10-28T05:35:39Z",
          "updatedAt": "2014-11-01T17:55:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Makes sense.\n",
          "createdAt": "2014-10-28T19:50:02Z",
          "updatedAt": "2014-10-28T19:50:02Z"
        },
        {
          "author": "timbl",
          "authorAssociation": "NONE",
          "body": "We should either use a URI properly or not at all. \nInteresting that RFC4287 (http://tools.ietf.org/search/rfc4287#section-4.2.7) calls for the relationship rel=meta for example  to be  considered to be that identified by the URI http://www.iana.org/assignments/relation/meta -- but that is in fact alas 404.   \n\nI think it is valuable to have a namespace for all occurrences of something.  The rdlib.js library tracks metadata from HTTP requests in the RDF model, and uses for example, an a namespace  httph: http://www.w3.org/2007/ont/httph#  for all HTTP headers:\n\n\"his vocabulary is a one deemed to contain all HTTP headers.\nThe rdflib.js library uses it as for relationships between an HTTP response\nand the  content (value) of the HTTP header in that response.     The ontology\nis deemed to contain one property for every HTTP header, standard or not.\nThe property in this ontology has a localname which is the header field converted\nto lower case.\"\n\nCurrently, searching for a link with a relationship is a pain, I would prefer to add code which generated a direct relationship in a specific namespace.  Much more the RDF way.  We are happy to host the namespace on w3.org/ns and give a set of editors access.   If IANA host it, will they (a) actually put something there and (b) allow the experts (like you Mark) to update it easily?  Should it be a wiki even?\n",
          "createdAt": "2014-11-06T11:41:14Z",
          "updatedAt": "2014-11-06T11:41:14Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@timbl: We can certainly try. The IANA registry currently has a csv representation of the link relation definitions. I've used that to autogenerate a JSON-LD @context of the registry. Something similar could be put in place to generate a resource in the w3.org/ns namespace giving each of those link relations a home. Then either rfc5988bis or another RFC can be written up establishing the w3.org/ns namespace. Doing so would be quite valuable, imho.\n",
          "createdAt": "2014-11-06T15:58:56Z",
          "updatedAt": "2014-11-06T15:58:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@timbl I'm very interested in exploring how to improve registry process -- whether that's improving IANA or doing something completely different. Going to talk to some people about this at IETF next week to get an idea of what's possible. \n\nThis is really #40 btw.\n",
          "createdAt": "2014-11-07T00:05:28Z",
          "updatedAt": "2014-11-07T00:05:28Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "regarding \"We should either use a URI properly or not at all\": RFC 5988 thankfully makes it clear that first and foremost, the link relation URIs are identifiers, and should be treated as such. all this issue is trying to track is RDF's incompatibility with RFC 5988 registered relations, and how to best deal with this without compromising how RFC 5988 is used widely today.\n",
          "createdAt": "2014-11-07T19:06:35Z",
          "updatedAt": "2014-11-07T19:06:35Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "https://html.spec.whatwg.org/multipage/semantics.html#other-link-types\n\n> 4.6.5.17 Other link types\n> \n> Extensions to the predefined set of link types may be registered in the microformats wiki existing-rel-values page. [MFREL]\n> \n> Anyone is free to edit the microformats wiki existing-rel-values page at any time to add a type.\n\nhttp://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions @tantek\n",
          "createdAt": "2014-11-19T00:31:55Z",
          "updatedAt": "2014-11-19T00:31:55Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "And http://www.w3.org/TR/html5/links.html#other-link-types as well.\n",
          "createdAt": "2014-11-19T00:45:18Z",
          "updatedAt": "2014-11-19T00:45:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@elf-pavlik, just for clarification: this is just HTML5 doing its usual NIH dance. the way how link relations on the web are used and defined is still specified by RFC 5988.\n",
          "createdAt": "2014-11-19T09:26:58Z",
          "updatedAt": "2014-11-19T09:26:58Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> Currently, searching for a link with a relationship is a pain, I would prefer to add code which generated a direct relationship in a specific namespace. Much more the RDF way. We are happy to host the namespace on w3.org/ns and give a set of editors access. If IANA host it, will they (a) actually put something there and (b) allow the experts (like you Mark) to update it easily? Should it be a wiki even?\n\nwhile microformats wiki looks already endorsed by W3C in http://www.w3.org/TR/html5/links.html#other-link-types\n\nmaybe we could work on fixing issues with link relations not having proper URIs which also provide their own description? @tantek do you see possibility of enhancing http://microformats.org/wiki/existing-rel-values to address those concerns?\n",
          "createdAt": "2014-11-19T12:41:19Z",
          "updatedAt": "2014-11-19T12:41:19Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "dret said: \"just for clarification: this is just HTML5 doing its usual NIH dance. the way how link relations on the web are used and defined is still specified by RFC 5988.\"\n\nThis is neither a clarification nor true.\n\nHTML5 deliberately abandoned the IANA / RFC5988 ceremony bureaucracy for link registrations because it proved to be unnecessarily inefficient, and instead, chose to \"just use a wiki\" for link registrations, and in this case, the most complete wiki resource that already existed which was/is http://microformats.org/wiki/existing-rel-values (which itself was not created by the HTMLWG, thus the claim of NIH is false as well).\n\nIf you want further clarification and citations of public discussion of how this decision happened, please contact the HTMLWG chairs and/or contacts listed on the WG home page: http://www.w3.org/html/wg/\n\nElf quoted someone \"Should it be a wiki even?\"\n\nIt already is a wiki.\n",
          "createdAt": "2014-11-20T17:10:44Z",
          "updatedAt": "2014-11-20T17:10:44Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tantek, what you write is true about what HTML5 is doing (and i don't think i disputed that), which was my point. but link relations are used in many other places across the web (which is a much larger space than just HTML5). what happens there is entirely unaffected by what HTML5 says or does; RFC 5988 is what matters.\n",
          "createdAt": "2014-11-20T18:03:29Z",
          "updatedAt": "2014-11-20T18:03:29Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "The HTMLWG (and WHATWG for that matter) have both taken the forward step of obsoleting that aspect of RFC 5988, in favor of just using a wiki page for registration, and I'd encourage any \"other places across the web\" that use link relations to do so as well. \n\nAs HTML is how people interact with the web for the most part, RFC 5988 no longer matters in that regard, and thus secondary uses of link relations should take the same forward step. \n",
          "createdAt": "2014-11-20T18:40:12Z",
          "updatedAt": "2014-11-20T18:40:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@tantek and @dret - this back and forth isn't productive. RFC5988 clearly needs to evolve, and HTML can't unilaterally do it for the whole world -- just for its sandbox (which is NOT the whole world, despite some people's aspirations).\n",
          "createdAt": "2014-11-20T21:14:52Z",
          "updatedAt": "2014-11-20T21:14:52Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @mnot ... I was just getting ready to set an email filter to tune this particular thread out. The key question is how exactly does 5988 need to evolve. Aligning the specific syntax rules with HTML5's definition would be a good start, figuring out how best to use link relations in things like json-ld and linked data would be good, determining the future of the IANA registry would be another. I'm all for trying to see if we can come up with a more open or flexible registration process somehow.\n",
          "createdAt": "2014-11-20T22:03:54Z",
          "updatedAt": "2014-11-20T22:03:54Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "mnot: \"RFC5988 clearly needs to evolve, and HTML can't unilaterally do it for the whole world -- just for its sandbox\"\n\nThanks @mnot. I agree completely with both of these. We had to break-up the political-inertia behind 5988 somehow, and forging forward first with _only_ HTML5 made a lot of sense. In the years since that explicit switch from email/IANA -> wiki, it's been a good experience, and thus I think it now makes sense to broaden the solution adopted by HTMLWG and WHATWG, even if just one client/WG/technology at a time (whether for HTTP, JSON-LD, LDP, etc.). \n\n@jasnell - by all means, if you come up with an improvement over and above what HTMLWG/WHATWG have successfully used for years, please make a proposal. I'm all for more such sandbox experiments to improve/minimize process.\n",
          "createdAt": "2014-11-21T01:21:20Z",
          "updatedAt": "2014-11-21T01:21:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Keep in mind that IANA is contractually bound to implement what the IETF tells them to do. If we tell them to run a wiki, they'll run a wiki.\n",
          "createdAt": "2014-11-21T01:23:36Z",
          "updatedAt": "2014-11-21T01:23:36Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "I have no better way of putting this, but to be blunt I think there's been a growing cultural impedance mismatch between IANA/IETF and modern web (specification) development practices. Not sure an IANA run wiki would help.\n\nI don't have any suggestions for fixing this (except by openly bringing it up to start a conversation). Just wanted to point out that this rel registry issue is just one symptom of a much larger iceberg IMO.\n",
          "createdAt": "2014-11-21T01:38:36Z",
          "updatedAt": "2014-11-21T01:38:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I don't disagree, but there's an awfully fine line between \"modern web spec development practices\" and \"Not Invented Here\" these days...\n",
          "createdAt": "2014-11-21T02:06:18Z",
          "updatedAt": "2014-11-21T02:06:18Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "IMO usage of full URIs addresses issue of who and how runs THE registry, by simply making such construct much less needed, if at all. While I understand that many people see need for some kind of a central registry, just on this thread we can see that agreeing on it may come as major challenge.\nBTW for Linked Data people also create **aggregation** services enabling to easily search terms across hundreds of **independently** hosted vocabularies, eg: http://lov.okfn.org\n\n> i'd be more cautious than that, mark. i would be very specific about the fact that the URI version are not the same as the RFC5988 identifiers, just to make sure that the URIs do not start creeping into the web and then we have interoperability problems. \n\nOnce some central registry of link relations, also provides proper _prefix_ to create URIs for all the local identifiers. We could possibly recommend something similar to [JSON-LD Flattened Form](http://www.w3.org/TR/json-ld/#flattened-document-form) to prevent full URIs appearing where someone doesn't expect them. It should work fine with RDFa, people using [Microdata may struggle a bit using multiple vocabularies](http://openspring.net/blog/2011/06/10/microdata-multiple-vocabularies) and AFAIK Microformats doesn't allow use of terms from independent vocabularies but still one could use MF terms with other syntax eg: [JSON-LD: Microformats](http://www.w3.org/TR/json-ld/#microformats) given proper _prefix_ available. Currently I see three interesting prefixes to adopt.\n- **http://www.iana.org/assignments/relation/**\n- **http://microformats.org/wiki/rel-** and **http://microformats.org/profile/**\n\nIn long run I see various benefits of more systems properly handling URIs and prefixes.\n",
          "createdAt": "2014-11-21T11:40:22Z",
          "updatedAt": "2014-11-21T11:40:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "FWIW - I've checked with the Powers that Be (i.e., some ADs), and in principle, yes, we can use a wiki. Documenting how the wiki is to be run is the main challenge.\n",
          "createdAt": "2014-11-25T05:00:44Z",
          "updatedAt": "2014-11-25T05:00:44Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2014-11-25, 06:00, Mark Nottingham wrote:\n\n> FWIW - I've checked with the Powers that Be (i.e., some ADs), and in\n> principle, yes, we can use a wiki. Documenting how the wiki is to be run\n> is the main challenge.\n\nand that indeed is the crux, right? in the end, it's the process that \nmatters when it comes to determining which link relation values are \nconsidered to be \"well-known\"/\"registered\", and which aren't.\n\nwhether the process results end up in an IANA-hosted registry or in a \nwiki (on IANA or other sites) is mostly a question of preferences about \nURI prefixes and organizations.\n",
          "createdAt": "2014-11-25T08:24:11Z",
          "updatedAt": "2014-11-25T08:24:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "If it's in a wiki, \"registered\" is \"somebody has bothered to edit the wiki.\"\n\nThe process would mostly be about dispute resolution, dealing with spammers / squatters, etc. It would probably be necessarily lightweight, otherwise the virtues of a wiki would be lost.\n",
          "createdAt": "2014-11-25T08:27:24Z",
          "updatedAt": "2014-11-25T08:27:24Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hello mark.\n\nOn 2014-11-25, 09:27, Mark Nottingham wrote:\n\n> If it's in a wiki, \"registered\" is \"somebody has bothered to edit the wiki.\"\n\nsure, but it seems that some process or rules how to exactly do that \nprobably are necessary. \nhttp://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions \ndoes have some rules in there as well, and maybe those are good enough. \nand in the end, they are not that different from what RFC 5988 is doing; \njust a bit more lightweight.\n\n> The process would mostly be about dispute resolution, dealing with\n> spammers / squatters, etc. It would probably be necessarily lightweight,\n> otherwise the virtues of a wiki would be lost.\n\nyes, exactly. but i guess i still fail to see why a wiki would be such a \nqualitative difference; it's just a different publishing method. but if \nit makes people happier to see one (governed by a lightweight set of \nrules) instead of an IANA-style registry, then we should have one.\n",
          "createdAt": "2014-11-25T08:33:48Z",
          "updatedAt": "2014-11-25T08:33:48Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "Hi everyone, I wonder if we can add checklist with some clear :white_check_mark:   **ACTION** points to move forward here?\n\n@tantek & @msporny do you see any possible issues with how HTML5 and RDFa1.1 define **rel** ?\n- http://www.w3.org/TR/html5/document-metadata.html#attr-link-rel\n- http://www.w3.org/TR/rdfa-syntax/#A-rel\n",
          "createdAt": "2015-01-17T18:12:08Z",
          "updatedAt": "2015-01-17T18:12:08Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@mnot @tantek while neither IANA and microformats do NOT provide stable URI for all the terms in open controlled vocabularies, which they manage. Would you see problem if someone else provided such stable URIs, for example via https://w3id.org/ ?\n- https://w3id.org/iana/type\n- https://w3id.org/microformats/h-entry\n\n(or possibly using # pattern for such nice and small vocabularies)\n- https://w3id.org/iana#type\n- https://w3id.org/microformats#h-entry\n\nIf one day you decide to take responsibility for hosting resources returned when dereferencing those URIs, it would just take changing redirects on w3id.org\n\n@msporny @kidehen @prototypo do you see such approach as appropriate and along intention behind w3id.org?\n",
          "createdAt": "2015-02-23T08:02:01Z",
          "updatedAt": "2015-02-23T08:02:01Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "@elf-pavlik - yes, that approach is appropriate wrt. w3id.org. If IANA / IETF wants to add themselves to be a co-maintainer of the w3id.org website, it would be welcomed w/ open arms. The same invitation has been extended to W3C, but they'd like to publish terminology such as this in W3C-space. I expect that IANA / IETF will most likely want to do the same.\n\nFor schema.org, when they weren't publishing a reasonable JSON-LD context, the JSON-LD community took it upon itself to publish something via w3id.org and implementers just linked to the w3id.org context. This may or may not have pushed the schema.org folks to publish something themselves lest w3id.org ended up becoming the main location that developers would use to reference the JSON-LD schema.org context. So, w3id.org has been used to move these sorts of discussions forward before.\n\nI have no horse in this race, just providing info for the rest in this thread that need to make the decision.\n",
          "createdAt": "2015-02-23T13:52:47Z",
          "updatedAt": "2015-02-23T13:52:47Z"
        },
        {
          "author": "prototypo",
          "authorAssociation": "NONE",
          "body": "+1\n\nRegards,\n\n## Dave\n\nhttp://about.me/david_wood\n\n> On Feb 23, 2015, at 08:52, Manu Sporny notifications@github.com wrote:\n> \n> @elf-pavlik https://github.com/elf-pavlik - yes, that approach is appropriate wrt. w3id.org. If IANA / IETF wants to add themselves to be a co-maintainer of the w3id.org website, it would be welcomed w/ open arms. The same invitation has been extended to W3C, but they'd like to publish terminology such as this in W3C-space. I expect that IANA / IETF will most likely want to do the same.\n> \n> For schema.org, when they weren't publishing a reasonable JSON-LD context, the JSON-LD community took it upon itself to publish something via w3id.org and implementers just linked to the w3id.org context. This may or may not have pushed the schema.org folks to publish something themselves lest w3id.org ended up becoming the main location that developers would use to reference the JSON-LD schema.org context. So, w3id.org has been used to move these sorts of discussions forward before.\n> \n> I have no horse in this race, just providing info for the rest in this thread that need to make the decision.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub https://github.com/mnot/I-D/issues/39#issuecomment-75543671.\n",
          "createdAt": "2015-02-23T16:24:49Z",
          "updatedAt": "2015-02-23T16:24:49Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just one word of caution: experience shows that when you create specs that say \"you can refer to this concept by identifier a or b\", the minority of implementations handle this correctly (see @jasnell's comment https://github.com/mnot/I-D/issues/39#issuecomment-30522032 and similar implementation experience from activity streams which also defined synonyms that weren't supported well by implementations). implementations mostly prefer a or b and use that preference consistently, and then stop being interoperable with those implementations that make the opposite choice.\nso yes, there should be a way how data models that can only handle URI identifiers are given the opportunity to identify natively non-URI values from IANA registries. in an ideal world, this could even be approached in a way that it is not done on a per-registry basis, but consistently across (some of) them.\n",
          "createdAt": "2015-02-23T16:32:23Z",
          "updatedAt": "2015-02-23T16:32:23Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "On 2/23/15 8:52 AM, Manu Sporny wrote:\n\n> @elf-pavlik https://github.com/elf-pavlik - yes, that approach is \n> appropriate wrt. w3id.org. If IANA / IETF wants to add themselves to \n> be a co-maintainer of the w3id.org website, it would be welcomed w/ \n> open arms. The same invitation has been extended to W3C, but they'd \n> like to publish terminology such as this in W3C-space. I expect that \n> IANA / IETF will most likely want to do the same.\n> \n> For schema.org, when they weren't publishing a reasonable JSON-LD \n> context, the JSON-LD community took it upon itself to publish \n> something via w3id.org and implementers just linked to the w3id.org \n> context. This may or may not have pushed the schema.org folks to \n> publish something themselves lest w3id.org ended up becoming the main \n> location that developers would use to reference the JSON-LD schema.org \n> context. So, w3id.org has been used to move these sorts of discussions \n> forward before.\n> \n> I have no horse in this race, just providing info for the rest in this \n> thread that need to make the decision.\n\nI only have one horse in this race, and its all about making names \ninterpretable using Linked Open Data patterns. That's it.\n\n## \n\nRegards,\n\nKingsley Idehen \nFounder & CEO\nOpenLink Software\nCompany Web: http://www.openlinksw.com\nPersonal Weblog 1: http://kidehen.blogspot.com\nPersonal Weblog 2: http://www.openlinksw.com/blog/~kidehen\nTwitter Profile: https://twitter.com/kidehen\nGoogle+ Profile: https://plus.google.com/+KingsleyIdehen/about\nLinkedIn Profile: http://www.linkedin.com/in/kidehen\nPersonal WebID: http://kingsley.idehen.net/dataspace/person/kidehen#this\n",
          "createdAt": "2015-02-23T16:42:35Z",
          "updatedAt": "2015-02-23T16:42:35Z"
        },
        {
          "author": "tantek",
          "authorAssociation": "NONE",
          "body": "Elf, this is not a reasonable assumption nor framing: \"while neither IANA and microformats do NOT provide stable URI for all the terms in open controlled vocabularies, which they manage\" thus I interpret the rest of your proposal as unnecessary.\n\nHow are you measuring such \"stability\" so as is to assert it (w3id) or lack thereof?\n\nFrom my experience, both IANA and microformats appear have fairly good track records of \"stable URI[s]\". And by \"fairly good\" I mean no loss of URLs AFAIK in their entire history.\n\nSuch stable URLs seem to be an instance of: if it's working, don't fix it, don't make extra work for people.\n\nContrasting example: OpenSocial just killed all their URLs in their handoff to W3C.\n\nBackground: my expertise comes from personally having 12+ years of personal experience maintaining stable URLs (date-time-stamped permalinks) at my personal domain, and longer than that for non-date-stamped URLs. I know nothing of w3id, nor of the longevity of anyone else's experience here with maintaining personal stable URLs, so I don't know how to evaluate other opinions.\n",
          "createdAt": "2015-02-23T22:48:04Z",
          "updatedAt": "2015-02-23T22:48:04Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tantek, it is my understanding that when @elf-pavlik  talks about \"provide stable URI for all the terms in open controlled vocabularies\", he not only talks about defining URIs, but for the ability to dereference them and get something back as a response. which is an entirely different issue, imho, but i think this may be the slight misunderstanding between the two of you. please correct me if i am wrong, @elf-pavlik.\n",
          "createdAt": "2015-02-24T08:59:42Z",
          "updatedAt": "2015-02-24T08:59:42Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "On 2/24/15 3:59 AM, Erik Wilde wrote:\n\n> @tantek https://github.com/tantek, it is my understanding that when \n> @elf-pavlik https://github.com/elf-pavlik talks about \"provide \n> stable URI for all the terms in open controlled vocabularies\", he not \n> only talks about defining URIs, but for the ability to dereference \n> them and get something back as a response. which is an entirely \n> different issue, imho, but i think this may be the slight \n> misunderstanding between the two of you. please correct me if i am \n> wrong, @elf-pavlik https://github.com/elf-pavlik.\n\nYes, this is all about URIs resolving to descriptions of what they \nidentify.\n\nRight now we have:\n1. http://www.iana.org/assignments/link-relations/link-relations.txt\n2. http://www.iana.org/assignments/link-relations/link-relations.xhtml\n3. http://www.iana.org/assignments/link-relations/link-relations.xml\n4. http://www.iana.org/assignments/link-relations/link-relations-1.csv\n\nSimple solution options:\n1. Tweak \n   http://www.iana.org/assignments/link-relations/link-relations.xhtml by \n   using <script/> to embed json-ld and turtle\n2. Add http://www.iana.org/assignments/link-relations/link-relation.ttl\n3. Add http://www.iana.org/assignments/link-relations/link-relations.jsonld.\n\nI don't know who controls this domain, but the TURTLE and JSON docs can \nbe prepared very easily for incorporation and we are then completely set \nwith this matter.\n\n## \n\nRegards,\n\nKingsley Idehen \nFounder & CEO\nOpenLink Software\nCompany Web: http://www.openlinksw.com\nPersonal Weblog 1: http://kidehen.blogspot.com\nPersonal Weblog 2: http://www.openlinksw.com/blog/~kidehen\nTwitter Profile: https://twitter.com/kidehen\nGoogle+ Profile: https://plus.google.com/+KingsleyIdehen/about\nLinkedIn Profile: http://www.linkedin.com/in/kidehen\nPersonal WebID: http://kingsley.idehen.net/dataspace/person/kidehen#this\n",
          "createdAt": "2015-02-24T13:36:16Z",
          "updatedAt": "2015-02-24T13:36:16Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@kidehen do you have any suggestions for mentioned earlier on this thread http://microformats.org/wiki/existing-rel-values (HTML5 spec uses it as official registry of link relations!)\n\nplease also notice earlier comment by @darrelmiller \n\n> I see no reason why 5988bis could not indicate that all registered link relations could be resolved to a URI such as http://www.iana.org/assignments/link-relations/{relname} or something like that. In 5988 even extension link relations are not required to actually be serialized as URIs as long as there is some process to generate a URI identifier.\n\nand reply by @jasnell \n\n> FWIW, this approach was attempted in RFC4287 (http://tools.ietf.org/search/rfc4287#section-4.2.7) but exceedingly few implementers would actually treat the registered short form as being equivalent to the absolute URI form. In fact, Apache Abdera is the only implementation I'm aware of that did. So the real question is: would implementers actually pay attention to this and implement it? I'm not so sure.\n",
          "createdAt": "2015-02-25T20:00:58Z",
          "updatedAt": "2015-02-25T20:00:58Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "It looks that another big difference in using link-relations/predicates in RDF serializations and in HTTP Link Header relates to using them as in(re)verse. In Web Linking spec we find:\n\n> The \"rev\" parameter has been used in the past to indicate that the\n>    semantics of the relationship are in the reverse direction.  That is,\n>    a link from A to B with REL=\"X\" expresses the same relationship as a\n>    link from B to A with REV=\"X\". \"rev\" is deprecated by this\n>    specification because it often confuses authors and readers; in most\n>    cases, using a separate relation type is preferable.\n\nhttps://tools.ietf.org/html/rfc5988#section-5.3\n\nWhile many people discourage defining separate relation for in(re)verse in RDF vocabularies since it may require OWL reasoning (owl:inverseOf) when processing the data:\nhttps://lists.w3.org/Archives/Public/public-vocabs/2015Mar/0189.html\n",
          "createdAt": "2015-04-04T20:17:14Z",
          "updatedAt": "2015-04-04T20:17:14Z"
        },
        {
          "author": "timbl",
          "authorAssociation": "NONE",
          "body": "On 2015-04 -04, at 16:17, \u262e elf Pavlik \u262e notifications@github.com wrote:\n\n> It looks that another big difference in using link-relations/predicates in RDF serializations and in HTTP Link Header relates to using them as in(re)verse. In Web Linking spec we find:\n> \n> The \"rev\" parameter has been used in the past to indicate that the\n> semantics of the relationship are in the reverse direction. That is,\n> a link from A to B with REL=\"X\" expresses the same relationship as a\n> link from B to A with REV=\"X\". \"rev\" is deprecated by this\n> specification because it often confuses authors and readers; in most\n> cases, using a separate relation type is preferable.\n\nYes the above passage is unfortunate and in the spec \"against my better judgement\" as they say.\n\nI would personally encourage people to use \"rev\" as well as \"rel', and to invent only one predicate not two.\n\nIt is worth starting a movement to have the spec changed, or the modern style to issue another best practice spec which is a \"willful violation\" of the current HTML one?\n\n> https://tools.ietf.org/html/rfc5988#section-5.3\n> \n> While many people discourage defining separate relation for in(re)verse in RDF vocabularies since it may require OWL reasoning (owl:inverseOf) when processing the data:\n> https://lists.w3.org/Archives/Public/public-vocabs/2015Mar/0189.html\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n",
          "createdAt": "2015-04-05T15:15:35Z",
          "updatedAt": "2015-04-05T15:15:35Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "I believe most of the people participating in this issue will also attend [TPAC 2015](http://www.w3.org/2015/11/TPAC/), maybe it will give an opportunity to meet face 2 face and discuss possible improvements to current state of things?\n\nAs of today, attempts to navigate between link-relations and RDF predicates mismatch, results in proposals like for example @jasnell's http://www.w3.org/TR/activitystreams-vocabulary/ Which has tons of reverse properties defined on vocabulary level (20) and tries to introduce constructs like [as:Link](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-link) with [as:rel](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-rel)\n\nAt the same time on http://microformats.org/wiki/existing-rel-values I see proposed relations with _DCTERMS_ namespace e.g. _DCTERMS.creator_ @tantek \nAlso human and machine readable mappings for example between http://microformats.org/wiki/rel-publickey and https://w3id.org/security#publicKey (owl:equivalentProperty) could help with making things more inter-operable while allowing people who implement things to work with technology of their choice.\n\nI really wish that people responsible for current state of things will make serious effort to engage in dialog about possible solutions. Especially that many possibilities for improvement exist and most likely just require solid evaluation by everyone involved.\n",
          "createdAt": "2015-04-05T19:11:53Z",
          "updatedAt": "2015-04-05T19:12:47Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@gkellogg in https://github.com/w3c/csvw/issues/297#issuecomment-90078110\n\n> I can add it to th examples directory. I will also likely use it to create a cache IANA vocabulary for my Ruby RDF libraries, as users have been clamoring for this.\n> \n> ``` json\n> {\n>   \"url\": \"http://www.iana.org/assignments/link-relations/link-relations-1.csv\",\n>   \"tableSchema\": {\n>     \"aboutUrl\": \"{name}\",\n>     \"lang\": \"en\",\n>     \"columns\": [\n>       {\"name\": \"name\", \"title\": \"Relation Name\", \"propertyUrl\": \"rdfs:label\"},\n>       {\"name\": \"comment\", \"title\": \"Description\", \"propertyUrl\": \"rdfs:comment\"},\n>       {\"name\": \"type\", \"title\": \"Reference\", \"propertyUrl\": \"rdf:type\", \"valueUrl\": \"rdf:Property\"},\n>       {\"title\": \"Notes\", \"suppressOutput\": true}\n>     ]\n>   }\n> }\n> ```\n> \n> https://github.com/w3c/csvw/commit/976ada9e4a7587d12149eddd913cfdc0d49bd86f\n",
          "createdAt": "2015-04-06T16:22:48Z",
          "updatedAt": "2015-04-06T16:23:28Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "https://github.com/aaronpk/Micropub/issues/1#issuecomment-92421316\n\nIn issue above @tantek and [aaronpk](https://github.com/aaronpk) argue that registry recommended by WHATWG and W3C in HTM5 spec -  http://microformats.org/wiki/existing-rel-values also applies to HTTP Headers and using _micropub_ and _webmention_ there does NOT require additional registration with IANA.\nIn response to issue I raised that **relations not registered with IANA should use full URI** when used in **HTTP** Header. While for relations registered on microformats wiki can use short form but only when used as value of **HTML** _rel_/_rev_ attribute.\n\n> Note that extension relation types are REQUIRED to be absolute URIs\n>    in Link headers, and MUST be quoted if they contain a semicolon (\";\")\n>    or comma (\",\") (as these characters are used as delimiters in the\n>    header itself).\n\nhttps://tools.ietf.org/html/rfc5988#section-5.3\n\nI don't argue here for any particular solution, just raise issue that such unclear situation about link relations / rdf:Property **blessed** registry, and having different ones for HTTP, HTML (why not JSON), can have consequences in future interoperability. Here again lack of official URIs for link relations / rdf:Property(ies) defined in IANA and microformats _blessed_ registries, prevents those, who want to stay  very precise about which particular terms they use, from simply using such URIs as truly unique identifiers :disappointed: \n",
          "createdAt": "2015-04-14T10:40:27Z",
          "updatedAt": "2015-04-14T10:40:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Reading over this issue, I think we're actually talking about a number of (hopefully separable) issues:\n\nThis issue is \"how do I find a link for a registered relation type.\" I think the resolution is a modification of what I suggested way above (incorporating feedback from @dret). In \"Registered Relation Types\", add:\n\n> Applications that wish to refer to registered relation types with a URI [RFC3986] MAY do so by prepending them with \"http://www.iana.org/assignments/relation/\". Note that the resulting strings are not considered equivalent to the registered relation types by many processors, and SHOULD NOT be serialised unless the application using link relations specifically allows them.\n\n_(with possible adjustments to the prefix depending on decisions below)_\n\nAnother issue is \"What are the rules for getting things into and maintaining the registry?\" That's #40. \n\nFinally, there's \"Where should the registry be hosted?\" Provided #40 is dealt with adequately, this is mostly a question of who can meet the requirements, in terms of software, stability, resources, oversight, etc. I don't think that should have an issue number _or_ be discussed until we figure out what those requirements are. \n\n@tantek, I'd love to have a discussion with you about the process used for the wiki over on #40. \n",
          "createdAt": "2015-06-08T05:59:44Z",
          "updatedAt": "2015-06-08T05:59:44Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@timbl @mnot @tantek sadly I don't see any progress in #40 :worried: \nIf you all participate in [W3C TPAC 2015](http://www.w3.org/2015/10/TPAC/), maybe at least all three of you could discuss this issue there IRL?\n\nOnce again, I find current situation **harmful for The Internet & The Web ecosystem as a whole**! Having a different link relations registry for HTML5 media type and a different for HTTP Headers and all the non HTML5 media types doesn't seem to make any sense from technical perspective, and it seems more of a very unfortunate outcome of possible drama between standards organizations / working groups (happy to stand corrected here! and :+1: / :-1: from others following this thread very welcomed)\n\nIMO we also need stable official prefix ASAP to use with relations like: **[describes](https://tools.ietf.org/html/rfc6892)/[descirbedBy](https://dvcs.w3.org/hg/ldpwg/raw-file/default/ldp.html#link-relation-describedby)** when used in JSON-LD, Turle, RDFa and all the other [RDF serializations](http://www.w3.org/TR/rdf11-new/#section-serializations) (eg. https://github.com/w3c/csvw/issues/297#issuecomment-78284500)... or\n\n| link relation | Activity Streams 2.0 | Hydra Core |\n| --- | --- | --- |\n| first | [as:first](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-first) | [hydra:firstPage](http://www.hydra-cg.com/spec/latest/core/#hydra:firstPage) |\n| previous | [as:prev](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-prev) | [hydra:previousPage](http://www.hydra-cg.com/spec/latest/core/#hydra:previousPage) |\n| next | [as:next](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-next) | [hydra:nextPage](http://www.hydra-cg.com/spec/latest/core/#hydra:nextPage) |\n| last | [as:last](http://www.w3.org/TR/activitystreams-vocabulary/#dfn-last) | [hydra:lastPage](http://www.hydra-cg.com/spec/latest/core/#hydra:lastPage) |\n",
          "createdAt": "2015-09-16T10:03:37Z",
          "updatedAt": "2015-09-25T22:41:36Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I agree with @elf-pavlik. The current situation is indeed harmful and even more fragmentation is being suggested as we write this, by different RDF based vocabularies defining their own semantics and names for relations that already exist in IANA. Not having a single registry for this that can support RDF, HTML5 and HTTP headers is quite terrible.\n\n@timbl writes:\n\n> I would personally encourage people to use \"rev\" as well as \"rel', and to invent only one predicate not two.\n\nIn an ideal world, I agree, but as per [the research done while creating HTML5](https://blog.whatwg.org/the-road-to-html-5-link-relations#rel-author):\n\n> Given that `rev=made` was [the only significant non-typo usage of the rev attribute](https://developers.google.com/webmasters/state-of-the-web/2005/linkrels?csw=1), HTML 5 added `rel=author` to make up for the loss of `rev=made` in HTML 4, thus allowing the working group to obsolete the rev attribute altogether. Other than the un/semi/sortof-documented `rev=made` value, people typo the \"rev\" attribute more often than they intentionally use it, which suggests that the world would be better off if validators could flag it as non-conforming.\n\nAs [`rev` is obsoleted in HTML5](http://www.w3.org/TR/html-markup/a.html#a), and given the research that led to that decision, I think it's wise to obsolete it in all other media types too and instead pay the overhead it is to define two inverse predicates.\n",
          "createdAt": "2015-10-14T12:57:34Z",
          "updatedAt": "2015-10-14T12:57:34Z"
        },
        {
          "author": "niklasl",
          "authorAssociation": "NONE",
          "body": ":+1: Certainly agree. Adding some simple RDFS statements about the IANA relations in one of the official representations has come up for many years. Now there might be interest enough and traction to make it happen. It would be quite simple to do so (e.g. by adding some RDFa like in http://www.w3.org/1999/xhtml/vocab#).\n\nThe \"reinvention\" of them in various vocabularies is understandable but fragmenting. That can be made interoperable by equivalence statements linking to the IANA \"base properties\". \n",
          "createdAt": "2015-10-14T14:26:12Z",
          "updatedAt": "2015-10-14T14:26:12Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "+1 to add RDFa or similar, for both link relations and media types. Link types and media types are used beyond HTTP headers and need stable URIs, not just \"The word `disclosure` in that IANA Link registry you know\".\n\nFor media types I have previously used http://purl.org/NET/mediatypes/ as not all media types have URIs at IANA - http://www.iana.org/assignments/media-types/text/plain is the most glaring example - but now http://mediatypes.appspot.com/ (as the purl redirect to) has stopped working. I agree with @dret that these should be hosted by IANA instead of third-parties.\n\nIt should be possible to edit [link-relations.xsl](http://www.iana.org/assignments/link-relations/link-relations.xsl) and/or [iana-registry.xsl](http://www.iana.org/assignments/_support/iana-registry.xsl) to generate RDFa.\n\nSee also this RDF/XML approach by @acoburn:\nhttps://github.com/projecthydra-labs/rdf-vocab/commit/4b8457c828b94cfed60315d10c91913d38ae5a8c\n",
          "createdAt": "2015-10-15T08:41:34Z",
          "updatedAt": "2015-10-15T08:41:34Z"
        },
        {
          "author": "niklasl",
          "authorAssociation": "NONE",
          "body": "@stain Indeed, tweaking the relevant part of link-relations.xsl to something like:\n\n``` xslt\n<xsl:when test=\"../@id = 'link-relations-1'\">\n  <tr typeof=\"owl:ObjectProperty\" resource=\"http://www.iana.org/assignments/relation/{iana:value}\">\n    <td property=\"skos:notation\"><xsl:value-of select=\"iana:value\"/></td>\n    <td property=\"dc:description\"><xsl:apply-templates select=\"iana:description\"/></td>\n    <td rel=\"dc:references\"><xsl:apply-templates select=\"iana:spec\"/></td>\n    <td>\n      <xsl:if test=\"iana:note\">\n        <xsl:attribute name=\"property\">skos:note</xsl:attribute>\n      </xsl:if>\n      <xsl:value-of select=\"iana:note\"/>\n    </td>\n  </tr>\n</xsl:when>\n```\n\nwould do the trick.\n",
          "createdAt": "2015-10-15T09:16:08Z",
          "updatedAt": "2015-10-15T09:16:08Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "great, @niklasl - I made something along those lines - perhaps you could help me finish it? Not sure if `owl:ObjectProperty` is appropriate, so I went with just `skos:Concept`\n\nSee https://gist.github.com/stain/d4656bede203b7c3ba4e\nFeel free to use. CC0 or whatever.\n",
          "createdAt": "2015-10-15T09:33:03Z",
          "updatedAt": "2015-10-15T09:33:15Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "Being compatible with @acoburn approach I used URIs like http://www.iana.org/assignments/relation/terms-of-service as it HTTP-redirects correctly to the XHTML, I didn't think http://www.iana.org/assignments/link-relations/link-relations.xhtml#terms-of-service would be a nice identifier. \n\nA compromise could be http://www.iana.org/assignments/link-relations#terms-of-service which with a bit of `id=\"relation`\" would scroll to the right line. \n\n(I am not sure about the difference between `/assignments/relation` and `/assignments/link-relations` -- IANA folks?)\n",
          "createdAt": "2015-10-15T09:35:20Z",
          "updatedAt": "2015-10-15T09:38:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I've created #140 to capture the specific issue about registered relation types.\n\n#40 is about the management of the registry itself.\n",
          "createdAt": "2015-10-15T23:35:07Z",
          "updatedAt": "2015-10-15T23:35:07Z"
        },
        {
          "author": "IS4Code",
          "authorAssociation": "NONE",
          "body": "It's been 8 years, has anything improved? At least the redirect from <code>http\\://www.iana.org/assignments/relation/*rel*</code> is there, but no semantic improvements to the XSL.",
          "createdAt": "2023-12-25T12:47:56Z",
          "updatedAt": "2023-12-25T12:47:56Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUyMzI4MzYyMA==",
      "title": "Registration procedure",
      "url": "https://github.com/mnot/I-D/issues/40",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "(from Bjoern)\n\nGiven that\n\n  Within at most 14 days of the request, the Designated Expert(s) will\n  either approve or deny the registration request, communicating this\n  decision to the review list and IANA. ...\n\ndoes not happen in practise, revising the registration process should be\na primary concern.\n\nThis issue includes discussion of how the registry should be managed, or _not_ managed.\n",
      "createdAt": "2013-11-25T23:43:29Z",
      "updatedAt": "2015-11-26T00:49:48Z",
      "closedAt": "2015-11-26T00:49:48Z",
      "comments": [
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "Does this issue relates only to [Link Relations Registry](https://www.iana.org/assignments/link-relations/link-relations.xhtml) or also [other registries](https://www.iana.org/protocols)?\n- [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml)\n- [The Profile URI Registry](https://tools.ietf.org/html/rfc7284)\n- [OAuth Parameters](http://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml)\n- [Webfinger Parameters](https://www.iana.org/assignments/webfinger/webfinger.xhtml) (empty)\n- [vCard Elements](https://www.iana.org/assignments/vcard-elements/vcard-elements.xhtml#properties)\n- [iCalendar Element Registries](https://www.iana.org/assignments/icalendar/icalendar.xhtml)\n- etc.\n\nFor example vCard Elements has currently URIs defined for use with RDF in [W3C vCard Ontology](http://www.w3.org/TR/vcard-rdf/), hopefully not duplicated again by including them also among URIs in [Microformats namespace](https://github.com/rhiaro/mf2rdf), in particular [mf:h-card](http://microformats.org/wiki/h-card). Similar iCalendar has some URIs defined for use with RDF in [W3C RDF Calendar](http://www.w3.org/TR/rdfcal/) and again possibly duplicated in [mf:h-event](http://microformats.org/wiki/h-event). Which in a way relates to various issues with coordination already discussed in #39 \n",
          "createdAt": "2015-06-09T10:39:14Z",
          "updatedAt": "2015-06-09T10:39:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Only link relations.\n",
          "createdAt": "2015-06-09T23:18:33Z",
          "updatedAt": "2015-06-09T23:18:33Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "even though the 14 day deadline may not always have been strictly followed, it seems that the spirit of the review process is followed (have expert reviews and give feedback and include the value if accepted). i have been following that particular registry very closely, and personally have been happy with how the registration process has been handled so far.\n",
          "createdAt": "2015-10-16T03:39:59Z",
          "updatedAt": "2015-10-16T03:39:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think a good portion of the problem is friction; it's not reasonable to ask people to subscribe to a mailing list to submit something.\n\nA form (e.g., like that for media types, but better) might do the trick, but I want to think through the workflow. \n\nA wiki has been brought up many times. I'm not against it, but looking at the current one:\n  http://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions\n\n... I'm not sure it's an improvement...\n",
          "createdAt": "2015-10-16T03:47:06Z",
          "updatedAt": "2015-10-16T03:47:06Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the wiki part is where the \"workflow-based registries are pure evil\" people lose me. the \"wiki registries\" have some workflow part to it, but of course badly done, because that's what wikis are bad at. so in the end it's a poorly managed registry that seems to just bear the cooler name \"wiki\". and whatever the technical platform is, it seems to me that some form of review/feedback/consensus loop is a good idea. it's not that i'm a huge fan of IANA's way of doing things, but it seems to me that even if their technical foundation may be quite outdated by now, the general idea and process still are appropriate.\n",
          "createdAt": "2015-10-16T06:10:05Z",
          "updatedAt": "2015-10-16T06:10:05Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> A wiki has been brought up many times. I'm not against it, but looking at the current one:\n> http://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions\n> \n> ... I'm not sure it's an improvement...\n\nOn mentioned wiki I see proposals like DCTERMS.rightsHolder and many others saying\n\n> Requires Dublin Core namespace declaration: `<link rel=\"schema.DCTERMS\" href=\"http://purl.org/dc/terms/\" />`\n\nThey [stay in proposed state since March 2015](http://microformats.org/wiki/index.php?title=existing-rel-values&diff=64849&oldid=64838). I also struggle to understand benefit of using `rel=\"DCTERMS.rightsHolder\"` over `rel=\"http://purl.org/dc/terms/rightsHolder\"`\n\nI also notice there proposal `http://docs.oasis-open.org/ns/cmis/link/200908/acl`, which I understood more as attempt to make this URI more broadly known that need to register it.\n\nMaybe IANA experts responsible for link relations could offer their feedback on some of the proposals we can find on that wiki? It could possibly highlight reasons for having certain lightweight process in place?\n",
          "createdAt": "2015-10-16T08:35:41Z",
          "updatedAt": "2015-10-16T08:35:41Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I'm in perfect line with @elf-pavlik on this. :+1: \n",
          "createdAt": "2015-10-16T09:47:06Z",
          "updatedAt": "2015-10-16T09:47:06Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-10-15 22:35, elf Pavlik wrote:\n\n> Maybe IANA experts responsible for link relations could offer their\n> feedback on some of the proposals we can find on that wiki? It could\n> possibly highlight reasons for having certain lightweight process in place?\n\ni think it's clear where the IANA process is lacking:\n- no easy way to find a history of registry updates.\n- no easy way to contribute other than by email.\n\nafaict, these things would be fairly easy to fix with better \ninterlinking between the registry and whatever medium is used for \ndiscussions. that could be done with a wiki, but wikis tend to be pretty \nbad at this kind of structured information. from the discussion i have \nheard, mostly they started and ended with\n\nIANA registry (email list!) = bad\nwiki (no email list!) = good\n\nhaving worked with a large number of registries (shared across pretty \nlarge developer teams), i was never impressed with the ease of use or \nunderstanding that wikis provide (we tried simple ones and structured \nones and they all failed after getting past the point where there's not \nso much data to handle).\n\nmaybe a better approach would be to first list the ways in which one \nwould want to improve/change the current process (maybe even saying \nwhy), and then look at which solution would work best for that. my \npersonal feeling is that something a la github might be better, but even \nthere it is maybe still lacking the kind of structure one would probably \nwant to have to run a larger number of registries.\n\ni'd be more than happy trying to help improving the process, but as mark \npointed out, simply yelling \"wiki!\" and claiming that this is better \nthan what IANA has may not be the best way to go about this.\n",
          "createdAt": "2015-10-16T17:53:40Z",
          "updatedAt": "2015-10-16T17:53:40Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "Actually I have impression that http://microformats.org/wiki/existing-rel-values#HTML5_link_type_extensions doesn't work that well at all! :-1: \n\n:+1: something like Pull Request workflow with Github/Gitlab discussion thread attached, it seems to work very fast for example with with https://github.com/perma-id/w3id.org\n",
          "createdAt": "2015-10-16T18:01:14Z",
          "updatedAt": "2015-10-16T18:01:14Z"
        },
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": "I agree with @elf-pavlik that URIs should be used. URLs preferrred!\n",
          "createdAt": "2015-10-16T20:07:02Z",
          "updatedAt": "2015-10-16T20:07:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-10-16 10:07, Andreas Kuckartz wrote:\n\n> I agree with @elf-pavlik https://github.com/elf-pavlik that URIs\n> should be used. URLs preferrred!\n\nthis issue is not about changing the nature of link relation types. \nthese are and will remain strings. this issue is just about how to maybe \nimprove the way in which those strings are registered. for the question \nof how those may be used in environments that don't work well with \nnon-URI identifiers, please refer to #140.\n",
          "createdAt": "2015-10-16T20:13:05Z",
          "updatedAt": "2015-10-16T20:13:05Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I too think pull requests are a better tool to aid in the process than a chaotic wiki. Pull requests provide a natural place for discussion of the proposed change before it is accepted and merged. With tags and \"releases\" on GitHub, you can track version numbers in a user friendly way too. And `readme.md` provides a pretty thoughtful rendering of the repository's documentation.\n\nI find GitHub a rather good fit for the entire process. If hosting the registry on another domain than github.com is important, [GitHub Pages](https://pages.github.com/) might be a solution.\n",
          "createdAt": "2015-10-16T22:26:57Z",
          "updatedAt": "2015-10-16T22:26:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hm. I wonder if we simply need to define the guarantees that that the registration process offers, but leave the actual mechanics of operation up to the Expert(s), and say that IANA will put text on the registry page to facilitate that at the direction of the Expert(s).\n\nThat way, we could set up a Github repo (perhaps plus a Google form for those who don't want to create a Github account) to do the discussion component.\n",
          "createdAt": "2015-10-16T22:39:02Z",
          "updatedAt": "2015-10-16T22:39:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "to me, that's definitely the way to go; say what the process should accomplish and how (from a workflow perspective). how to implement it is something else, and usually can be accomplished with all kinds of implementation platforms. to me, that's where the \"IANA vs. Wiki\" discussions failed to focus on the aspects that actually matter.\nhowever, in the end there has to be one designated implementation that is the blessed one, or else you may end up with the situation that we're currently in, with the IANA registry being in place and the official one, but an competing implementation being provided and championed by one specific community. for outsiders just looking for which values are registered, this just looks odd and confusing, and very understandably so.\n",
          "createdAt": "2015-10-16T22:45:57Z",
          "updatedAt": "2015-10-16T22:45:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, I'm going to start working on text to that effect; I suspect we still need to hammer through what the process requirements should be on this issue.\n\nIn the meantime, we also need to consider #144.\n",
          "createdAt": "2015-10-16T22:49:49Z",
          "updatedAt": "2015-10-16T22:49:49Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Sounds good. The process is more important than the tools. Although I think GitHub pull requests are an excellent tool on which the process can be modelled. :-)\n",
          "createdAt": "2015-10-19T06:37:10Z",
          "updatedAt": "2015-10-19T06:37:10Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUyMzM1ODI5OQ==",
      "title": "\"home\" link relation",
      "url": "https://github.com/mnot/I-D/issues/41",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "would it make sense to add a \"home\" link relation to the home document draft? if not, should the draft maybe suggest the use of an existing one to use when linking to a home document? \"start\" maybe isn't terrible when just looking at the name, but then again it seems to be more \"first\" than \"home\" when looking at the definition: \"Refers to the first document in a collection of documents. This link type tells search engines which document is considered by the author to be the starting point of the collection.\" http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-links\n",
      "createdAt": "2013-11-27T00:05:40Z",
      "updatedAt": "2017-03-06T06:15:43Z",
      "closedAt": "2017-03-06T06:15:43Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "any thoughts on this? seems like having a standardized way to link to \"home documents\" (whatever media type they may use) could be a useful thing to add. if you agree, i can add a section.\n",
          "createdAt": "2014-08-06T17:04:20Z",
          "updatedAt": "2014-08-06T17:04:20Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "if \"home\" is added, it might be interesting to see how it compares to the relation types proposed by http://tools.ietf.org/html/draft-wilde-service-link-rel\n",
          "createdAt": "2015-06-15T20:32:43Z",
          "updatedAt": "2015-06-15T20:32:43Z"
        },
        {
          "author": "ethanresnick",
          "authorAssociation": "NONE",
          "body": "The `contents` relation originally from html might also be able to do this. I'm curious what  others think about that though!\n",
          "createdAt": "2015-06-16T20:38:55Z",
          "updatedAt": "2015-06-16T20:38:55Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "http://www.w3.org/TR/1999/REC-html401-19991224/types.html#type-links says that `contents` 'Refers to a document serving as a table of contents. Some user agents also support the synonym ToC (from \"Table of Contents\").'\nto me, that's a bit different from \"home\" itself (for example, at a \"home\" resource you might even find a link to a \"contents\" resource), but i am curious to hear more opinions as well!\n",
          "createdAt": "2015-06-16T20:44:08Z",
          "updatedAt": "2015-06-16T20:44:08Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thinking about the relation of the proposed `home` to https://tools.ietf.org/html/draft-wilde-service-link-rel a bit more, it seems to me it's fairly simple: `home` links to the actual home resource of the service from where the assumption is application flows start initially; the relations proposed by https://tools.ietf.org/html/draft-wilde-service-link-rel link to where these flows are documented, either in human- or in machine-readable ways. typically, the resource provided at `home` might have those links to service documentation and description.\n",
          "createdAt": "2016-02-22T11:23:18Z",
          "updatedAt": "2016-02-22T11:23:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot, any thoughts on this one? if you're ok, i'd be happy to contribute a PR, containing a bit of explanatory text, and the appropriate IANA registration template.\n",
          "createdAt": "2016-06-15T21:45:16Z",
          "updatedAt": "2016-06-15T21:45:16Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I agree that a `home` relation would be useful. It conveys something different from `contents`, `up` and `start`. It would be useful if the text for the registration of the `home` relation explained this difference explicitly, I think.\n",
          "createdAt": "2016-06-16T08:18:10Z",
          "updatedAt": "2016-06-16T08:18:10Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-06-16 04:18, Asbj\u00f8rn Ulsberg wrote:\n\n> I agree that a |home| relation would be useful. It conveys something\n> different from |contents|, |up| and |start|. It would be useful if the\n> text for the registration of the |home| relation explained this\n> difference explicitly, I think.\n\nlink relations are fuzzy by nature so it will be hard to differentiate \nthese things in a definitive way. but i would certainly try and as \nusual, feedback will be very much appreciated.\n",
          "createdAt": "2016-06-16T10:01:11Z",
          "updatedAt": "2016-06-16T10:01:11Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "for now, https://github.com/dret/I-D/commit/3002e1ff8d1499f3b62259f16e0d04a06b951492 (the \"XML syntax for home documents\" draft) is where i have added the \"home\" link relation type. at least it's somewhere, and i'd be fine to migrate it to the core spec when/if the time seems right.\n",
          "createdAt": "2016-06-21T09:29:36Z",
          "updatedAt": "2016-06-21T09:29:36Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://tools.ietf.org/html/draft-wilde-home-xml-04#section-4.3.1\n",
          "createdAt": "2016-06-27T10:33:02Z",
          "updatedAt": "2016-06-27T10:33:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "So, what are the actual use cases here? Do you envision it occurring in representations sent to API clients (non-browser), or to browsers, or...?",
          "createdAt": "2016-11-23T06:51:02Z",
          "updatedAt": "2016-11-23T06:51:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-23 12:21, Mark Nottingham wrote:\n> So, what are the actual use cases here? Do you envision it occurring in\n> representations sent to API clients (non-browser), or to browsers, or...?\n\nmore to non-browsers than to browsers. API people i am talking to seem \nto like the idea that there's a simple way to get from any resource to a \nhome document (and from there potentially to additional resources such \nas service documentation or description). there's not a lot of harm in \ndefining such a link relations, i'd say.\n",
          "createdAt": "2016-11-24T16:08:03Z",
          "updatedAt": "2016-11-24T16:08:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think that makes sense.",
          "createdAt": "2016-11-27T07:20:03Z",
          "updatedAt": "2016-11-27T07:20:03Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-26 23:20, Mark Nottingham wrote:\n> I think that makes sense.\n\ni'll try to come up with a PR, then. the contribution process is to \nupdate draft.md which is your \"latest draft source\", right?\n",
          "createdAt": "2016-11-27T18:34:25Z",
          "updatedAt": "2016-11-27T18:34:25Z"
        },
        {
          "author": "algermissen",
          "authorAssociation": "NONE",
          "body": "As a note to this thread: I am using a Well-Known URI for the purpose of finding the home document of a server (/.well-known/home). It has less capabilities compared to a link rel, but has served me well over the years.",
          "createdAt": "2017-03-01T08:09:21Z",
          "updatedAt": "2017-03-01T08:09:21Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-03-01 09:09, Jan Algermissen wrote:\n> As a note to this thread: I am using a Well-Known URI for the purpose of\n> finding the home document of a server (/.well-known/home). It has less\n> capabilities compared to a link rel, but has served me well over the years.\n\ni am sure you are aware that this is not a registered well-known URI.\n\nhttps://www.ietf.org/assignments/well-known-uris/well-known-uris.xml\n\nhowever, maybe it would be a good idea to register \"home\" as a \nwell-known URI? i'll open a new issue for that.\n",
          "createdAt": "2017-03-01T08:21:57Z",
          "updatedAt": "2017-03-01T08:21:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR: https://github.com/mnot/I-D/pull/214",
          "createdAt": "2017-03-01T15:19:50Z",
          "updatedAt": "2017-03-01T15:19:50Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> however, maybe it would be a good idea to register \"home\" as a well-known URI? i'll open a new issue for that.\r\n\r\n@dret: That sounds like a good idea. Would you say it's okay for that `well-known` URI to do an HTTP `301` to i.e. `/` for applications where that make sense?",
          "createdAt": "2017-03-01T15:46:50Z",
          "updatedAt": "2017-03-01T15:46:50Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-03-01 16:46, Asbj\u00f8rn Ulsberg wrote:\n>     however, maybe it would be a good idea to register \"home\" as a\n>     well-known URI? i'll open a new issue for that.\n> @dret <https://github.com/dret>: That sounds like a good idea. Would you\n> say it's okay for that |well-known| URI to do an HTTP |301| to i.e. |/|\n> for applications where that make sense?\n\nlet's head over to https://github.com/mnot/I-D/issues/212 for this topic\n",
          "createdAt": "2017-03-01T15:50:38Z",
          "updatedAt": "2017-03-01T15:50:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "#214 merged; thanks!\r\n",
          "createdAt": "2017-03-06T06:15:43Z",
          "updatedAt": "2017-03-06T06:15:43Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUyMzg3NDI2MA==",
      "title": "RNC schema, and the extension model in general",
      "url": "https://github.com/mnot/I-D/issues/42",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "currently, the text in appendix A makes statements about how extensions should be serialized, but the RNC schema does not attempt to capture those constraints. which may be fine, but it also may confuse readers when they try to match what the text is saying to what the schema is doing.\nmaybe this is touching upon the bigger issue of how extensibility is defined: is the extensibility essentially JSON-based and the XML syntax then has to reflect that in some form of JSONish structure? another approach could be to leave this open, so that for example users of the XML media type would be open to define XML-based extensions, but then these of course would have no easy mapping into a JSON variant.\nthis is probably the general problem (that's essentially the same for home documents) whether the extension model is based on one particular metamodel, and claims that all extensions must follow it (even if they might only be used in a serialization that's based on a different metamodel).\ni guess in the end all this boils down to is bascially your \"XML or JSON? Just choose!\" blog post and its claim that a hybrid tends to look weird in places. the question then simply is how to manage/constrain the weirdness.\none possibility to avoid the \"metamodels are us\" conundrum could be to leave it open to extensions to define how they are supposed to be serialized in different metamodels. this includes the possibility that an extension would only say how it is serialized in JSON (or XML), and then there would be no reliable way to tell how it should be used in a different representation. this would avoid the need for a custom metamodel (or a preferred one such as JSON), but place the burden on extensions to explicitly define how they're supposed to be used in different serializations.\n",
      "createdAt": "2013-12-06T17:58:43Z",
      "updatedAt": "2017-02-24T05:59:59Z",
      "closedAt": "2016-05-10T06:28:26Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Think this was http-problem; published.\n",
          "createdAt": "2016-05-10T06:28:26Z",
          "updatedAt": "2016-05-10T06:28:26Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yup, it was. the same problem applies to home documents, btw, when looking at the JSON and XML syntaxes (but there it's currently two separate drafts).\n",
          "createdAt": "2016-05-10T15:17:43Z",
          "updatedAt": "2016-05-10T15:17:43Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUyNzM4NDQ2Mg==",
      "title": "draft-nottingham-http-problem-06",
      "url": "https://github.com/mnot/I-D/issues/45",
      "state": "CLOSED",
      "author": "MajorBreakfast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "@steveklabnik, the person who is currently leading the efforts of developing the [json-api](jsonapi.org) spec suggested that I should post my concerns about the http-problem specification right at the source (I'm guessing that's here).\n\nI've written a lengthy comment about it: https://github.com/json-api/json-api/issues/7#issuecomment-34739285. It would be great if you were willing to discuss any improvements! (Here)\n",
      "createdAt": "2014-02-11T20:47:04Z",
      "updatedAt": "2015-06-16T00:42:41Z",
      "closedAt": "2015-06-16T00:42:41Z",
      "comments": [
        {
          "author": "steveklabnik",
          "authorAssociation": "NONE",
          "body": "Yes, I would really like to use http-problem in JSON-API, but there are a few questions.\n",
          "createdAt": "2014-02-11T20:55:01Z",
          "updatedAt": "2014-02-11T20:55:01Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": "It seems that there is an old discussion about some of @MajorBreakfast points at http://www.mnot.net/blog/2013/05/15/http_problem\n\nMaybe we can get into it to clarify some of them?\n",
          "createdAt": "2014-02-12T16:32:07Z",
          "updatedAt": "2014-02-12T16:32:36Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "\"errors\" -> \"problems\" not a big deal\n\nMy biggest concern is the \"problemType\" being an URI. It should be something short and sweet. However I see now why Mark Nottingham decided to make it so. But I think the link should be put into a \"doc\", \"docs\", \"documentation\", \"description\", \"moreInfo\", \"info\" or \"href\". field. And I agree that it's a SHOULD field for mysterious errors like \"csrfTokenInvalid\".\n\nThe supplied example shows the  \"instance\" is an absolute url. At least for json api it's probably best if it showed the path of the problematic field in the request document like `\"path\": \"/posts/2/title\"` because that's what we need to provide the context. I previously said that it should be called \"path\". I'm not so sure about that now because it does not quite the same as the \"path\" in the JSON patch standard in which the \"path\" is the path to a resource field, not a field in the request document.\n\nAnd now the array thing. One solution to this was described by Mark Nottingham himself in the comments and it is to introduce another problem type. I'm not sure. What are the Pros and Cons? At least in json api everything as a plural top level key (like `\"posts\": [...]`) proved to be rather simpler.\n",
          "createdAt": "2014-02-12T20:54:31Z",
          "updatedAt": "2014-02-12T20:56:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hi,\n\nThanks for the input :)\n\n> My biggest concern is the \"problemType\" being an URI. It should be something short and sweet. However I see now why Mark Nottingham decided to make it so. But I think the link should be put into a \"doc\", \"docs\", \"documentation\", \"description\", \"moreInfo\", \"info\" or \"href\". field. And I agree that it's a SHOULD field for mysterious errors like \"csrfTokenInvalid\".\n\nSo, the type is crucial to uniquely identifying the problem. If we make it a short string, clients will need some context to understand what that short string is -- i.e., you need to know that you're \"in\" a particular API.\n\nThat's not very Web-like. Good APIs should be able to be mixed up and un-ambiguously identify what they mean.\n\nWhat's the problem :) with having a URI to identify it? After all, these are going to be consumed and generated by machines, not people.\n\n> The supplied example shows the \"instance\" is an absolute url. At least for json api it's probably best if it showed the path of the problematic field in the request document like \"path\": \"/posts/2/title\" because that's what we need to provide the context. I previously said that it should be called \"path\". I'm not so sure about that now because it does not quite the same as the \"path\" in the JSON patch standard in which the \"path\" is the path to a resource field, not a field in the request document.\n\nInstance gives an identifier for the occurrence of the problem, _not_ where in the request it was a problem (we don't assume the request was JSON). Think of it as a support ticket identifier.\n\nIf you want to define a problem type with a \"path\" extension that identifies where in the request there was a problem, that's totally cool.\n\n> And now the array thing. One solution to this was described by Mark Nottingham himself in the comments and it is to introduce another problem type. I'm not sure. What are the Pros and Cons? At least in json api everything as a plural top level key (like \"posts\": [...]) proved to be rather simpler.\n\nMany people have brought this up. \n\nThe whole idea behind the problem spec is that it's a refinement of the HTTP status code, not a replacement for it. When you allow an array there, it means that you have multiple errors, some of which may conflict with that of the HTTP status code.\n\nWebDAV tried to address this with the 207 Multi-Status status code, and all of the WebDAV folks I talk to wish they hadn't done it; it's caused them a number of problems, mostly because it requires infrastructure to look inside the payload to figure out what's happening.\n\nIf you want to communicate a number of related problems, this can already be accommodated. For example, if your problem type is \"validation error\", you can put an array or object in the extensions that lists all of the different validation problems. \n\nYou can also make a new problem type that combines the semantics of two similar problem types, if necessary.\n\nIt's only when you need to communicate fundamentally different problem types on the same response that you'd need an array, and if they're fundamentally different, they don't fit into HTTP very well.\n\nDo you have use cases that aren't covered by the solutions above? Would love to hear about them.\n\nBTW, the most recent draft when from camelCase to single words to avoid stylistic clashes.\n",
          "createdAt": "2014-02-13T02:16:13Z",
          "updatedAt": "2014-02-13T02:16:13Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@mnot I'm very happy that your're willing to discuss these problems!\n\nFirst I'd like to restate why I'm so sure that the (now called) \"type\" needs to be something short. You say that it's generated by a machine and also consumed by a machine. That is of course correct but it's also a half truth. When developping an application you're going to touch the type quite often because it's the primary key since the other fields are allowed to be localized. It's the thing that will most certainly pop up in the language files (rich client apps/mobile apps) and in the places of the application that decide how to react to the error. You say that it's benefical that it's an URI because you can dereference it. But the support document that it leads to is written for people anyway. So what's left and I think you're after is that if there are errors from multiple APIs, you'll know which error is from which API. But it's from the API you sent the request to, isn't it? We really should standardize a \"documention\"/\"reference\" field.\n\nCould you outline a common use case for the \"instance\" field. I don't seem to get what it's for. Could you give a concrete real world example? If it's a support identifier, then why isn't it called \"supportIdentifier\"?\n\nI get the multi status code thing. We certainly could introduce our `\"type\": \"validation\"` and standardize a \"violations\" array with objects that hold our beloved \"path\" property (-> https://gist.github.com/MajorBreakfast/8884211) My concern is that 90% of the errors end up with `\"type\": \"validation\"` then. I have a bad feeling there. So I'm really not talking about multi status code errors but of this problem.\n\nAny chance we could define a root key \"problem(s)\"? Having such a root key makes it possible to sideload things. In json api it's the standard layout. And of course: The plural/singular could solve the array/object problem (See example below).\n\nThe \"status\" field has no place whatsoever in the JSON. It's repetition. The people who demanded of you to put it in should put it in because it falls into the arbitrary field category. The standard should not mention it because it's a crap idea. (@diosney agrees)\n\n``` JSON\n{\n  \"problem\": { \n    \"type\": \"csrfTokenInvalid\",\n    \"documentation\": \"http://developers.example.com/manual#csrfTokenInvalid\"\n  }\n}\n```\n\n``` JSON\n{\n  \"problems\": [\n    { \"type\": \"invalidEmail\", \"path\": \"/users/0/email\" }\n    { \"type\": \"required\", \"path\": \"/users/0/givenName\" }\n  ]\n}\n```\n\nAnd we should add the \"path\" property to the standard. It refers to the content of the request. I think a standardized name is very useful and we should define its layout if the request was in JSON.\n\nEdit: This post criticizes a lot. But just the draft you know :)\n",
          "createdAt": "2014-02-13T08:23:41Z",
          "updatedAt": "2014-02-13T19:20:47Z"
        },
        {
          "author": "steveklabnik",
          "authorAssociation": "NONE",
          "body": "> If you want to communicate a number of related problems, this can already be accommodated. For example, if your problem type is \"validation error\", you can put an array or object in the extensions that lists all of the different validation problems.\n\nSeems good to me!\n",
          "createdAt": "2014-02-13T18:28:36Z",
          "updatedAt": "2014-02-13T18:28:36Z"
        },
        {
          "author": "steveklabnik",
          "authorAssociation": "NONE",
          "body": "> If you want to communicate a number of related problems, this can already be accommodated. For example, if your problem type is \"validation error\", you can put an array or object in the extensions that lists all of the different validation problems.\n\nSeems good to me!\n",
          "createdAt": "2014-02-13T18:43:09Z",
          "updatedAt": "2014-02-13T18:43:09Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": "> The \"status\" field has no place whatsoever in the JSON. It's repetition. The people who >demanded of you to put it in should put it in because it falls into the arbitrary field category. The > standard should not mention it because it's a crap idea. (@diosney agrees)\n\n@MajorBreakfast Take it easy :) Is true that there is little information about that design \"feature\", but maybe there is a hidden conclusion behind it that we don't know.\n\nThat being told, I do think that it should at least be optional and not a **MUST** so we can get rid of it.\n",
          "createdAt": "2014-02-13T18:52:38Z",
          "updatedAt": "2014-02-13T18:53:05Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@diosney I'm a bit of a tldr; fan. I'm just saying how I see it there. Maybe I shouldn't call it a crap idea, let's say ill advised :) Not meant in an aggressive way though...\n",
          "createdAt": "2014-02-13T19:12:08Z",
          "updatedAt": "2014-02-13T19:26:37Z"
        },
        {
          "author": "robertoandrade",
          "authorAssociation": "NONE",
          "body": "> First I'd like to restate why I'm so sure that the (now called) \"type\" needs to be something short. You say that it's generated by a machine and also consumed by a machine. That is of course correct but it's also a half truth. When developping an application you're going to touch the type quite often because it's the primary key since the other fields are allowed to be localized. It's the thing that will most certainly pop up in the language files (rich client apps/mobile apps) and in the places of the application that decide how to react to the error. You say that it's benefical that it's an URI because you can dereference it. But the support document that it leads to is written for people anyway. So what's left and I think you're after is that if there are errors from multiple APIs, you'll know which error is from which API. But it's from the API you sent the request to, isn't it? We really should standardize a \"documention\"/\"reference\" field.\n\n@MajorBreakfast not sure if you're understanding the URI paradigm right, but just in case I'm misunderstanding your point, I believe URI here doesn't mean URL necessarily. This is very common in concepts such as XML namespaces and other URI-based/driven systems such as some mobile frameworks like Android and iOS (where the URI can be an application-scope identifier such as app://authority/path#fragment?query), used to identify a particular \"thing\" as part of that problem-domain :)\n",
          "createdAt": "2014-02-13T19:25:59Z",
          "updatedAt": "2014-02-13T19:25:59Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": ":)\n\n@mnot, @steveklabnik What do you think about having the redundant http status code be optional?\n",
          "createdAt": "2014-02-13T19:28:41Z",
          "updatedAt": "2014-02-13T19:30:11Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": "@MajorBreakfast I know ;), just wanted to make sure we are not getting bad humors here, after all we are visitors and wanted the most of our host :)\n",
          "createdAt": "2014-02-13T19:32:12Z",
          "updatedAt": "2014-02-13T19:32:12Z"
        },
        {
          "author": "guillec",
          "authorAssociation": "NONE",
          "body": "@diosney the 'status' member is optional.\n\n<blockquote>\nThe status member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer.  Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.\n</blockquote>\n",
          "createdAt": "2014-02-13T19:41:39Z",
          "updatedAt": "2014-02-13T19:41:39Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": "@guillec Thanks! Somehow I missed that :O\n\nI will go to bed now for several days to recover. This was a huge mistake...Thanks again.\n",
          "createdAt": "2014-02-13T19:45:52Z",
          "updatedAt": "2014-02-13T19:57:39Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@robertoandrade \"invalidEmail\" is not an URI\n",
          "createdAt": "2014-02-14T09:25:32Z",
          "updatedAt": "2014-02-14T16:30:57Z"
        },
        {
          "author": "robertoandrade",
          "authorAssociation": "NONE",
          "body": "@majorbreakfast hence the draft suggesting something like http://api.domain.TLD/errors/validation#invalid-email?code=000 instead.\n",
          "createdAt": "2014-02-14T12:56:26Z",
          "updatedAt": "2014-02-14T12:56:26Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@robertoandrade Yes it suggest that. I think it's too verbose for code. I suggest to have a clear recommendation for something short in the spec. (You can't program Java without an IDE but you sure can program JavaScript with any text editor. Reason is that it's impossible to remember the java package names - unless you have a super brain :) ) Short and concise that's the way to go.\n",
          "createdAt": "2014-02-14T16:30:31Z",
          "updatedAt": "2014-02-14T16:35:26Z"
        },
        {
          "author": "robertoandrade",
          "authorAssociation": "NONE",
          "body": "@MajorBreakfast I think you're talking about two different things, one thing is a protocol level (HTTP/API server with HTTP/API client), the other thing is the interface of the HTTP/API client with the developer himself.\n\nIn many platforms you could return the user a representation of a [URI/URL](http://tools.ietf.org/html/rfc2396) object to which they can inquiry the \"short\" piece of the URL that is of interest, but still allowing him to check for the other parts, i.e.: in JS the [Location](http://www.w3.org/TR/html5/browsers.html#location) interface allows you to represent a fully-qualified URI/URL and fetch the interesting bits, i.e.: `Location.hash` in the case of the previous example.\n\nSo if a http-problem client API (such as [the ones json-api suggests](http://jsonapi.org/examples/) using) for the particular language you're consuming the HTTP API, would return the \"Problem\" object, with a property called \"Type\" which is of type \"URL\" or \"Location\", from which you can pull the short piece you're interested in, such as the hash or the code. just like you would if you were doing straight JSON object manipulation and fetching the properties yourself.\n\nSo at the end, `problemObject.type.<hash | fragment | etc> = \"invalid-email\"`\n",
          "createdAt": "2014-02-14T18:09:28Z",
          "updatedAt": "2014-02-14T18:09:28Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@robertoandrade In my sample responses above the problem objects are one liners. A quick glance at each tells you in an instance what went wrong. This is what I want to see when I inspect the traffic in chrome dev tools.\n\nIt's still possible to access the URL. It's in the request meta data, too. Maybe not the URL to an error description. But that is why I'm proposing a \"documentation\" field - not necessary for the \"invalidEmail\" error, but interesting for more complex errors.\n",
          "createdAt": "2014-02-14T18:59:59Z",
          "updatedAt": "2014-02-14T19:02:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@MajorBreakfast - that's what \"title\" is for.\n",
          "createdAt": "2014-02-17T07:11:27Z",
          "updatedAt": "2014-02-17T07:11:27Z"
        },
        {
          "author": "MajorBreakfast",
          "authorAssociation": "NONE",
          "body": "@mnot Please elaborate. I addressed the \"title\" thing in one of my posts above. This discussion kind of needs a detailed response from you now.\n",
          "createdAt": "2014-02-17T07:15:05Z",
          "updatedAt": "2014-02-17T07:42:50Z"
        },
        {
          "author": "diosney",
          "authorAssociation": "NONE",
          "body": "Hehe, ironically, I moved from hating the `status` code in the standard to support it :) (always as an optionally attribute).\n\nI've been researching a lot and found that it could be useful in some rare cases, like the scenario when the platform/app is intercepting the HTTP errors and taking action before the developer can get into it (fi, can happen in flash apps). That way the api can always send the HTTP 200 status code and then in the payload specify the **real** HTTP status code associated with the response. I'm not saying this is the right way to do it, but a real example of the usefulness of the status code.\n\n@mnot Maybe is worth posting this somewhere to let others know when can be useful? This way you can get rid of lot of hate about this attribute.\n",
          "createdAt": "2014-02-20T14:18:52Z",
          "updatedAt": "2014-02-20T14:20:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "We're trying to get the spec to WGLC in the apps area WG, and I realised we never closed this discussion out. Sorry.\n\nAFAICT, the major points left:\n- \"type\" should be shorter. See resolution to #104 - is that better?\n- \"title\" is to convey a quick, human-readable name for the error, whereas \"type\" is to identify it to machines. Make sense?\n\nAnything else?\n\nThanks,\n",
          "createdAt": "2015-04-27T06:40:49Z",
          "updatedAt": "2015-04-27T06:40:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not hearing anything, so closing.\n",
          "createdAt": "2015-06-16T00:42:41Z",
          "updatedAt": "2015-06-16T00:42:41Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWUyODM4NTk4NA==",
      "title": "Possible typo in httpbis-alt-svc-03",
      "url": "https://github.com/mnot/I-D/issues/46",
      "state": "CLOSED",
      "author": "tyoshino",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "http://tools.ietf.org/html/draft-nottingham-httpbis-alt-svc-03#section-1\n\n> expressed a strong desire utilize\n\ndesire to?\n",
      "createdAt": "2014-02-27T01:15:55Z",
      "updatedAt": "2014-03-17T03:17:51Z",
      "closedAt": "2014-03-17T03:17:51Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks; that text will be removed from the next draft.\n",
          "createdAt": "2014-03-17T03:17:51Z",
          "updatedAt": "2014-03-17T03:17:51Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUyODM4NjAwMw==",
      "title": "NOT_AUTHORITATIVE should be a HTTP status code",
      "url": "https://github.com/mnot/I-D/issues/47",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "As per Martin's e-mail on list.\n",
      "createdAt": "2014-02-27T01:16:23Z",
      "updatedAt": "2014-03-18T04:03:08Z",
      "closedAt": "2014-03-18T04:03:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Fixed in 2beba5c84.\n",
          "createdAt": "2014-03-18T04:03:08Z",
          "updatedAt": "2014-03-18T04:03:08Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWUyODM4NjA3MA==",
      "title": "DNS-based alternate discovery?",
      "url": "https://github.com/mnot/I-D/issues/48",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "As per draft TODO list.\n",
      "createdAt": "2014-02-27T01:17:33Z",
      "updatedAt": "2014-03-18T04:03:32Z",
      "closedAt": "2014-03-18T04:03:32Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Punting for now; there is already discussion on-list.\n",
          "createdAt": "2014-03-18T04:03:32Z",
          "updatedAt": "2014-03-18T04:03:32Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWUyODM4NjExMA==",
      "title": "Indicating Chosen Service",
      "url": "https://github.com/mnot/I-D/issues/49",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "It's likely necessary for the server to know which protocol the user agent has chosen, and perhaps even the hostname (for load balancing).  At the very least, there should be a flag in SETTINGS that indicates that an alternate service has been used.\n\nAs per the draft's TODO.\n",
      "createdAt": "2014-02-27T01:18:28Z",
      "updatedAt": "2014-03-31T03:20:29Z",
      "closedAt": "2014-03-31T03:20:29Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moved to http2/http2-spec#443. \n",
          "createdAt": "2014-03-31T03:20:24Z",
          "updatedAt": "2014-03-31T03:20:24Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWUyODM4NjQ0Mw==",
      "title": "Advice for setting headers",
      "url": "https://github.com/mnot/I-D/issues/50",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Need guidelines for servers that use the Alt-Svc header field.\n\nFrom the draft TODO.\n",
      "createdAt": "2014-02-27T01:25:24Z",
      "updatedAt": "2014-03-18T03:00:52Z",
      "closedAt": "2014-03-18T03:00:52Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Can leave it for now\n",
          "createdAt": "2014-03-18T03:00:52Z",
          "updatedAt": "2014-03-18T03:00:52Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWUyODM4NjQ2NA==",
      "title": "Flushing Cache",
      "url": "https://github.com/mnot/I-D/issues/51",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "For the load balancing use case, it's necessary for clients to always flush altsvc cache upon a network change, but right now they're only required to examine the cache for suspicious entries. We should discuss whether this should be upgraded to always flush.\n",
      "createdAt": "2014-02-27T01:25:54Z",
      "updatedAt": "2014-03-31T03:21:04Z",
      "closedAt": "2014-03-31T03:21:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moved to http2/http2-spec#444\n",
          "createdAt": "2014-03-31T03:21:04Z",
          "updatedAt": "2014-03-31T03:21:04Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWUyODM4NzMxNg==",
      "title": "Mate-ise the text",
      "url": "https://github.com/mnot/I-D/issues/52",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "alternate -> alternative, for Martin.\n",
      "createdAt": "2014-02-27T01:44:29Z",
      "updatedAt": "2014-03-17T03:18:20Z",
      "closedAt": "2014-03-17T03:18:20Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWUyODU3NjI4Mw==",
      "title": "Alt-Svc Header Syntax",
      "url": "https://github.com/mnot/I-D/issues/53",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "review whether quoting is necessary, etc.\n",
      "createdAt": "2014-03-02T09:30:33Z",
      "updatedAt": "2014-03-31T03:21:22Z",
      "closedAt": "2014-03-31T03:21:22Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Options AFAICT:\n1. Leave as is.\n2. Drop quotes - but then we have to caution against protocol identifiers that contain \"=\" _or_ trimmable whitespace.\n3. Spec as quoted-string (as per Julian), but then we'd have to make sure that implementations actually did that, e.g., with examples and a test suite. \n4. Spec as uri-escaped string; same as quoted-string, but would allow non-ascii characters.\n",
          "createdAt": "2014-03-18T03:00:22Z",
          "updatedAt": "2014-03-18T03:00:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Already being handled in http2/http2-spec.\n",
          "createdAt": "2014-03-31T03:21:22Z",
          "updatedAt": "2014-03-31T03:21:22Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWUzMDQ4MzExMQ==",
      "title": "Link Cardinality",
      "url": "https://github.com/mnot/I-D/issues/54",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Some explicit text about how link cardinality would help; it's very tempting to limit cardinality in an API, but this limits how links can be used.\n\nAn appendix with suggested patterns for accessing links _might_ be useful too.\n",
      "createdAt": "2014-03-31T03:25:05Z",
      "updatedAt": "2014-10-28T01:15:40Z",
      "closedAt": "2014-10-28T01:15:40Z",
      "comments": []
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWUzMzAzNDQyNQ==",
      "title": "Accept-Post in draft-nottingham-link-hint",
      "url": "https://github.com/mnot/I-D/issues/55",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "\"accept-post\" as it is currently defined in the draft-nottingham-link-hint draft works different from the current proposal in http://tools.ietf.org/html/draft-wilde-accept-post. it would be good to align the way in which these fields work. Currently, the \"accept-post\" of link hints allows a list of specific media types, whereas the Accept-Post header field may contain \"media ranges\".\n",
      "createdAt": "2014-05-07T23:28:34Z",
      "updatedAt": "2017-06-20T00:50:16Z",
      "closedAt": "2017-06-20T00:50:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hm. The use cases for this seem to be along the lines of \"this resource accepts any format for PUT\" or \"this resource accept any `image/*` format for POST\".\r\n\r\nI'm not sure that this is the right place to indicate these semantics -- it feels like we're doing validation by media type. Much better would be to bake the semantics into the link relation type of that resource.\r\n\r\nOTOH HTML does it in form uploads with `accept`.\r\n\r\nI could see it working for `AcceptPut`; I have a harder time with it for `AcceptPost` and especially for `AcceptPatch`. Just not sure the added complexity is worth it.",
          "createdAt": "2017-02-15T04:38:21Z",
          "updatedAt": "2017-02-15T04:38:21Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI: the draft referenced above is no longer active. the W3C LDP group ended up registering `Accept-Post` directly in the LDP spec: https://www.w3.org/TR/ldp/#header-accept-post",
          "createdAt": "2017-02-15T09:55:57Z",
          "updatedAt": "2017-02-15T09:55:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "as discussed in #192, maybe it's worth considering splitting home documents and the general concept of link descriptions/hints?",
          "createdAt": "2017-02-15T09:59:37Z",
          "updatedAt": "2017-02-15T09:59:37Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> as discussed in #192, maybe it's worth considering splitting home documents and the general concept of link descriptions/hints?\r\n\r\nI'd love a separate JSON-based HTTP hints spec.  People keep wanting it in JSON Hyper-Schema, although my preference is also to look more towards link relations for this.  But if we must have hints a shared JSON format for them would be useful.",
          "createdAt": "2017-02-15T15:00:01Z",
          "updatedAt": "2017-02-15T15:00:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@dret LDP needs to go and actually register that header field with IANA, not just put it in a document.\r\n",
          "createdAt": "2017-02-15T23:34:40Z",
          "updatedAt": "2017-02-15T23:34:40Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-02-15 17:00, Henry Andrews wrote:\n> I'd love a separate JSON-based HTTP hints spec. People keep wanting it\n> in JSON Hyper-Schema, although my preference is also to look more\n> towards link relations for this. But if we must have hints a shared JSON\n> format for them would be useful.\n\nthanks for the feedback, and i think it may be at least a direction \nworth exploring. basically, @mnot and i both had the same/similar idea \nat some point, and we both produced drafts:\n\n* https://tools.ietf.org/html/draft-nottingham-link-hint\n* https://tools.ietf.org/html/draft-wilde-link-desc\n\nboth are expired now and partially overlap, but they could provide \nstarting points to think about what such a hints/descriptions spec might \nlook like.\n",
          "createdAt": "2017-02-16T12:05:28Z",
          "updatedAt": "2017-02-16T12:05:28Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-02-16 01:34, Mark Nottingham wrote:\n> @dret <https://github.com/dret> LDP needs to go and actually register\n> that header field with IANA, not just put it in a document.\n\ni raised that point a couple of times with the team, but will do it \nagain. thanks for the reminder!\n",
          "createdAt": "2017-02-16T12:08:33Z",
          "updatedAt": "2017-02-16T12:08:33Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWUzODk1NzgzMg==",
      "title": "Context of link header",
      "url": "https://github.com/mnot/I-D/issues/61",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "RFC5988, 5.2:\n\n```\n By default, the context of a link conveyed in the Link header field\n is the IRI of the requested resource.\n```\n\nThis means that the Link in a request has a context of the requested resource. Using the request representation itself might be more sensible.\n\nSee:\n  http://httpwg.github.io/specs/rfc7231.html#identification\n",
      "createdAt": "2014-07-29T04:47:21Z",
      "updatedAt": "2016-04-26T07:35:31Z",
      "closedAt": "2016-04-26T07:35:31Z",
      "comments": [
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "Adding this little piece of nanotation for tracking and context enrichment:\n\n{\n\n<#this>\na schema:WebPage;\nschema:url <> ;\nschema:mainEntity <#HttpLinkHeader> .\n\n`<http://lists.w3.org/Archives/Public/public-webpayments/2014Jul/0112.html#this>` \na schema:WebPage ;\nschema:url `<http://lists.w3.org/Archives/Public/public-webpayments/2014Jul/0112.html>` ;\nschema:mentions <#HttpLinkHeader>  .\n}\n",
          "createdAt": "2014-07-29T11:22:00Z",
          "updatedAt": "2016-02-29T18:53:31Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@mnot has this issued been attended to in HTTP 2.0? \n",
          "createdAt": "2015-03-05T02:17:57Z",
          "updatedAt": "2015-03-05T02:17:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "HTTP/2 doesn't talk about semantics; this would need to be an errata or update to 5988.\n",
          "createdAt": "2015-03-05T03:04:50Z",
          "updatedAt": "2015-03-05T03:04:50Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@mnot -- any errata or update to https://github.com/mnot/I-D/labels/rfc5988bis#this  in regards to this matter? Ideally, I don't want to be using custom headers if Link: offers me the ability to identify relations scoped to an HTTP request. \n",
          "createdAt": "2016-02-29T18:56:37Z",
          "updatedAt": "2016-02-29T18:56:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "This is too big a change to be an errata. This repo is working on an update, but it's not official, and won't be for some time, I reckon. Even if I pull my finger out and push a revision, it'll take a while to wind through IETF process.\n",
          "createdAt": "2016-03-02T05:55:44Z",
          "updatedAt": "2016-03-02T05:55:44Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@mnot :  So I am to assume right notw that the powerful Link: header is to be reduced to its context being scoped to what's identified by the request IRI? That's quite a bug to leave lingering for so long. As you know, Link: is a powerful mechanism for reducing custom HTTP header explosion. \n",
          "createdAt": "2016-03-02T19:59:26Z",
          "updatedAt": "2016-03-03T16:30:57Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWUzOTI1NDU5Nw==",
      "title": "Clarify intent",
      "url": "https://github.com/mnot/I-D/issues/62",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "safe-hint"
      ],
      "body": "Suggestion from Crocker:\n\n```\nThis document standardises the mechanism for communicating the user's \npreference, but need not standardise its fine-grained semantic.  Simply \nput, the feature is a statement by (or on behalf of) the end-user of the sort \n\"you have a 'safe' setting that you offer to users.  This user is hereby \nopting into that, according to your definition of the term.\"\n```\n",
      "createdAt": "2014-08-01T01:29:58Z",
      "updatedAt": "2014-08-05T00:25:25Z",
      "closedAt": "2014-08-05T00:25:25Z",
      "comments": []
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWUzOTI1NDczNQ==",
      "title": "Explicitly NOT \"child-at-keyboard\"",
      "url": "https://github.com/mnot/I-D/issues/63",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "safe-hint"
      ],
      "body": "From Toronto discussion, this needs to be crystal-clear.\n",
      "createdAt": "2014-08-01T01:34:02Z",
      "updatedAt": "2014-08-05T00:24:19Z",
      "closedAt": "2014-08-05T00:24:19Z",
      "comments": []
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWUzOTMxNjI4OQ==",
      "title": "\"safe\" hint Link extension param or link relation",
      "url": "https://github.com/mnot/I-D/issues/64",
      "state": "CLOSED",
      "author": "jasnell",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "safe-hint"
      ],
      "body": "Something to consider to go along with the safe-hint. To allow a server to advertise that it offers a \"safe\" alternative to any given resource:\n\n```\nLink: <http://example.org>; rel=\"alternate\"; safe\n```\n\nThe implication here would be that by default, the given resource may not be safe, but that the \"safe\" alternative will be provided if \"Prefer: safe\" is included in the request.\n\nThe alternative is to use a \"safe\" link relation:\n\n```\nLink: <http://example.org/safe-alternative>; rel=\"safe-alternate\"\n```\n\nThe implication here is that the linked resource is a \"safe\" alternative to the context resource, regardless of whether \"Prefer: safe\" is included in the request. \n",
      "createdAt": "2014-08-01T18:39:23Z",
      "updatedAt": "2018-08-29T00:02:01Z",
      "closedAt": "2018-08-29T00:02:01Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Doesn't look like `safe` is going forward; the IESG knocked it back and it *appears* that Microsoft is no longer implementing. ",
          "createdAt": "2018-08-29T00:02:01Z",
          "updatedAt": "2018-08-29T00:02:01Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU0NTA2NjU3Ng==",
      "title": "Key / Vary precedence",
      "url": "https://github.com/mnot/I-D/issues/65",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Make it explicit that you can ignore Vary if you understand Key.\n",
      "createdAt": "2014-10-07T04:32:44Z",
      "updatedAt": "2015-09-02T03:49:48Z",
      "closedAt": "2015-09-02T03:49:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Taken care of in -03-to-be.\n",
          "createdAt": "2015-09-02T03:49:48Z",
          "updatedAt": "2015-09-02T03:49:48Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU0NTA2NjcwMQ==",
      "title": "Different Keys for different representations?",
      "url": "https://github.com/mnot/I-D/issues/66",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Discussion with Leif:\n\n> > A general question: is there a requirement that the Key: header is the same\n> > for all variations / alternate for a URL? Or can two responses from the origin\n> > for a given URI have different Key: values?\n> > \n> > This becomes important, because if there's no way for an origin to specify\n> > that the Key: is fixed for a URI, we can't do much in ways of optimisations on\n> > the cache. For example, if the Key: _can_ be fixed for all alternates, it'd be\n> > possible to produce a fast lookup table or hash for the alternates. If not,\n> > you have to evaluate every single alternate in the cache for that URL until\n> > you find one that satisfies the modifiers.\n> \n> In the current design, they should (lower-case) be the same. It's probably worth making that a requirement, so you can rely upon it (except when the key changes, of course). We could even say that each URI has exactly one Key, and the latest value seen from the origin overwrites any previous value?\n\nInteresting thought. So when the Key: changes, that is an implicit invalidation of all other alternates for that URL? \n",
      "createdAt": "2014-10-07T04:35:23Z",
      "updatedAt": "2015-09-02T03:55:34Z",
      "closedAt": "2015-09-02T03:55:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Think this is addressed in -03-to-be.\n",
          "createdAt": "2015-09-02T03:55:34Z",
          "updatedAt": "2015-09-02T03:55:34Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU0NTA2Njc1OA==",
      "title": "Case handling",
      "url": "https://github.com/mnot/I-D/issues/67",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Discussion with Leif:\n\n> > Section 2.1: In step 4, it says to case normalise all values to lower\n> > case. How is that expected to work when a modifier asks for case sensitive\n> > matching? 2.2.6 indicates that \"c\" reverts this, but that seems convoluted at\n> > best (surely no implementation will do / undo the normalisation). I think step\n> > 4 should be clarified and say that the values can be lowercased or left as is\n> > depending on the modifiers.\n> \n> That means we'd need pairs of modifiers for case sensitive vs. insensitive. \n> \n> I'm tempted to make it ALL case insensitive for now; thoughts?\n\nI think case insensitive matches makes sense. Case sensitivity _might_ make sense on e.g. some cookie values that are e.g. base-64'd\u2026 How likely that is to be used in a real implementation, I honestly don't know.\n",
      "createdAt": "2014-10-07T04:36:37Z",
      "updatedAt": "2015-10-19T05:14:35Z",
      "closedAt": "2015-10-19T05:14:31Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to httpbis repo.\n",
          "createdAt": "2015-10-19T05:14:31Z",
          "updatedAt": "2015-10-19T05:14:31Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU0NTA2NjgwOQ==",
      "title": "pr and \"naked\" values",
      "url": "https://github.com/mnot/I-D/issues/68",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Discussion with Ilya:\n\n> Cache dedup notwithstanding.. What do you think of: \n> \n> Key: CH-DPR;pr=[1.5:]\n> \n> Aka, allowing \"pr\" to operate on \"naked\" values, or optionally, if the name is provided on a specific field-> value? This would give it nice symmetry with other modifies in Key.\n",
      "createdAt": "2014-10-07T04:37:57Z",
      "updatedAt": "2015-09-02T03:59:11Z",
      "closedAt": "2015-09-02T03:59:11Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Don't think this is relevant any more; maybe an extension.\n",
          "createdAt": "2015-09-02T03:59:11Z",
          "updatedAt": "2015-09-02T03:59:11Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU0NTA3NTg2MA==",
      "title": "CONNECT -> TUNNELED",
      "url": "https://github.com/mnot/I-D/issues/69",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "wpd"
      ],
      "body": "_from Kevin Smith on-list_\n\nSection 3.6:\n\n>   \" If the string \"CONNECT\" appears in alwaysDirect, it indicates that\n>  requests that require establishment of a tunnel (e.g., for \"https\"\n>  URLs) MUST NOT use the WPD's proxies, but instead ought to be made\n>  directly to the origin (i.e., without a tunnel).\"\n\nIIRC CONNECT involves the proxy in the setup of the tunnel, in which case 'MUST NOT use the WPD's proxies' seems misleading. If the intention is that the request is that tunnelled requests are always direct, then maybe 'TUNNELLED' is a more appropriate value.\n",
      "createdAt": "2014-10-07T07:15:02Z",
      "updatedAt": "2015-04-01T03:21:32Z",
      "closedAt": "2015-04-01T03:21:32Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing; WPD is abandoned.\n",
          "createdAt": "2015-04-01T03:21:32Z",
          "updatedAt": "2015-04-01T03:21:32Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWU0NTE4NTE0Ng==",
      "title": "Special networks",
      "url": "https://github.com/mnot/I-D/issues/70",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "wpd"
      ],
      "body": "_From Nicolas mailhot_:\n\n> It would be really nice if the spec mandated that special networks (as defined in rfc 6761 and 6762) are not proxyfied by default unless an override exists in the wpd (for people doing strange things with local proxies).\n> \n> I'm sure most proxy operators are sick of needing to tell web clients 127.0.0.x is local for example\u2026\n",
      "createdAt": "2014-10-07T23:24:54Z",
      "updatedAt": "2014-10-13T05:54:43Z",
      "closedAt": "2014-10-13T05:54:43Z",
      "comments": []
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU0NTYxMDYyNQ==",
      "title": "Authentication?",
      "url": "https://github.com/mnot/I-D/issues/71",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "wpd"
      ],
      "body": "It might be useful to allow the WPD to pass proxy auth info to the proxy.\n\nLikewise, it might be interesting to allow auto to be required to fetch the WPD. However, the UX for that would be difficult, if we want to get to something more than a modal dialog box.\n",
      "createdAt": "2014-10-13T05:57:33Z",
      "updatedAt": "2015-04-01T03:21:27Z",
      "closedAt": "2015-04-01T03:21:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing; WPD is abandoned.\n",
          "createdAt": "2015-04-01T03:21:27Z",
          "updatedAt": "2015-04-01T03:21:27Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU0NTYxMDg1NA==",
      "title": "NoDirect",
      "url": "https://github.com/mnot/I-D/issues/72",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "wpd"
      ],
      "body": "Flag to say \"don't allow _anything_ to leak onto the network\"\n",
      "createdAt": "2014-10-13T06:02:51Z",
      "updatedAt": "2014-10-13T06:52:39Z",
      "closedAt": "2014-10-13T06:52:39Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "maybe \"exclusive\"?\n",
          "createdAt": "2014-10-13T06:05:24Z",
          "updatedAt": "2014-10-13T06:05:24Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU0NzY5MjQ4Ng==",
      "title": "Applicability of this media type to JSON flavoured API's",
      "url": "https://github.com/mnot/I-D/issues/74",
      "state": "CLOSED",
      "author": "ahacking",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This current draft and the ones preceding it appears to have such limited applicability as to be unusable for the majority of api use cases where JSON is used so I am wondering are JSON api's an intended use case for the draft?\n\nIt is fairly typical to return multiple problems when the JSON presented to a server cannot be processed. The canonical use case is a set of validation errors which have at least the following basic requirements:\n- a problem description\n- fine grained location in the request document where the problem exists (eg JSON field level granularity as described by json-pointer)\n- machine processable problem class/type\n- machine processable problem code/reason\n- user related messages detailing the problem and how it may be rectified\n- **multiple problem support**\n\nThe above requirements are fairly critical requirements for a viable JSON problem media type when dealing with JSON flavoured apis.\n\n**So my question, are JSON API's an intended use case for this draft or not?**\n\nI am fine if its \"no\", but if it is \"yes\", bare in mind that I do not regard \"you can add anything you want to the payload\" as an acceptable answer, as everyone may as well use their existing media type instead of surprising clients by switching media types to one such as this.\n\nIf the answer is \"yes\", please answer how this draft:\n- assists JSON api clients to identify problem fields in their requests\n- assists clients by switching to a different media type than that requested\n- improves the likelihood of consistency by repeating HTTP status codes, given payload and headers may be produced by different operational layers (eg application server behind a reverse proxy)\n- assists servers to communicate field and resource level validation errors to clients,\n- assists clients to identify and process field level validation problems\n- improves interoperability when servers would need to add implementation specific fields to the payload to meet minimum client processing requirements\n\nI await your considered response.\n",
      "createdAt": "2014-11-04T09:20:11Z",
      "updatedAt": "2016-05-10T06:27:54Z",
      "closedAt": "2016-05-10T06:27:54Z",
      "comments": []
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU0OTg1MjExMQ==",
      "title": "camelCase",
      "url": "https://github.com/mnot/I-D/issues/76",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "for the JS people.\n",
      "createdAt": "2014-11-24T02:59:38Z",
      "updatedAt": "2016-11-23T06:47:43Z",
      "closedAt": "2016-11-23T06:47:43Z",
      "comments": [
        {
          "author": "RubenVerborgh",
          "authorAssociation": "NONE",
          "body": "This is definitely important; was the first thing I noticed.\n",
          "createdAt": "2016-04-11T08:02:44Z",
          "updatedAt": "2016-04-11T08:02:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Any preferences between camelCase and CamelCase? What are the cool kids doing these days?\n",
          "createdAt": "2016-05-26T02:47:21Z",
          "updatedAt": "2016-05-26T02:47:21Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "The convention in JavaScript is inherited from Java, which is `lowerCamelCase`.\n",
          "createdAt": "2016-05-26T06:43:30Z",
          "updatedAt": "2016-05-26T06:43:30Z"
        },
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": "For those interested in history: camelCase and CamelCase were first introduced in Smalltalk (which is still cool, see http://squeak.org/ :-).\n",
          "createdAt": "2016-05-26T06:51:19Z",
          "updatedAt": "2016-05-26T06:51:19Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU1MTE5OTE1NA==",
      "title": "Links and cookies",
      "url": "https://github.com/mnot/I-D/issues/77",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "A few questions (courtesy of @yoavweiss), that came up while discussing [Resource Hints + Link interop](http://w3c.github.io/resource-hints/#interoperability-with-http-link-header):\n\n> What should the browser do if a response returns with both \"Link\" and \"Set-Cookie\" headers, assuming that the URLs to preload are on the HTML's domain? Should the browser send the request with the proper cookies set? What if \"Set-Cookie\" comes after the \"Link\"? Should the browser wait for \"Set-Cookie\" if the header parts of the response is still open (i.e. \"\\r\\n\\r\\n\" wasn't yet read from the socket)?\n> \n> I think we should define that. The best compromise performance-wise is probably to respect cookies if they arrived before the \"Link\", but not guaranty respecting them afterwards. \n",
      "createdAt": "2014-12-06T22:41:30Z",
      "updatedAt": "2014-12-08T05:41:38Z",
      "closedAt": "2014-12-07T02:32:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "There's no semantics in the ordering of headers in HTTP when they have different names; intermediaries and libraries can (and do) reorder them. In short, you have to treat a header set as atomic.\n\nBeyond that, Link is a _very_ generic header; saying how cookies should be handled with it across the board may not make sense -- it feels more like a per-relation decision.\n",
          "createdAt": "2014-12-07T01:27:55Z",
          "updatedAt": "2014-12-07T01:27:55Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "Fair enough, this reminds me.. it looks like we'll have to wait on dispatching Link-initiated requests until all headers are processed anyway to enforce CSP (https://github.com/w3c/resource-hints/issues/16). As a result, we can also add some language recommending that Cookies are processed and applied to those.\n",
          "createdAt": "2014-12-07T02:32:24Z",
          "updatedAt": "2014-12-07T02:32:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "This sounds like something that might be better in whatwg/fetch -- although again, it's a case-by-case thing with different relations. \n",
          "createdAt": "2014-12-07T03:10:50Z",
          "updatedAt": "2014-12-07T03:10:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "NONE",
          "body": "> There's no semantics in the ordering of headers in HTTP when they have different names; intermediaries and libraries can (and do) reorder them. In short, you have to treat a header set as atomic.\n\nOf course. Should've thought of that :)\n\nIn that case (and because of CSP forcing us to wait for all the headers to arrive), it's probably best to apply cookies as well to these requests. (at least for `rel=preload`)\n\n@mnot - Are there any relations that trigger a resource download, and should not get cookies applied in that scenario?\n",
          "createdAt": "2014-12-07T10:23:52Z",
          "updatedAt": "2014-12-07T10:23:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not off the top of my head, but I'd be reluctant to rule it out altogether...\n",
          "createdAt": "2014-12-08T05:41:38Z",
          "updatedAt": "2014-12-08T05:41:38Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU1NzQyMjIyMA==",
      "title": "Remove AAD from encryption",
      "url": "https://github.com/mnot/I-D/issues/90",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "The discriminator string probably isn't needed since we munge the CEK with a string that has a similar function.  And the record index is part of the IV.\n\nJim Schaad is convinced that you need to roll the tag from the previous block in to prevent substitution attacks, but I think you are screwed at that point anyway.\n\nRun by @ekr first.\n",
      "createdAt": "2015-02-12T06:23:08Z",
      "updatedAt": "2015-03-04T23:30:35Z",
      "closedAt": "2015-03-04T23:30:35Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@ekr?\n",
          "createdAt": "2015-02-15T00:09:58Z",
          "updatedAt": "2015-02-15T00:09:58Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think I understand the proposal. Can you explain exactly what is intended?\n",
          "createdAt": "2015-02-15T00:16:15Z",
          "updatedAt": "2015-02-15T00:16:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are two things in the AAD: \n1. a discriminator string that identifies this as being encrypted with this specific scheme.  This makes substitution into or out of other encryption formats difficult.\n2. the sequence number of the block, which makes it difficult to move records around, reorder, drop, etc...\n\n(Basically the design is ripped from the TLS record format).\n\nThe idea is that neither is strictly needed. The CEK is derived from the original key with a similar discriminator string, addressing point 1.  And the record sequence number forms the IV.\n",
          "createdAt": "2015-02-16T02:09:13Z",
          "updatedAt": "2015-02-16T02:09:13Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there some reason not to include these?\n\nOn Sun, Feb 15, 2015 at 6:09 PM, Martin Thomson notifications@github.com\nwrote:\n\n> There are two things in the AAD:\n> 1. a discriminator string that identifies this as being encrypted with\n> this specific scheme. This makes substitution into or out of other\n> encryption formats difficult.\n> 2. the sequence number of the block, which makes it difficult to move\n> records around, reorder, drop, etc...\n> \n> (Basically the design is ripped from the TLS record format).\n> \n> The idea is that neither is strictly needed. The CEK is derived from the\n> original key with a similar discriminator string, addressing point 1. And\n> the record sequence number forms the IV.\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/mnot/I-D/issues/90#issuecomment-74451267.\n",
          "createdAt": "2015-02-16T05:04:36Z",
          "updatedAt": "2015-02-16T05:04:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not a particularly good reason to keep them if they are indeed redundant.\n",
          "createdAt": "2015-02-16T10:18:05Z",
          "updatedAt": "2015-02-16T10:18:05Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe we do not need the discriminator string, but I would advise checking with a cryptographer before removing the sequence number.\n",
          "createdAt": "2015-02-16T17:23:37Z",
          "updatedAt": "2015-02-16T17:23:37Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU1NzQyMjU1NA==",
      "title": "Padding change",
      "url": "https://github.com/mnot/I-D/issues/91",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "Jim Schaad suggests that padding being zero is bad if AES-GCM ever loses its inviolate IND-CCA(2) status.  That would open up some known plaintext attacks, probably similar to those that people are getting excited about with in RC4.  I'm not concerned, but I think that it's worth checking to see if this is worth addressing.\n\nA simple change would be to insist on all the octets being a repeat of the counter value, similar to how CMS does it (though CMS padding is 1-255 bytes because zero is not allowed for a reason I can't fathom).\n",
      "createdAt": "2015-02-12T06:27:54Z",
      "updatedAt": "2015-09-06T11:31:42Z",
      "closedAt": "2015-09-06T11:31:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Call on the collective wisdom of the crypto avengers and deliver a verdict.\n",
          "createdAt": "2015-02-15T00:09:41Z",
          "updatedAt": "2015-02-15T00:09:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing this; @martinthomson I trust you've taken care of this in your copy.\n",
          "createdAt": "2015-09-06T11:31:42Z",
          "updatedAt": "2015-09-06T11:31:42Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU1NzUzOTkyNA==",
      "title": "Consider Encryption header field split",
      "url": "https://github.com/mnot/I-D/issues/92",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "Logically, there are two functions for this header field:\n- To describe the encryption (nonce and keyid)\n- To describe the key derivation for a given keyid.\n\n@bifurcation suggests that two header fields be used, if only to make the story a little easier to tell.\n\nWe can use the former to say: \"assume a shared key with ID X\", then the latter one can deal with the business of actually describing how that key can be derived.  He also suggests that JWK is a useful construct for key description/conveyance.\n",
      "createdAt": "2015-02-13T00:05:21Z",
      "updatedAt": "2015-03-04T23:30:35Z",
      "closedAt": "2015-03-04T23:30:35Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Interesting. Not as sure as JWK as _the_ way to do it, but it might be interesting as an option. WDYT?\n",
          "createdAt": "2015-02-15T00:09:02Z",
          "updatedAt": "2015-02-15T00:09:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wasn't thinking that JWK was the only option, or even _an_ option in the core specification, but I can certainly see how a split might make it easier to explain.\n",
          "createdAt": "2015-02-16T02:06:09Z",
          "updatedAt": "2015-02-16T02:06:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "SGTM.\n",
          "createdAt": "2015-02-16T04:25:17Z",
          "updatedAt": "2015-02-16T04:25:17Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU1NzU0MDY1Mg==",
      "title": "Be more explicit about what out-of-band information is needed for ECDH",
      "url": "https://github.com/mnot/I-D/issues/93",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "Currently, we aren't very precise about this.  The actual information required is:\n- the curve\n- the point format\n- an identifier for all of the above\n",
      "createdAt": "2015-02-13T00:13:37Z",
      "updatedAt": "2017-02-24T06:00:45Z",
      "closedAt": "2015-02-13T01:19:45Z",
      "comments": []
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWU2MzI0ODk5NA==",
      "title": "Examples in encrypted C-E are wrong",
      "url": "https://github.com/mnot/I-D/issues/101",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "I just discovered a bug in my implementation.  This is a reminder to fix them.\n",
      "createdAt": "2015-03-20T15:26:31Z",
      "updatedAt": "2017-02-24T06:00:55Z",
      "closedAt": "2015-03-22T19:47:52Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU2Mzg1MjE0Ng==",
      "title": "SHOULD link to a HTML resource",
      "url": "https://github.com/mnot/I-D/issues/103",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "@domenic felt that this was too strong a requirement in https://github.com/w3ctag/spec-reviews/issues/37 .\n",
      "createdAt": "2015-03-23T22:50:08Z",
      "updatedAt": "2015-04-27T06:32:34Z",
      "closedAt": "2015-04-27T06:32:34Z",
      "comments": []
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU2Mzg1MjIzNQ==",
      "title": "Type as URI",
      "url": "https://github.com/mnot/I-D/issues/104",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "On https://github.com/w3ctag/spec-reviews/issues/37 @domenic said:\n\nI think the core of my issue is envisioning someone designing a HTTP API, perhaps someone who hasn't bought into REST all that much. They might naively expect something like { \"type\": \"not_enough_money\" }. Being told that they have to convert this to { \"type\": \"https://api.example.com/error-types/not_enough_money\" } could cause them to abandon this spec on first read-through as not suited for their server. If they could simply do { \"type\": \"not_enough_money\" }, that would be great. If they instead had to do { \"type\": \"about:not_enough_money\" } or something, that might also be OK. Remember that we don't need to be globally unique here---we just need to be unique per-API.\n\nWhat are your thoughts on this perspective? When you talk about possibly-relative URLs, do you mean that { \"type\": \"not_enough_money\" } is fine, since technically it fits the grammar of a relative URL?\n",
      "createdAt": "2015-03-23T22:50:56Z",
      "updatedAt": "2015-04-27T06:32:01Z",
      "closedAt": "2015-04-27T06:32:01Z",
      "comments": [
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": "The alternative\n\n> { \"type\": \"https://api.example.com/error-types/not_enough_money\" } \n\nmight be an option if the URL is not required to be dereferencable.\n",
          "createdAt": "2015-04-19T11:02:30Z",
          "updatedAt": "2015-04-19T11:02:40Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU2Mzg1Mjc1Ng==",
      "title": "\"title\" and \"detail\"",
      "url": "https://github.com/mnot/I-D/issues/105",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "From @domenic on https://github.com/w3ctag/spec-reviews/issues/37 :\n\n> \"title\" is defined by the error type, and therefore static between instances of the error. \"detail\" is specific to a particular instance.\n\nSure, I got that. But when is that helpful?\n",
      "createdAt": "2015-03-23T22:53:20Z",
      "updatedAt": "2015-06-16T00:43:23Z",
      "closedAt": "2015-06-16T00:43:23Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It's for when you want a short, human-readable message specific to what happened; e.g., you might show it in a UI.\n",
          "createdAt": "2015-04-27T06:30:52Z",
          "updatedAt": "2015-04-27T06:30:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not hearing anything, so closing. If you think the spec could be improve here, please re-open or comment.\n",
          "createdAt": "2015-06-16T00:43:23Z",
          "updatedAt": "2015-06-16T00:43:23Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU2Mzg1Mzc2NQ==",
      "title": "\"instance\" as URL",
      "url": "https://github.com/mnot/I-D/issues/106",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "@domenic in https://github.com/w3ctag/spec-reviews/issues/37 :\n\n> Error logs is a good point to bring up. Although, again, suggesting that it should be a URL seems unlikely to be something that people will be willing to do. A simple ID would be something I could envision actually implementing. Whereas, I'm definitely not going to spin up the HTML page production machinery (templating, etc.), in order to write out a new page and start serving it, in the middle of my error handler. A GUID or incrementing \"problemID\" seems more likely what I would program into my server.\n",
      "createdAt": "2015-03-23T22:58:49Z",
      "updatedAt": "2015-06-16T00:43:50Z",
      "closedAt": "2015-06-16T00:43:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Does allowing relative URLs help? (as per #104 resolution)\n",
          "createdAt": "2015-04-27T06:31:27Z",
          "updatedAt": "2015-04-27T06:33:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not hearing anything, so closing. Please comment or re-open if you have more.\n",
          "createdAt": "2015-06-16T00:43:50Z",
          "updatedAt": "2015-06-16T00:43:50Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU2Mzg1MzkxMQ==",
      "title": "Extension namespacing",
      "url": "https://github.com/mnot/I-D/issues/107",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "Brought up by @domenic in https://github.com/w3ctag/spec-reviews/issues/37 .\n\nSuggestion is either to reserve syntax (e.g., \"-\" in keys), or have an explicit extension object.\n",
      "createdAt": "2015-03-23T22:59:51Z",
      "updatedAt": "2015-09-07T05:56:00Z",
      "closedAt": "2015-09-07T05:56:00Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since we also define an alternative XML serialization, it would be good to make sure that whatever the extension convention is, it maps reasonably into XML. Using XML namespaces probably would not be a good way to go, so the XML would simply reflect the JSON convention.\n",
          "createdAt": "2015-03-25T08:30:35Z",
          "updatedAt": "2015-03-25T08:30:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm a _little_ bit sensitive to people who are already using the format; don't want to break them unnecessarily. \n\nHow about defining a container for extensions to go into, and then saying that other unrecognised root members need to be ignored? That would allow future standard extension as well as existing ad hoc uses.\n\nQuestion is, what to call it? \"payload\"? \"ext\"? \"extra\"? \n",
          "createdAt": "2015-04-27T06:36:33Z",
          "updatedAt": "2015-04-27T06:36:33Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "could you please give a short JSON example of what you're thinking of? that would help, and then i can also see how (well) this would map for the XML representation. if there's such a mechanism, there should be examples of it in the spec anyway, right?\n",
          "createdAt": "2015-04-27T17:54:24Z",
          "updatedAt": "2015-04-27T17:54:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "The existing example in the spec is:\n\n``` json\n{\n \"type\": \"https://example.com/probs/out-of-credit\",\n \"title\": \"You do not have enough credit.\",\n \"detail\": \"Your current balance is 30, but that costs 50.\",\n \"instance\": \"/account/12345/msgs/abc\",\n \"balance\": 30,\n \"accounts\": [\"/account/12345\",\n              \"/account/67890\"]\n}\n```\n\n... which I'm saying should become something like:\n\n``` json\n{\n \"type\": \"https://example.com/probs/out-of-credit\",\n \"title\": \"You do not have enough credit.\",\n \"detail\": \"Your current balance is 30, but that costs 50.\",\n \"instance\": \"/account/12345/msgs/abc\",\n \"vars\": {\n   \"balance\": 30,\n   \"accounts\": [\"/account/12345\",\n                \"/account/67890\"]\n  }\n}\n```\n\n(delta the name of the thing)\n",
          "createdAt": "2015-04-28T01:28:49Z",
          "updatedAt": "2015-04-28T01:28:49Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "not sure that this was part of the suggestion, but if there are \"extension objects\", another possibility would be to have an array of them and have identifiers (most likely URIs) for them, so that extensions would be packaged and labeled. maybe that's overkill, but if we're trying to separate \"well-known\" and \"extension\" properties, we might as well structure the extensions. the downside is that the simple example now becomes even more complicated:\n\n``` javascript\n{\n  \"type\": \"https://example.com/probs/out-of-credit\",\n  \"title\": \"You do not have enough credit.\",\n  \"detail\": \"Your current balance is 30, but that costs 50.\",\n  \"instance\": \"/account/12345/msgs/abc\",\n  \"ext\": [\n    { \"http://example.com/extension42\": {\n        \"balance\": 30,\n        \"accounts\": [ \"/account/12345\", \"/account/67890\" ] } }\n  ]\n}\n```\n",
          "createdAt": "2015-04-28T03:16:33Z",
          "updatedAt": "2015-04-28T03:16:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "That seems like a barrier to entry / use...\n",
          "createdAt": "2015-04-28T03:49:18Z",
          "updatedAt": "2015-04-28T03:49:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so then the model is to have one unstructured bag of extension properties and they go all in there? then the wording about disallowing extensions on the outer level should be rather strong, i assume.\n",
          "createdAt": "2015-04-28T04:13:58Z",
          "updatedAt": "2015-04-28T04:13:58Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "I was just discussing the issue of extension properties with @mamund and some audience members after at talk at NDC Oslo where I was showing HTTP Problem.  I really like the fact that there is no structural difference between standard properties and extension properties.  It has the benefit that if some extension property becomes popular it could be adapted into the specification without impacting existing users.\n\nIf there is a naming conflict between some app-specific extension property and the standard properties then the app-specific properties could be embedded in their own namespacing object.\n\nThe only downside I can see is if http-problem is updated to include new properties then there may be conflicts with users who have created extension properties with the same name with different semantics.  This seems like the same problem we have with HTTP headers and if users are concerned  about this property then prefixing with a company specific prefix will likely solve that.\n\nThe \"ext\" object feels a whole lot like x- to me.  If you have multiple pieces of middleware that want to add error/tracing related details to a http-problem payload on the return path, the problem of namespacing returns but this time within the \"ext\" object.\n",
          "createdAt": "2015-06-22T13:25:51Z",
          "updatedAt": "2015-06-22T13:25:51Z"
        },
        {
          "author": "mamund",
          "authorAssociation": "NONE",
          "body": "In Cj, the decision was lean on MUST-IGNORE behavior and allow added properties and objects as long as there was a \"registered extension\" in the standards repo. This provides some barrier to entry and review that is helpful. but it still runs the risk of collisions.\n\nIn UBER the thinking is closer to @mnot's example here -- a named element of some type. in UBER we plan to use a common element for all extensions and, like @dret suggests,  a unique identifier for each of them (`{\"extends: {\"id\":\"...\", ....}}`). That ID _might_ be a URI, simple name, etc. -- no decision yet. The ID will be the point of MUST-IGNORE.\n\nThe Cj pattern offers very easy extension w/o much ceremony even at runtime but we often see pll extending Cj w/o registering and that has the _potential_ of incompatibility (we haven't seen any real pain from this tho). The UBER pattern offers more isolation, but added structure as a downside.\n",
          "createdAt": "2015-06-22T15:05:54Z",
          "updatedAt": "2015-06-22T15:05:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@darrelmiller - The problem is that it'll be a huge judgement call as to whether to prefix your extension based upon whether you think it might eventually gets into the \"standard\" space or not. \n\nHistory shows us that people have a really hard time making that determination well; lots of things that are app-specific get into the \"standard\" space (because people don't care or don't have time to read the docs), and lots of things that _could_ be standard get prefixed (because careful people who read the docs get conservative).\n",
          "createdAt": "2015-06-22T23:24:12Z",
          "updatedAt": "2015-06-22T23:24:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Another option would be to not change anything, but require any future version of the spec to use a different media type.\n",
          "createdAt": "2015-06-22T23:37:31Z",
          "updatedAt": "2015-06-22T23:37:31Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just as a data point: https://tools.ietf.org/html/rfc6648 (@mnot is co-author, so no surprises here).\n",
          "createdAt": "2015-06-24T16:37:20Z",
          "updatedAt": "2015-06-24T16:37:20Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU2Mzk4NzIyMA==",
      "title": "Encrypted c-e might be vulnerable to truncation",
      "url": "https://github.com/mnot/I-D/issues/108",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ecc"
      ],
      "body": "On the record boundaries... Need to think on it.\n",
      "createdAt": "2015-03-24T12:45:13Z",
      "updatedAt": "2017-02-24T06:01:03Z",
      "closedAt": "2015-03-30T23:00:25Z",
      "comments": []
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU3MDc1Nzc0MA==",
      "title": "HTTP problem spec is expired",
      "url": "https://github.com/mnot/I-D/issues/112",
      "state": "CLOSED",
      "author": "kevinburkeshyp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "The latest version of the HTTP problem spec (that I can find, anyway) indicates March 23, 2015 as the expiration date: https://tools.ietf.org/html/draft-ietf-appsawg-http-problem-00\n\nIs there a new draft? \n",
      "createdAt": "2015-04-24T18:16:19Z",
      "updatedAt": "2017-02-24T06:01:13Z",
      "closedAt": "2015-04-27T05:00:03Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not yet; we have some issues to work through.\n\nBTW, it's better to ask on the mailing list (apps-discuss@ietf.org, as mentioned in the draft) than create an issue for this sort of thing.\n",
          "createdAt": "2015-04-27T05:00:03Z",
          "updatedAt": "2015-04-27T05:00:03Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU4NjgxNDQ0OA==",
      "title": "Question: Status of json-home?",
      "url": "https://github.com/mnot/I-D/issues/114",
      "state": "CLOSED",
      "author": "jrnail23",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "Just wanted to ask about the current status of the json-home draft... I noticed that v3 expired quite a while back.  Will it be updated anytime soon, has it been abandoned, or is it considered complete?\nAlso, as of v3, representation hints were listed as \"TBD\" -- has any progress been made on that, or should they simply be ignored when implementing json-home?\n\nThanks in advance!\n",
      "createdAt": "2015-06-10T03:00:23Z",
      "updatedAt": "2017-02-24T06:01:27Z",
      "closedAt": "2015-08-17T05:41:02Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Just on the back burner; will dust it off soon. Not sure about hints yet.\n",
          "createdAt": "2015-08-17T05:41:02Z",
          "updatedAt": "2015-08-17T05:41:02Z"
        },
        {
          "author": "jrnail23",
          "authorAssociation": "NONE",
          "body": "Thanks for the update, @mnot.\n",
          "createdAt": "2015-08-24T14:13:49Z",
          "updatedAt": "2015-08-24T14:13:49Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU4ODU3NTAwOQ==",
      "title": "Editorial from RLB",
      "url": "https://github.com/mnot/I-D/issues/115",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "onion"
      ],
      "body": "https://mailarchive.ietf.org/arch/msg/dnsop/uUv66smASM1u2KWH3BQEKPb0x4Y\n\n\"\"\"\n   This information is not meaningful to the Tor\n   protocol, but can be used in application protocols like HTTP\n   [RFC7230].\n\"\"\"\n\nIt took me a second to process what this meant.  Would the following\nphrasing be correct?\n\n\"\"\"\n   Labels beyond the first label under \".onion\" are not used by\n   the Tor routing, so for example, \"foo.example.onion\" will route\n   to (and authenticate) the same Tor service as \"example.onion\".\n   However, additional labels might be used by application services\n   to distinguish different sub-services accessible via the same Tor\n   service.  In the case of HTTP, for example, the full name, with\n   all labels, will be included in the Host header, and can be used\n   to identify HTTP virual hosts on a common server.\n\"\"\"\n\nMight not be necessary to clarify this much, but like I said, it wasn't\nobvious to me what the sub-label handling would be.\n\n---\n\n\"Note that this draft was preceded by\n[I-D.grothoff-iesg-special-use-p2p-names] ...\"\n\nThis paragraph can probably be deleted in the final version.\n\n---\n\n\"The \".onion\" Special-Use TLD\" -> \"The \".onion\" Special-Use Domain Name\"\n\n(For consistency with RFC 6761)\n\n---\n\n\"\"\"\n       ... or using a proxy (e.g., SOCKS [RFC1928])\n       to do so.  Applications that do not implement the Tor protocol\n       SHOULD generate an error upon the use of .onion, and SHOULD NOT\n       perform a DNS lookup.\n\"\"\"\n\nIt might be worth noting that in the scope of the last sentence,\n\"Applications\" includes proxies.  That is, your proxy should n't generate a\nDNS request if it gets a .onion request either.  I would just add\n\"(including proxies)\" between \"protocol\" and \"SHOULD\".\n\n---\n\n\"\"\"\n1.  Name Resolution APIs and Libraries: Resolvers that implement the\n      Tor protocol MUST either respond to requests for .onion names by\n      resolving them (see [tor-rendezvous]) or by responding with\n      NXDOMAIN.  Other resolvers SHOULD respond with NXDOMAIN.\n   \"\"\"\n\nThis seems a little backward.  It seems like the general requirement is\nthat resolvers MUST either resolve over Tor or return NXDOMAIN.  If you\ndon't support Tor, you just fall in the latter bucket.  Don't be afraid to\nMUST DNS servers, here or in the subsequent points.\n",
      "createdAt": "2015-06-16T00:23:38Z",
      "updatedAt": "2015-06-19T01:35:34Z",
      "closedAt": "2015-06-19T01:35:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "WRT the first point - I think this goes too far in specifying the HTTP behaviour, and I don't think that's the intent here.\n",
          "createdAt": "2015-06-16T02:09:56Z",
          "updatedAt": "2015-06-16T02:09:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@bifurcation - please review 779e194 and previous comment.\n",
          "createdAt": "2015-06-16T02:15:58Z",
          "updatedAt": "2015-06-16T02:15:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not hearing anything, so closing.\n",
          "createdAt": "2015-06-19T01:35:34Z",
          "updatedAt": "2015-06-19T01:35:34Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWU4ODU3NTMyMg==",
      "title": "Editorial from Tom Ritter",
      "url": "https://github.com/mnot/I-D/issues/116",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "onion"
      ],
      "body": "https://mailarchive.ietf.org/arch/msg/dnsop/_t_7kF6Wd_bEGkjaJlyf6bWMa0o\n- Noted for the first time that the IETF boilerplate uses the oxford\n  comma. (I like the Oxford comma, but it seems most don't.)\n- \"visually or apparently semantically similar to the desired\n  service\" - not sure what \"or apparently semantically\" adds to this,\n  seems to be a repeat of \"visually\"\n",
      "createdAt": "2015-06-16T00:26:00Z",
      "updatedAt": "2015-06-16T01:59:46Z",
      "closedAt": "2015-06-16T01:59:46Z",
      "comments": []
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU4ODU3NTU1Mg==",
      "title": "Use of \"TLD\"",
      "url": "https://github.com/mnot/I-D/issues/117",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "onion"
      ],
      "body": "https://mailarchive.ietf.org/arch/msg/dnsop/8x522tdE01T0UY6X6Dry4TuIctw\n\nThe document uses the phrase \"top-level domain\" all over the place to \ndescribe .onion. That phrase to me seems indelibly linked to its meaning \nin the context of the DNS; in the case of Tor, however, we're not \ntalking about the DNS at all, but rather the use of a completely \nseparate namespace that just happens to be syntactically equivalent to \nDNS names.\n\nThe purpose of the document should not be to create a top-level domain \nin the usual/DNS sense; rather it's to prevent such a top-level domain \n(i.e. a delegation from the root zone for the owner name \"onion\") from \never existing, since that would make things confusing for applications.\n\nI support the idea that the running code evident in the tor network \nshould properly trump any process or policy that would otherwise make it \ndifficult to make the DNS-specific recommendations on resolvers and the \nroot zone encapsulated here. I just think the different contexts should \nbe more clearly delineated.\n",
      "createdAt": "2015-06-16T00:27:22Z",
      "updatedAt": "2015-06-16T02:20:33Z",
      "closedAt": "2015-06-16T02:20:33Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Suggestion from Ted Lemon: \"reserved special-use top-level domain name\"\n\nhttps://mailarchive.ietf.org/arch/msg/dnsop/fOBK84kpyTWfmTS_r3o4GAU20TY\n",
          "createdAt": "2015-06-16T00:28:10Z",
          "updatedAt": "2015-06-16T00:28:10Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU4ODU3NTk3Ng==",
      "title": "Editorial from PS",
      "url": "https://github.com/mnot/I-D/issues/118",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "onion"
      ],
      "body": "\".onion names are often used provide access to end to end encrypted,\nsecure, anonymized services; that is,\"\n\nshould be\n\n.onion names are often used to provide access to end to end encrypted,\nsecure, anonymized services; that is,\n",
      "createdAt": "2015-06-16T00:31:31Z",
      "updatedAt": "2015-06-16T01:57:49Z",
      "closedAt": "2015-06-16T01:57:49Z",
      "comments": []
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU4ODU3NjAyMw==",
      "title": "Editorial from RD",
      "url": "https://github.com/mnot/I-D/issues/119",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "onion"
      ],
      "body": "- Look at the three instances of the phrase \"Section 2\", and note that\n  two of them are Section 2 of this document, and the third is I think\n  Section 2 of a different document. It might be smart to add a phrase like\n  \"of that RFC\" to the middle one.\n- If you want, you could say that your affiliation is \"The Tor Project,\n  Inc\". That is our official name. (to Jake)\n- Oh oh, while I'm being pedantic: your References section uses the\n  Oxford comma, but your Acknowledgements section does not.\n",
      "createdAt": "2015-06-16T00:32:08Z",
      "updatedAt": "2015-06-16T01:57:02Z",
      "closedAt": "2015-06-16T01:54:53Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "WRT \"Section 2\" -- they're all same-document refs, and this is normal IETF style.\n",
          "createdAt": "2015-06-16T01:57:02Z",
          "updatedAt": "2015-06-16T01:57:02Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWU5NjMxNTMwMA==",
      "title": "value neutrality",
      "url": "https://github.com/mnot/I-D/issues/121",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "Harald points out that the IETF is _not_ neutral -- we have values. If we don't, we're merely a meeting place.\n\nThis has most implication upon the introduction.\n",
      "createdAt": "2015-07-21T13:32:35Z",
      "updatedAt": "2015-10-08T00:19:17Z",
      "closedAt": "2015-10-08T00:19:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Because our decisions have ethical implications, we must consider them, and determine whether they're within our core values. We do so in a well-defined open fashion.\n",
          "createdAt": "2015-07-21T13:34:27Z",
          "updatedAt": "2015-07-21T13:34:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "If something reduces openness, we're against it. \n",
          "createdAt": "2015-07-21T13:35:07Z",
          "updatedAt": "2015-07-21T13:35:07Z"
        },
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": ":+1:\n",
          "createdAt": "2015-07-21T15:33:12Z",
          "updatedAt": "2015-07-21T15:33:12Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWU5NjMxNTUxMQ==",
      "title": "\"stakeholder\"",
      "url": "https://github.com/mnot/I-D/issues/122",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "This term is poisoned. Suggest \"constituent\"\n",
      "createdAt": "2015-07-21T13:33:54Z",
      "updatedAt": "2015-07-22T12:22:40Z",
      "closedAt": "2015-07-22T12:22:40Z",
      "comments": [
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": "I disagree that it is poisened.\n",
          "createdAt": "2015-07-21T15:31:55Z",
          "updatedAt": "2015-07-21T15:31:55Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWU5NjMxNTkyMQ==",
      "title": "game theory",
      "url": "https://github.com/mnot/I-D/issues/123",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "Harald suggests that \"playing field\" and similar implies a zero-sum game.\n",
      "createdAt": "2015-07-21T13:35:41Z",
      "updatedAt": "2015-07-24T08:34:29Z",
      "closedAt": "2015-07-24T08:34:29Z",
      "comments": []
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWU5NjMxNjk5Mw==",
      "title": "Promoting Stakeholders as \"Winners\"",
      "url": "https://github.com/mnot/I-D/issues/124",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "This is too strong; federation is not always the right solution. The Internet has two central points of control (DNS and IP addresses), and they have good effect. \n\nIn the few cases where points of control are appropriate; we need appropriate stewardship (responsible for them; e.g., ICANN). \n\nPerhaps combine this and the intermediary section; it's about points of control/access.\n",
      "createdAt": "2015-07-21T13:40:05Z",
      "updatedAt": "2015-07-24T08:34:19Z",
      "closedAt": "2015-07-24T08:34:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Removed the federation section, not part of the core message.\n",
          "createdAt": "2015-07-24T08:34:19Z",
          "updatedAt": "2015-07-24T08:34:19Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU5NjMxOTI3Mg==",
      "title": "General Feedback",
      "url": "https://github.com/mnot/I-D/issues/125",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "Needs full community review; both on list and in plenary.\n\nEffectively we're making the code law, and taking ethical responsibility for it. \n",
      "createdAt": "2015-07-21T13:47:41Z",
      "updatedAt": "2015-09-24T12:15:40Z",
      "closedAt": "2015-09-24T12:15:40Z",
      "comments": []
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWUxMDQzOTk1NDM=",
      "title": "Policy for key parameter registry",
      "url": "https://github.com/mnot/I-D/issues/130",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "IETF Consensus is probably too high a bar.\n",
      "createdAt": "2015-09-02T04:11:45Z",
      "updatedAt": "2015-10-19T05:15:38Z",
      "closedAt": "2015-10-19T05:15:35Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to HTTP-extensions repo.\n",
          "createdAt": "2015-10-19T05:15:35Z",
          "updatedAt": "2015-10-19T05:15:35Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWUxMDQ0MTAzOTQ=",
      "title": "Whitespace requirement might be too harsh",
      "url": "https://github.com/mnot/I-D/issues/131",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "`Whitespace is not allowed in the field-value between each field-name and its parameter set.`\n\nAs a potential implementor it makes the parsing algorithm simpler, but I'm also afraid it'd create a subtle way in which people would fail to deploy this syntax in real life.\n\nSince supporting whitespace won't add significant complexity to the parsing algorithm, can we allow it?\n",
      "createdAt": "2015-09-02T06:22:58Z",
      "updatedAt": "2015-10-19T05:16:31Z",
      "closedAt": "2015-10-19T05:16:22Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to http-extensions repo.\n",
          "createdAt": "2015-10-19T05:16:22Z",
          "updatedAt": "2015-10-19T05:16:22Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWUxMDQ2MjA4MTA=",
      "title": "Each field-name should be used only once in a Key header",
      "url": "https://github.com/mnot/I-D/issues/132",
      "state": "CLOSED",
      "author": "zwoop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "To simplify implementations, as well as making sure servers provide efficient Key headers, maybe we should require that a particular field-name is only used once. I.e. this would not be allowed:\n\n```\nKey: Cookie;param=a, Accept-Encoding;match=\u201cgzip\u201d, Cookie;param=b\n```\n\nwhereas this would be:\n\n```\nKey: Cookie;param=a;param=b, Accept-Encoding;match=\u201cgzip\"\n```\n\nFor this to be usable, it would have to be a \"MUST\" I think.\n",
      "createdAt": "2015-09-03T04:43:55Z",
      "updatedAt": "2015-10-19T05:17:15Z",
      "closedAt": "2015-10-19T05:17:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to http-extensions repo\n",
          "createdAt": "2015-10-19T05:17:10Z",
          "updatedAt": "2015-10-19T05:17:10Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWUxMDUxNTcwODE=",
      "title": "generational constant",
      "url": "https://github.com/mnot/I-D/issues/133",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "From @royfielding:\n\n> In that case, we might also want an optional generation constant at the front of the key to allow the origin server to force deliberate breaks from the past.\n",
      "createdAt": "2015-09-07T06:46:27Z",
      "updatedAt": "2015-10-19T05:17:51Z",
      "closedAt": "2015-10-19T05:17:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to http-extensions repo\n",
          "createdAt": "2015-10-19T05:17:48Z",
          "updatedAt": "2015-10-19T05:17:48Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "MDU6SXNzdWUxMDUxNzY3MDc=",
      "title": "Flag value",
      "url": "https://github.com/mnot/I-D/issues/134",
      "state": "CLOSED",
      "author": "alagoutte",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "h2-vpn"
      ],
      "body": "On H2, other frame type (DATA, HEADERS, PUSH_PROMISE) use always 0x08 to say, there is pad stuff\n\nMay be also use bit6 for IPv6 flag on IP / HTTP2 frame type ?\n",
      "createdAt": "2015-09-07T08:57:39Z",
      "updatedAt": "2018-03-30T00:59:13Z",
      "closedAt": "2018-03-30T00:59:13Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Sounds reasonable. I'm not spending much time on this spec right now, as it's not clear to me that it's the right way forward, and also I need some implementer interest :) \n",
          "createdAt": "2016-04-26T07:58:18Z",
          "updatedAt": "2016-04-26T07:58:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "QUIC is probably better for VPNs at this point, and AIUI some people are looking at this. Closing.",
          "createdAt": "2018-03-30T00:59:13Z",
          "updatedAt": "2018-03-30T00:59:13Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWUxMDgwMjc4NTk=",
      "title": "List styles",
      "url": "https://github.com/mnot/I-D/issues/135",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "Roy points out that the lists look like section headers; should update when close to RFC editor.\n\nSee:\n  https://www.rfc-editor.org/rfc-editor/xml2rfcFAQ.html#q_fancy_lists\n",
      "createdAt": "2015-09-23T23:34:31Z",
      "updatedAt": "2015-10-19T05:18:53Z",
      "closedAt": "2015-10-19T05:18:53Z",
      "comments": []
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWUxMDgwMzYzMDM=",
      "title": "First strategy for generating secondary keys infers request doesn't need to be stored",
      "url": "https://github.com/mnot/I-D/issues/136",
      "state": "CLOSED",
      "author": "darrelmiller",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 2.2. the first strategy says..\n\n> Generating a new secondary cache key for every stored response associated with the resource upon each request.\n\nIn order to achieve this, wouldn't the request headers for each stored response need to be cached also?  The next strategy explicitly calls out this requirement,\n\n> with the stored request/response pair \n\nI must admit, I'm a bit leery about the idea of caches choosing to store authorization headers just in case one day a future key header decides to include it.  I think I would prefer the invalidate all variants if the key changes approach.\n",
      "createdAt": "2015-09-24T01:02:53Z",
      "updatedAt": "2015-09-25T13:27:40Z",
      "closedAt": "2015-09-24T05:46:45Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Authorization headers always imply a private response, see http://httpwg.github.io/specs/rfc7234.html#response.cacheability\n\nRegardless, there are a number of ways to do this, and not all require storing requests; re-read the text around the second quote above. :)\n",
          "createdAt": "2015-09-24T05:46:45Z",
          "updatedAt": "2015-09-24T05:46:45Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Just because the request headers are only cached privately does mean there is not a risk associated to it... http://blog.parse.com/learn/engineering/discovering-a-major-security-hole-in-facebooks-android-sdk/\nAnd if someone happens to use a must-revalidate header, the authenticated response can be cached. I've never really understood that relation.\n\nI still don't see how storing all the request headers can be avoided unless you take the third strategy but maybe it will get clearer to me when I actually try implementing it.\n",
          "createdAt": "2015-09-24T12:25:48Z",
          "updatedAt": "2015-09-24T12:25:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Keep in mind that Vary also requires storing the relevant request headers.\n",
          "createdAt": "2015-09-25T04:14:36Z",
          "updatedAt": "2015-09-25T04:14:36Z"
        },
        {
          "author": "darrelmiller",
          "authorAssociation": "NONE",
          "body": "Exactly.  But you only need to store the request headers mentioned in the vary header at the time of the request.  If the vary header adds a new field name at a later date, you do not need to know what that request header value was for the stored responses for that new vary header field.  Previously stored responses are only evaluated based on what the vary header was at the time it was stored.\n\nThe only way you can keep a stored response around when a key header adds a new field name is if you have the request header already stored.  But how do we predict what fields might be added to a key header might be added in the future?\n",
          "createdAt": "2015-09-25T13:27:40Z",
          "updatedAt": "2015-09-25T13:27:40Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWUxMDgyNjQwNTk=",
      "title": "Splitting on ','",
      "url": "https://github.com/mnot/I-D/issues/137",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "2.2. Calculating a Secondary Cache Key\nhttps://tools.ietf.org/html/draft-fielding-http-key-03#section-2.2\n\nYou need here more quoted string exceptions.\n\n|   4.  Create \"key_list\" by splitting \"key_value\" on \",\" characters.\n\nYou need here:    excepting \",\" characters within quoted strings\n\nas you have in\n\n|       6.  Create \"param_list\" by splitting \"parameters\" on \";\"\n|           characters, excepting \";\" characters within quoted strings,\n|           as per [RFC7230] Section 3.2.6.\n",
      "createdAt": "2015-09-25T05:02:00Z",
      "updatedAt": "2015-10-19T05:19:31Z",
      "closedAt": "2015-10-19T05:19:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moving to http-extensions repo\n",
          "createdAt": "2015-10-19T05:19:28Z",
          "updatedAt": "2015-10-19T05:19:28Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWUxMDk3NzQzOTY=",
      "title": "typo in escaping discussion",
      "url": "https://github.com/mnot/I-D/issues/138",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "\"Note that, as per [RFC7231], parameter names are case-insensitive and parameter values can be double-quoted strings (potentially with \"\"-escaped characters inside).\"\n\nIt looks like a backslash is missing here.\n",
      "createdAt": "2015-10-05T11:06:23Z",
      "updatedAt": "2015-10-19T05:20:09Z",
      "closedAt": "2015-10-19T05:20:09Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Forgot to escape the escape. Thanks.\n",
          "createdAt": "2015-10-05T22:32:18Z",
          "updatedAt": "2015-10-05T22:32:18Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWUxMDk3NzQ4OTE=",
      "title": "parsing bug wrt comma",
      "url": "https://github.com/mnot/I-D/issues/139",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Key"
      ],
      "body": "\"4.  Create \"key_list\" by splitting \"key_value\" on \",\" characters.\"\n\nThis doesn't work when a parameter contains a comma.\n",
      "createdAt": "2015-10-05T11:09:21Z",
      "updatedAt": "2015-10-05T22:33:02Z",
      "closedAt": "2015-10-05T22:33:02Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Dup of #137 \n",
          "createdAt": "2015-10-05T22:33:02Z",
          "updatedAt": "2015-10-05T22:33:02Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWUxMTE3MjgzNzQ=",
      "title": "Stable URIs for registered relation types",
      "url": "https://github.com/mnot/I-D/issues/140",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "From #39. We need a convention for registered relation types to be assigned URIs, so that applications (such as RDF) can refer to them.\n\nFrom previous discussion: \n\nI think the resolution is a modification of what I suggested way above (incorporating feedback from @dret). In \"Registered Relation Types\", add:\n\n> Applications that wish to refer to registered relation types with a URI [RFC3986] MAY do so by prepending them with \"http://www.iana.org/assignments/relation/\". Note that the resulting strings are not considered equivalent to the registered relation types by many processors, and SHOULD NOT be serialised unless the application using link relations specifically allows them.\n\n(with possible adjustments to the prefix depending on decisions below)\n",
      "createdAt": "2015-10-15T23:32:57Z",
      "updatedAt": "2021-07-20T16:33:29Z",
      "closedAt": "2016-05-10T06:08:19Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i would consider even stronger wording, such as \"the resulting URIs MAY NOT be used outside of well-defined environments, and any serialization depending on registered IANA link relations MUST use the registered strings as link relation type identifiers.\" maybe that's too strict, but i think there's quite a risk here that the URIs will creep out of the places where they need to be used (such as RDF models that would like to use them as predicates) into the rest of the world where they really really shouldn't be used. establishing a URI convention substantially increases that risk, so trying to contain it with strong language may be in order.\n",
          "createdAt": "2015-10-16T03:32:12Z",
          "updatedAt": "2015-10-16T03:32:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Reopening to discuss that, and to remember we need to finalise the URL (considering things like / vs # ), and perhaps instruct IANA about what to do. \n",
          "createdAt": "2015-10-16T03:48:12Z",
          "updatedAt": "2015-10-16T03:48:12Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "@dret your concern is that services start using the URI and break applications which rely on the simple rel string, right? \nYour proposal seems to say: \"if you depend on a registered rel, you have to use the simple string. But in a well defined environment you may use the URI instead\". The alternative is not quite balanced, it is not about depending on a registered rel vs. well defined environment.\nTo me it appears that the alternative is: implementation that has an implicit notion of unique IANA rels vs. implementation that has no implicit notion of IANA rels and thus requires them to be unique identifiers (e.g. RDF).\nHow about using that alternative as the discriminator, and mention RDF to make it more clear which kind of scenario we are talking about?\n\n\"Serialisations such as RDF that have no implicit notion of unique IANA link relations MAY refer to them with a URI [RFC3986] by prepending them with \"http://www.iana.org/assignments/relation/\". Note that the resulting strings are not considered equivalent to the registered relation types by many processors, and therefore MUST NOT be used for serialisations which have an implicit notion of registered IANA relation types.\"\n",
          "createdAt": "2015-10-17T11:42:03Z",
          "updatedAt": "2015-10-17T11:42:03Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"Serialisations such as RDF that have no implicit notion of unique IANA\n> link relations MAY refer to them with a URI [RFC3986] by prepending them\n> with \"http://www.iana.org/assignments/relation/\". Note that the\n> resulting strings are not considered equivalent to the registered\n> relation types by many processors, and therefore MUST NOT be used for\n> serialisations which have an implicit notion of registered IANA relation\n> types.\"\n\nmaybe i am not quite understanding your usage of the term \"implicit\" \nhere. to me, the fundamental problem we're discussing is RDF's lack of \nstructural (i.e., coherent) context. in HTML/XML (and JSON), it is \ntrivial to say something like this:\n\n<link href=\"....\" rel=\"relation\"/>\n\nthe @rel attribute is only meaningful in the context of the link \nelement, and the model provides that kind of context. that kind of \ncontext is lacking in RDF, which is why strings (that need context to be \nmeaningful) don't work. that's how i see the underlying problem of RDF's \ninability to use non-URI identifiers.\n\nare we in agreement? if yes, then maybe it would be better to talk about \n\"context-dependent identifiers\" or something along these lines? i am \nmostly struggling with your term \"implicit notion\", which i don't quite \nknow how to interpret.\n",
          "createdAt": "2015-10-17T18:51:34Z",
          "updatedAt": "2015-10-17T18:51:34Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "By implicit notion I mean: when an application interprets an HTTP link header or an HTML link element, it can assume that a non-URI @rel value must be a IANA registered rel. Why can it assume that? That fact is not explicit in the link representation, but the application must bring along knowledge about the general implications of an HTTP link header. By being an HTTP link header, the rel attribute implies that its value is either an IANA registered rel or a custom rel. If I may rephrase what you said, the context of an HTTP link makes it clear that the rel is a registered rel. \n\nOne more try: \n\"Serialisations such as RDF that have no contextual notion of unique IANA link relations MAY refer to them with a URI [RFC3986] by prepending them with \"http://www.iana.org/assignments/relation/\". Note that the resulting strings are not considered equivalent to the registered relation types by many processors, and therefore MUST NOT be used in contexts where simple strings are known to be registered IANA relation types.\"\n",
          "createdAt": "2015-10-17T19:44:55Z",
          "updatedAt": "2015-10-17T19:44:55Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "Or maybe more straightforward: \n\n\"Applications which have no concept of context-dependent identifiers to support plain strings as IANA registered link relation types MAY refer to them with a URI [RFC3986] by prepending them with \"http://www.iana.org/assignments/relation/\". Note that the resulting strings are not considered equivalent to the registered relation types by many processors, and therefore MUST NOT be used in contexts where simple strings are known to be registered IANA relation types.\"\n",
          "createdAt": "2015-10-17T20:08:53Z",
          "updatedAt": "2015-10-17T20:08:53Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> in HTML/XML (and JSON), it is\n> trivial to say something like this:\n> \n> ``` html\n> <link href=\"....\" rel=\"relation\"/>\n> ```\n\nAs I understand it:\n- in HTML5 the spec itself **implies** that non URI string values should match those explicitly listed in a spec or registered in blessed registry [1]\n- in HTTP Headers, same implication comes from RFC5988 [2]\n- AFAIK in JSON each system needs to define their usage of link relations independently since no normative reference exist for that\n\n@dret , do you know of any other specs which in normative way specifies that any string used in a particular context, references a link relation from IANA registry?\n\nMaybe simply stating something in lines:\n\n\"In HTTP headers[2], HTML links[1] or other environments which define in normative way usage of link relations from IANA registry,  applications MUST use link relations short sting form. In environments which does not allow use of short string form and enforce use of URIs for identifiers, for example all RDF serializations[3], applications SHOULD reference link relations by prefixing their short string form with \"http://www.iana.org/assignments/relation/'\". \n\nIt definitely needs better wording, but as much as possible I see it helpful to keep it simple and to the point, without introducing any conceptually heave ideas.\n\n[1] http://www.w3.org/TR/html5/links.html\n[2] https://tools.ietf.org/html/rfc5988#section-6.2\n[3] http://www.w3.org/TR/rdf11-new/#section-serializations\n",
          "createdAt": "2015-10-17T21:41:02Z",
          "updatedAt": "2015-10-17T21:41:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As I understand it:\n> - in HTML5 the spec itself _implies_ that non URI string values should\n>   match those explicitly listed in a spec or registered in blessed\n>   registry [1]\n> - in HTTP Headers, same implication comes from RFC5988 [2]\n> - AFAIK in JSON each system needs to define their usage of link\n>   relations independently since no normative reference exist for that\n\nthe difference here is that HTML(5) and HTTP are talking about links \nexplicitly, whereas JSON is just some data metamodel. in JSON models \ntalking about links, you often find the very same link relation \nsemantics encoded (in various variations) as in HTML/HTTP. here is a \nvery nice overview:\n\nhttp://dracoblue.net/dev/overview-of-json-hypermedia-link-formats/\n\n> @dret https://github.com/dret , do you know of any other specs which\n> in normative way specifies that any string used in a particular context,\n> references a link relation from IANA registry?\n\nthere are many (start with above link) and it would be futile and a \nmistake to try to list them explicitly/exhaustively. RFC 5988 defines \nhow link relations types work (strings for registered values, URIs for \nextensions), and that's all that needs to be said. anybody using web \nlinking should be using that model, ot they are on their own.\n\n> Maybe simply stating something in lines:\n> \"In HTTP headers[2], HTML links[1] or other environments which define in\n> normative way usage of link relations from IANA registry, applications\n> MUST use link relations short sting form. In environments which does not\n> allow use of short string form and enforce use of URIs for identifiers,\n> for example all RDF serializations[3], applications SHOULD reference\n> link relations by prefixing their short string form with\n> \"http://www.iana.org/assignments/relation/'\".\n\nnot quite, i think. there is no \"short string form\". the short string \n_is the only allowed value_ if you want to properly reference a \nregistered type. anything else should not be considered a proper \nreference to the registered type, to avoid creeping out those \"pseudo \nvalues\" onto the web.\n",
          "createdAt": "2015-10-17T21:49:40Z",
          "updatedAt": "2015-10-17T21:49:40Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> not quite, i think. there is no \"short string form\". the short string\n> _is the only allowed value_ if you want to properly reference a\n> registered type. anything else should not be considered a proper\n> reference to the registered type, to avoid creeping out those \"pseudo\n> values\" onto the web.\n\nAbove statements don't seem to take into account environments like RDF which require use of URIs, and to my understanding we try here provide a way to still have there a **proper reference to the registered type**. How about something like \"... aplications MUST NOT add  'http://www.iana.org/assignments/relation/' prefix with exception where particular environment does not support use of references other than URIs (for example all RDF serializations)\"\n",
          "createdAt": "2015-10-17T22:04:38Z",
          "updatedAt": "2015-10-17T22:04:38Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@dret I think we all better trust you and Mark with your spec editorial experience. I would just like to make two requests\n\n1) keeping it as simple as possible and preferably not going into conceptually heavy statements which people may struggle to understand and see as vague\n2) offering informative advice about possible consequences of misuse of introduced prefix, and avoiding statements which may seem dogmatic and make people, who have to use URI in media types they work with, feel like they do something wrong\n\n> Reopening to discuss that, and to remember we need to finalise the URL (considering things like / vs # ), and perhaps instruct IANA about what to do.\n\nThis one I see very much related to #144 and very likely decisions there will influence the final recommended prefix. I guess we may end up with **\"http://www.iana.org/assignments/relation/#\"**\n",
          "createdAt": "2015-10-18T09:01:58Z",
          "updatedAt": "2015-10-18T09:01:58Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> @dret wrote:\n> \n> > not quite, i think. there is no \"short string form\". the short string is the only allowed value if you want to properly reference a registered type. anything else should not be considered a proper reference to the registered type, to avoid creeping out those \"pseudo values\" onto the web.\n\n@elf-pavlik wrote:\n\n> Above statements don't seem to take into account environments like RDF which require use of URIs, and to my understanding we try here provide a way to still have there a proper reference to the registered type.\n\nIt also seem to not take into account that [RFC 4287 has described this algorithm](https://tools.ietf.org/html/rfc4287#section-4.2.7.2) for almost 10 years now.\n\n> This one I see very much related to #144 and very likely decisions there will influence the final recommended prefix. I guess we may end up with \"http://www.iana.org/assignments/relation/#\"\n\nYes, that would be good. But it would work so much better if the resulting page wasn't just an enormous HTML `<table>`, but instead divided into sections (`<h2 id=\"{relation}\">`) that could be referenced individually.\n",
          "createdAt": "2015-10-19T06:51:19Z",
          "updatedAt": "2015-10-19T06:51:19Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "BTW, here's my suggested RDFa-from-XSLT approach: (from #39)\n\nhttps://gist.github.com/stain/d4656bede203b7c3ba4e\n",
          "createdAt": "2015-10-22T10:05:57Z",
          "updatedAt": "2015-10-22T10:05:57Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@stain great to see your concrete proposal! I still think that W3C should take responsibility of all the RDF related aspects (possibly using your XSLT) and IANA page could simply link to it using appropriate link relations, as I propose in https://github.com/mnot/I-D/issues/144#issuecomment-149531806\n",
          "createdAt": "2015-10-23T09:41:08Z",
          "updatedAt": "2015-10-23T09:41:08Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "+1 to http://www.iana.org/assignments/relation/#\n\nDo you even need the final trailing \"/\"?  Doesnt make a huge difference in the grand scheme of things.\n\nMay I request that the final resource is CORS enabled?\n",
          "createdAt": "2015-10-23T10:14:49Z",
          "updatedAt": "2015-10-23T10:14:49Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i am starting to wonder if it wouldn't make sense to start a separate document listing a number of requirements for IANA registries (also including #144 and maybe even #40) and how they are exposed. while not all of IANA's registries will need something like this, for many it might be useful, and least some aspects of it, so separating this issue into a standalone document might be useful to make it reusable. but then again, @mnot would be the right person to say whether that's a realistic and reasonable goal to have, or whether this would be too much effort for something that might see less (or no) reuse regardless of the best intentions.\n",
          "createdAt": "2015-10-23T17:11:06Z",
          "updatedAt": "2015-10-23T17:11:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@dret - no, that's been tried and failed before, and I'd like to avoid doing so for now.\n\nAll - can we _please_ keep issues discussion on-topic? I'm very happy to have the discussion, but not when it veers all over the place. Thanks.\n",
          "createdAt": "2015-10-27T05:30:09Z",
          "updatedAt": "2015-10-27T05:30:09Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot ... +1 to this change. I don't believe @dret's additional constraints are necessary (not that there's anything particularly wrong with them). \n",
          "createdAt": "2015-10-27T15:25:24Z",
          "updatedAt": "2015-10-27T15:25:24Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I'd also say :+1:, but with one exception: Drop the trailing `/`, so we end up with:\n\n```\nhttp://www.iana.org/assignments/relation#\n```\n\nIt is more in line with how such fragment URIs tend to look, and there's nothing to gain by having the trailing slash, is there?\n",
          "createdAt": "2015-10-27T15:42:01Z",
          "updatedAt": "2015-10-27T15:42:01Z"
        },
        {
          "author": "gkellogg",
          "authorAssociation": "NONE",
          "body": "Given that relations are all defined in a single resource, I agree that `http://www.iana.org/assignments/relation#` makes the most sense. Using '/#' would just seem indecisive.\n",
          "createdAt": "2015-10-27T15:49:09Z",
          "updatedAt": "2015-10-27T15:49:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@asbjornu @gkellogg I agree that relation# makes more sense than relation/ but RFC4287 _did_ specify the latter, and this issue is about stability :)\n\nIf there's really broad consensus to change it, I'm OK with that, but I wonder if we can determine that here.\n\nAlso, is it really that important that they resolve to something relevant/non-404, or is that just Nice to Have?\n",
          "createdAt": "2015-10-29T06:40:51Z",
          "updatedAt": "2015-10-29T06:40:51Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-10-29 07:40, Mark Nottingham wrote:\n\n> Also, is it really that important that they resolve to something\n> relevant/non-404, or is that just Nice to Have?\n\nit's nice to have. the essential thing is that the registered values are \nidentifiers, so the constructed URIs are a nicety. but it would be \nreally convenient if somebody asked \"what is this registered value all \nabout?\", if such a URI could be used to answer that question succinctly \nby pointing to the registry entry. and it really isn't a hard thing to \nmake them work, so why not do it well?\n",
          "createdAt": "2015-10-29T07:34:09Z",
          "updatedAt": "2015-10-29T07:34:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "If we were working from a clean slate, that would be easy. We're not.\n",
          "createdAt": "2015-10-29T07:53:39Z",
          "updatedAt": "2015-10-29T07:53:39Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Yes, [RFC 4287](https://tools.ietf.org/html/rfc4287) specify the use of `/` as the separator instead of `#`:\n\n> Registry of Link Relations (Section 7), and thus to the IRI that would be obtained by appending the value of the rel attribute to the string \"http://www.iana.org/assignments/relation/\".  The value of \"rel\" describes the meaning of the link, but does not impose any behavioral requirements on Atom Processors.\n\nA resulting string after processing would thus be `http://www.iana.org/assignments/relation/first`. In order to be backward compatible with that scheme, we can't introduce `#`. I wish we had the foresight to specify `#` back in the early 2000's when we were dabbling with this, but that's too late now.\n\nWhat's nice, though, is that `http://www.iana.org/assignments/relation/first` redirects to `http://www.iana.org/assignments/link-relations/link-relations.xhtml`, which is a behavior I assume no one expects to a degree that they have baked it into their applications. It should therefore be possible to instead redirect to `http://www.iana.org/assignments/relation#first` (which imho should be the canonical URL for link relations; not `http://www.iana.org/assignments/link-relations/link-relations.xhtml`) without breaking anything.\n",
          "createdAt": "2015-10-29T08:03:00Z",
          "updatedAt": "2015-10-29T08:03:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@asbjornu sounds reasonable, although some people will undoubtedly copy the resulting `#` URL and use it to identify :(\n\nThe other thing we could do is auto-generate a file for each relation. I'm not thrilled with that, though.\n",
          "createdAt": "2015-10-29T08:08:09Z",
          "updatedAt": "2015-10-29T08:08:09Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Auto-generating files would then make `http://www.iana.org/assignments/relation/first` return `200 OK` instead of `302 Found`? If so, that's indeed a solution that would be both backwards and forwards compatible. Why aren't you thrilled with that solution?\n",
          "createdAt": "2015-10-29T08:31:31Z",
          "updatedAt": "2015-10-29T08:31:31Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "Some thoughts\n- http://www.iana.org/assignments/relation/# is absolutely fine.  That's how I do my identity ( http://melvincarvalho.com/#me ).  If it's already in an RFC probably makes some sense to stick to it.\n- That the resource dereferences is less important than that a normative resource exists.  This is something that will be very useful in implementations today.  Currently my clients store HTTP headers and having a namespace for them will help to improve the data integrity.\n- Redirects can be a pain to work with, especially with CORS.  From my experience, best avoided, and using plain old HTTP 200 is easy for software to deal with\n",
          "createdAt": "2015-10-29T11:33:41Z",
          "updatedAt": "2015-10-29T11:33:55Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@melvincarvalho:\n- It's not `http://www.iana.org/assignments/relation/#` that is in an RFC, it's `http://www.iana.org/assignments/relation/` without the `#` that's in [RFC 4287](https://tools.ietf.org/html/rfc4287#section-7.1). So introducing `#` would be a breaking change regardless of the trailing slash.\n- Being able to dereference the URI is important from an extensibility and usability point of view. It's much easier to figure out what something is by being able to plock the URL into your browser. From there, it's much easier to add metadata to the HTML (or whatever) document being returned, in the form of HTTP headers (such as the `Link` header), RDFa, and whatnot.\n- Good point wrt. CORS. @mnot's idea of minting new resources on each full (\"prefixed\") relation URI would solve that quite elegantly. Although it isn't a thrilling idea, according to him.\n",
          "createdAt": "2015-10-29T14:01:37Z",
          "updatedAt": "2015-10-29T14:01:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@asbjornu: It complicates the interaction with IANA considerably, and we can't reasonably expect them to do it on their own.\n",
          "createdAt": "2015-10-30T01:41:07Z",
          "updatedAt": "2015-10-30T01:41:07Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "Maybe HTTP 303 as FOAF does it?\n\n``` shell\n$ curl -I http://xmlns.com/foaf/0.1/knows\nHTTP/1.1 303 See Other\nDate: Fri, 30 Oct 2015 13:05:32 GMT\nServer: Apache/2.4.7 (Ubuntu)\nAccess-Control-Allow-Origin: *\nLocation: http://xmlns.com/foaf/spec/\nContent-Type: text/html; charset=iso-8859-1\n```\n\n> although some people will undoubtedly copy the resulting # URL and use it to identify :(\n\nI think that people who don't pay attention to use of appropriate URL will use technologies which allow simple use of registered strings.\n\nAlso http://www.iana.org/assignments/relation/first could do HTTP 303 redirect to #144 and machines would find all the information there without need for # fragments, while people could just search the page for relation they looked for (not perfect but still way better than 404)\n",
          "createdAt": "2015-10-30T13:14:29Z",
          "updatedAt": "2015-10-30T13:15:51Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "I want to support Elf's point. In the RDF world it is apparently quite customary to have redirects for canonical URIs, for instance\n\n`http://purl.org/dc/terms/abstract`\nredirects to \n`http://dublincore.org/documents/2012/06/14/dcmi-terms/?v=terms#abstract`\n\nand nobody seems to have any problem with that in RDF land. It certainly helps that the redirection points to a URI that really does not look very canonical :-)\n\nMaybe we can replicate that by redirecting from \nhttp://www.iana.org/assignments/relation/next\n\nto some fancy fragment identifier such as \nhttp://www.iana.org/assignments/link-relations/link-relations.xhtml#transient-next-non-canonical\n",
          "createdAt": "2015-10-30T13:54:55Z",
          "updatedAt": "2015-10-30T13:55:11Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "I'd really avoid this FOAF and DCT (anti?) pattern.  It's a pain to deal with redirects.  And I believe, to this day both those vocabs have problems with CORS.  We've been trying for years to fix that, and it's technically a challenge, even for experienced coders such as @danbri.  There's no reason to split up a document into mini files in that way, and is a maintenance burden.  I spent a long time trying to work out the motivation for this kind of pattern, and it boils down to \"it looks nice\".  If the list was several MB large, I could understand it.  \n",
          "createdAt": "2015-10-30T15:13:55Z",
          "updatedAt": "2015-10-30T15:13:55Z"
        },
        {
          "author": "danbri",
          "authorAssociation": "NONE",
          "body": "FOAF is not broken into \"files\". Screwing around with Apache configurations is a giant PITA.\n\nThe reason we went with / rather than # was that at the time (15 years ago) it was far from clear that using #blah on a content negotiable URI was sensible. Plus it didn't work for bigger things like Wordnet without forcing you to make a single giant download.\n",
          "createdAt": "2015-10-30T15:46:51Z",
          "updatedAt": "2015-10-30T15:46:51Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "@melvincarvalho:\n\nAm 30.10.2015 16:13 schrieb Melvin Carvalho notifications@github.com:\n\n> I'd really avoid this FOAF and DCT (anti?) pattern. It's a pain to deal with redirects. And I believe, to this day both those vocabs have problems with CORS. We've been trying for years to fix that, and it's technically a challenge, even for experienced coders such as @danbri. There's no reason to split up a document into mini files in that way, and is a maintenance burden. I spent a long time trying to work out the motivation for this kind of pattern, and it boils down to \"it looks nice\". If the list was several MB large, I could understand it.\n\nMaybe I misunderstand you completely, but what do you propose, then? Having a clean URL prefix http://www.iana.org/assignments/relation#  that both is a breaking change wrt to Atom and doesn't dereference? If it doesn't dereference, why is CORS an issue at all? \n",
          "createdAt": "2015-10-30T18:00:21Z",
          "updatedAt": "2015-10-31T05:38:36Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> If we were working from a clean slate, that would be easy. We're not.\n\nfrom http://tools.ietf.org/search/rfc4287#section-4.2.7.2\n\n> If a name is given, implementations MUST consider the link\n>    relation type equivalent to the same name registered within the IANA\n>    Registry of Link Relations (Section 7), and thus to the IRI that\n>    would be obtained by appending the value of the rel attribute to the\n>    string \"http://www.iana.org/assignments/relation/\"\n\nIMO HTTP 303 redirects for all URIs starting with mentioned prefix already defined by rfc4287 should work just fine. Implementations which chose to dereference those URIs, should cache response received after following redirect from URI of any relation, this way not needing to try fetch description of each relation one by one. I guess details of what such response should contain fits more #144 \n\n@gkellogg from where did you pick mentioned in https://github.com/ruby-rdf/rdf-vocab/issues/31 `http://www.iana.org/assignments/link-relations/` does any spec recommends it?\n",
          "createdAt": "2015-10-31T04:52:39Z",
          "updatedAt": "2015-10-31T04:54:11Z"
        },
        {
          "author": "gkellogg",
          "authorAssociation": "NONE",
          "body": "It looks like http://www.iana.org/assignments/link-relations/ was used in error when the vocabulary was moved. The issue is created for people who this may affect have a chance to speak up. However, as it's used as a convenience, it would only be likely to be a problem when interacting with systems that used the previous value stored in a triple store.\n",
          "createdAt": "2015-10-31T05:52:29Z",
          "updatedAt": "2015-10-31T05:52:29Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "Would IANA be willing to reorganize today's redirects and return 200 OK for `http://www.iana.org/assignments/relation`?\n\nWe have:\n1. `http://www.iana.org/assignments/relation/*` redirects to `http://www.iana.org/assignments/link-relations`\n2. `http://www.iana.org/assignments/link-relations/*` redirects to `http://www.iana.org/assignments/link-relations/link-relations.xhtml`\n3. `http://www.iana.org/assignments/link-relations/link-relations.xhtml` finally answers 200 OK\n\nCan that be changed so that:\n1. `http://www.iana.org/assignments/relation` returns 200 OK with a representation that describes the rels and ideally has fragment identifier targets for the rels?\n2. `http://www.iana.org/assignments/link-relations` redirects to 1\n3. `http://www.iana.org/assignments/link-relations/*` redirects to 1 (includes link-relations.xhtml)\n4. `http://www.iana.org/assignments/relation/<whatever>` redirects to `http://www.iana.org/assignments/relation#<whatever>` instead of today's redirect to link-relations.xhtml (as proposed by @asbjornu, who argued that this change of redirection is not likely to break anything. I also doubt that Atom clients or services use the fully qualified URL as rel because that would be a misunderstanding of the Atom RFC)\n\nOnly if IANA is willing to return 200 OK for `http://www.iana.org/assignments/relation` it makes sense to go forward with `http://www.iana.org/assignments/relation#` as canonical URL prefix without redirects that seem to cause CORS problems.\n\nIf IANA is not willing to make that change, then RFC5988bis could just make `http://www.iana.org/assignments/relation/` the canonical URL prefix and we are done. All necessary redirects are in place already and we are in line with Atom.\n",
          "createdAt": "2015-10-31T08:35:00Z",
          "updatedAt": "2015-10-31T08:35:00Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "@asbjornu Do I read you correctly that although you said\n\n> In order to be backward compatible with that scheme, we can't introduce #.\n\nyour final conclusion was that you still want \"relation#\" to be the new canonical URL prefix?\nIn that case I think @mnot's concern that people would wrongly copy the resulting # URL was a misunderstanding, because people would be right doing so.\n",
          "createdAt": "2015-10-31T08:35:12Z",
          "updatedAt": "2015-10-31T08:35:12Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "@dschulten I'm not making a proposal.  I'm merely pointing out that this would be a valuable thing to standardize.  Obviously if an HTTP URI is dereferenable that's much better than if it doesnt.  I'm also pointing out from implementation experience 303s are a huge challenge to deal with both from the client and server perspective, especially if you want it to be CORS enabled.  \n",
          "createdAt": "2015-10-31T13:01:37Z",
          "updatedAt": "2015-10-31T13:01:37Z"
        },
        {
          "author": "gkellogg",
          "authorAssociation": "NONE",
          "body": "How about returning 200 for http://www.iana.org/assignments/relation/<whatever> with the content of http://www.iana.org/assignments/relation/ containing the RDFS definitions, and also the Location header of http://www.iana.org/assignments/relation/. That seems to be an accepted pattern now and avoids redirection.\n",
          "createdAt": "2015-10-31T15:05:07Z",
          "updatedAt": "2015-10-31T15:05:07Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "To my understanding URIs for each relation e.g. http://www.iana.org/assignments/relation/alternate would sill need to redirect to that page which describes all of them. Assuming that prefix recommended by rfc4287 will not change to one with #\n",
          "createdAt": "2015-10-31T15:37:19Z",
          "updatedAt": "2015-10-31T15:37:19Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "@elf-pavlik it already redirects, and even twice via /link-relations \u263a\n",
          "createdAt": "2015-10-31T17:07:19Z",
          "updatedAt": "2015-10-31T17:07:19Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "So if we already have the redirections in place, and the RFC already says they end with `/` which is trickier to change now, then something like my XSLT to include such RDFa statement should be the main thing that is needed.\n\nYou are not required to follow the HTTP links (unless you want to) as:\n\n1) The RFC can define the namespace\n2) The RDFa on the registry page will include all the statements.\n\nIn the spec you can simply say something like: \n\n> Applications which require an absolute URI, e.g. producing Linked Data in RDF, MUST use the http://www.iana.org/assignments/relation/ namespace for IANA registered types, and only for IANA registered types. For instance, the registered type `alternate` is represented as the absolute URI http://www.iana.org/assignments/relation/alternate.\"\n",
          "createdAt": "2015-11-03T10:57:45Z",
          "updatedAt": "2015-11-03T10:58:02Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@stain Isn't it a problem that `http://www.iana.org/assignments/relation/alternate` redirects to ?`http://www.iana.org/assignments/link-relations/link-relations.xhtml` without a fragment identifier? Or will sprinkling RDFa on that HTML page suffice?\n\nI think we need to define (in RFC 2119 parlance) separate requirements for three different types of applications. Let's name them _RDF Applications_, _Legacy Applications_ and _Other Applications_, for simplicity. I think each application need separate requirements. Here are some pretty random requirements that probably don't go far enough in some areas and probably go way too far in others:\n\n## RDF Applications\n\n**RDF Applications** are applications producing Linked Data in RDF that require the relation types to be (expanded to) full URIs, such as RDF/XML, RDFa and JSON-LD.\n1. RDF Applications **MUST** use the `http://www.iana.org/assignments/relation/` namespace for IANA registered relations. For instance, the registered type `alternate` is represented as the absolute URI `http://www.iana.org/assignments/relation/alternate`.\n2. RDF Applications **MUST NOT** use the `http://www.iana.org/assignments/relation/` namespace for relations not registered in IANA. They **SHOULD** instead find relation types registered elsewhere, such as RDFS, Dublin Core, schema.org, etc. For instance, the RDFS `rest` relation should be represented as the absolute URI `http://www.w3.org/2000/01/rdf-schema#rest`.\n\n## Classic Applications\n\n**Classic Applications** are applications producing formats that have existing and defined semantics for implicitly namespaced (or prefixed) relation type strings, such as HTML, Atom and the HTTP `Link` header.\n1. Classic Applications **MUST NOT** use `http://www.iana.org/assignments/relation/` namespace for IANA registered relations. For instance, the registered type `alternate` should be represented as the opaque string `alternate` and not as the absolute URI `http://www.iana.org/assignments/relation/alternate`.\n2. Classic Applications **SHOULD** use a full URI and not opaque strings for relations that are not registered in IANA. For instance, the RDFS `rest` relation should be represented as the absolute URI `http://www.w3.org/2000/01/rdf-schema#rest`.\n\n## Other Applications\n\n**Other Applications** are applications that don't produce RDF, but at the same time don't have defined semantics for implicitly namesapced (or prefixed) relation type strings.\n1. Other Applications **SHOULD** use the `http://www.iana.org/assignments/relation/` namespace for IANA registered relations. For instance, the registered type `alternate` is represented as the absolute URI `http://www.iana.org/assignments/relation/alternate`.\n2. Other Applications **SHOULD** use a full URI and not opaque strings for relations that are not registered in IANA. For instance, the RDFS `rest` relation should be represented as the absolute URI `http://www.w3.org/2000/01/rdf-schema#rest`.\n\n## Structure\n\nThe above can (and probably should) be restructured so each requirement is stated and identified and then referenced from sections describing the requirements for each application type. This allows the requirements to be easily conveyed in a matrix, for instance.\n",
          "createdAt": "2015-11-04T14:25:04Z",
          "updatedAt": "2015-11-06T14:04:34Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "it's a bit ironic that in the text above all applications (except one) are described as \"legacy applications\", whereas the only one that happens to have home-made problems with non-URI identifiers is becoming the one true way forward.\nwhat i think would be a bad idea is to create the impression that URIs are valid identifiers. the registry contains strings, and these are valid identifiers. creating legitimate aliases for pretty much anything is a sure-fire way into non-interop, so please let's not do that.\nand looking ahead, i am wondering what's next. force media types to also be URIs? which other registries come next? IANA currently manages 1885 registries, and the vast majority of these have non-URI entries. all the \"legacy applications\" using those registries have been doing fine until now, and it's hard to see the problem, except for one specific technology not having a way to deal with non-URI identifiers.\n",
          "createdAt": "2015-11-05T17:58:54Z",
          "updatedAt": "2015-11-05T17:58:54Z"
        },
        {
          "author": "danbri",
          "authorAssociation": "NONE",
          "body": "This use of \"Legacy\" looks disrespectful of mainstream approaches (who have respectable reasons for their choices); I strongly recommend against that terminology.\n",
          "createdAt": "2015-11-05T18:27:48Z",
          "updatedAt": "2015-11-05T18:27:48Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@danbri The use of the word **Legacy** was not intended to be disrespectful. The above text is also in no way intended to be used in a specification. \"Legacy\" was just a label I had to invent in order to try to organize my thoughts on how we can classify the different applications of link relations.\n\nIs **Traditional** a better word? I'm open to ideas and am in no way attached to the names I've picked. I do think I've managed to separate the three different types of applications successfully, though. If you disagree, please let me know.\n\n> it's a bit ironic that in the text above all applications (except one) are described as \"legacy applications\"\n\n@dret Wrt \"legacy\", please see above. \n\n> whereas the only one that happens to have home-made problems with non-URI identifiers is becoming the one true way forward.\n\nIncorrect. Atom had the same problem more than 10 years ago. What other algorithm or process would you devise to make identifiers extensible?\n\n> what i think would be a bad idea is to create the impression that URIs are valid identifiers. the registry contains strings, and these are valid identifiers. creating legitimate aliases for pretty much anything is a sure-fire way into non-interop, so please let's not do that.\n\nThat's a valid point and one I agree we need to address thoroughly.\n\n> and looking ahead, i am wondering what's next. force media types to also be URIs?\n\nMedia types are already sufficiently extensible through the `vnd.` prefix.\n\n> which other registries come next? IANA currently manages 1885 registries, and the vast majority of these have non-URI entries.\n\nI have no idea, to be honest, but I think a majority of those 1885 registries should and will remain untouched by anything we choose to do with the link relation registry.\n\nBut if I were to boil it down to what the core of the problem is, I think it is **extensibility**. If a registry defines a way to extend its identifiers with minimum bureaucracy, it should interoperate just fine. If the extension process involves using URI prefixes; even better. If a registry is impossible to extend without publishing an RFC, it's a dead end for most uses of its identifiers.\n\n> all the \"legacy applications\" using those registries have been doing fine until now, and it's hard to see the problem, except for one specific technology not having a way to deal with non-URI identifiers.\n\nI disagree. Not having a distributed way to extend identifiers places a huge potential burden on anyone who wants to use the registered identifiers. Because at one point, the registered identifiers won't solve all the problems at hand, won't fit the application semantics or won't contain the identifiers the application requires. That's a fact of life regardless of the class of application and which technology it uses.\n",
          "createdAt": "2015-11-06T13:10:38Z",
          "updatedAt": "2015-11-06T13:10:57Z"
        },
        {
          "author": "danbri",
          "authorAssociation": "NONE",
          "body": "Maybe 'classic' or 'mainstream'? Perhaps I'm over-sensitive on this point but having seen 15 years of semweb advocacy try to describe all prior efforts as 'legacy', and having seen the reactions (offense, laughter, ...) I do suggest anything but 'legacy' would be an improvement. Traditional implies they are old-fashioned; 'classic' does too but seems slightly softer. Mainstream is vague but straightforward. \n",
          "createdAt": "2015-11-06T13:14:03Z",
          "updatedAt": "2015-11-06T13:14:03Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@danbri I like \"Classic\". I've updated my proposal. I don't want to be mistaken for a semweb advocate, though, since I've just started trying to understand what it is through my involvement in [Hydra](http://www.hydra-cg.com/), which is based on [JSON-LD](http://json-ld.org/), which (quite invisibly, imho) is powerd by RDF. :wink: \n",
          "createdAt": "2015-11-06T14:07:07Z",
          "updatedAt": "2015-11-06T14:07:07Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-11-06 14:10, Asbj\u00f8rn Ulsberg wrote:\n\n> But if I were to boil it down to what the core of the problem is, I\n> think it is _extensibility_. If a registry defines a way to extend its\n> identifiers with minimum bureaucracy, it should interoperate just fine.\n> If the extension process involves using URI prefixes; even better. If a\n> registry is impossible to extend without publishing an RFC, it's a dead\n> end for most uses of its identifiers.\n\nyou don't need an RFC. registration is via the mailing list, and all you \nneed is some document saying what your link relation represents (and i \nthink that's a fair ask), and then you can send a request to the list. \nmany/most choose to write short RFCs, but that's probably just because \nthey are a nice way to get some feedback and consensus.\n\n> I disagree. Not having a distributed way to extend identifiers places a\n> huge potential burden on anyone who wants to use the registered\n> identifiers. Because at one point, the registered identifiers won't\n> solve all the problems at hand, won't fit the application semantics or\n> won't contain the identifiers the application requires. That's a fact of\n> life regardless of the class of application and which technology it uses.\n\nhave a close look at how link relations work today:\n- if you want to use a registered value, then use an existing one, or \n  submit a new one and get it registered. using such a string then means \n  that it's supposed to be registered.\n- if you don't feel like using registered values, you can always use \n  URIs, and then it's implicit that the link relation is not a registered \n  one, but one that somebody made up. if you want, you can use HTTP URIs \n  and put some documentation there (and that's how we did it in my \n  previous company), but that's just you being nice to devs.\n",
          "createdAt": "2015-11-06T16:09:26Z",
          "updatedAt": "2015-11-06T16:09:26Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> you don't need an RFC. registration is via the mailing list, and all you need is some document saying what your link relation represents (and i think that's a fair ask), and then you can send a request to the list. many/most choose to write short RFCs, but that's probably just because they are a nice way to get some feedback and consensus.\n\nSay you want to publish a simple JSON API for your local library. You do it mostly free of charge and good will. Given this or similar situations, I'd say that just being able to figure the registration procedure out is a major task, let alone complete it. Although joining a mailing list and sending an e-mail is simple enough, it's the whole process, starting from pretty user unfriendly plain text RFC's, that's just not optimized for dialogue and participation.\n\nI know this is a bigger problem to fix than what can be achieved in one registry and the RFC describing how it works, but until that bigger problem is fixed, the process of registering link relations needs to be distributed. And extensibility through the use of URIs works pretty well, I think.\n\n> if you want to use a registered value, then use an existing one, or submit a new one and get it registered. using such a string then means that it's supposed to be registered.\n\nI agree that all strings should be registered. But with the current process, I think that's too much to expect.\n\n> if you don't feel like using registered values, you can always use URIs, and then it's implicit that the link relation is not a registered one, but one that somebody made up.\n\nYes, this is what RFC 4287 and 5988 already specifies. And that makes unregistered link relations work better with RDF than registered, which is the problem we're trying to solve here.\n",
          "createdAt": "2015-11-09T07:47:28Z",
          "updatedAt": "2015-11-09T07:47:28Z"
        },
        {
          "author": "letmaik",
          "authorAssociation": "NONE",
          "body": "Is it accepted that rel=\"type\" becomes \"http://www.iana.org/assignments/relation/type\" and not \"rdf:type\"? Or would the relation between those two be expressed separately, e.g. with rdfs:subPropertyOf? I guess there are other such examples as well.\n",
          "createdAt": "2015-11-13T09:44:15Z",
          "updatedAt": "2015-11-13T09:44:15Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@neothemachine I really think that W3C should deal with such questions and IANA only take the responsibility for providing official URIs for all registered link relations. I really worry that by trying to address to much in this issue we may only delay its resolution within the original scope.\n",
          "createdAt": "2015-11-13T09:53:40Z",
          "updatedAt": "2015-11-13T09:53:40Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "@mnot can we already consider **http://www.iana.org/assignments/relation/** as official (to be) prefix?\nBTW http://prefix.cc/ianarel\n",
          "createdAt": "2016-03-13T00:37:13Z",
          "updatedAt": "2016-03-13T00:37:13Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "Id much rather see:  http://www.iana.org/assignments/relation#\n\nMay involve tweaking a couple of specs.\n\nExperience from hosting vocabularies such as foaf is that using slash uris are much harder to get working with things like cors,https,redirects than a single resource using hash uris.\n",
          "createdAt": "2016-03-13T06:21:02Z",
          "updatedAt": "2016-03-13T06:21:02Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "@elf-pavlik please dont squat name spaces before consensus is arrived at (ie the issue is closed)\n",
          "createdAt": "2016-03-13T06:28:17Z",
          "updatedAt": "2016-03-13T06:28:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "`http://www.iana.org/assignments/relation/` was defined by Atom, which was the precursor to RFC5988, so it's the established base URI. In that sense, it's as official as we've got.\n\nUsing anything else is going to be difficult, not just a \"tweaking a couple of specs.\" It would be _possible_ to say that that prefix is just for the Atom serialisation, but doing so seems very likely to leave the world a significantly worse (and more confusing) place, as there will be different prefixes used in different contexts, and the need to translate prefixes when moving links around. Yuck.\n",
          "createdAt": "2016-03-13T23:33:28Z",
          "updatedAt": "2016-03-13T23:33:28Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'd argue that what @mnot says about making the world a worse place also applies to re-introducing the deprecated `http://www.iana.org/assignments/relation/` prefix. it would effectively introduce non-unique identifiers (assuming the raw strings remain valid). every implementation would have to be coded to treat the prefixed and the raw form as identical, and that's rather unlikely to happen in a reliable manner. this was exactly the reason why the prefix was dropped, because implementation experience showed that developers conveniently only supported the identifer \"variant\" they cared about (i.e., they produced), leading to non-interoperable implementations.\nbtw, over at https://github.com/dret/I-D/blob/master/registries/draft-wilde-registries-02.txt#L652 i am trying to write about this problem more generally. web linking is an interesting case study (i think), and whatever is going to happen in RFC5988bis, i am curious to see what it is and how it will play out.\n",
          "createdAt": "2016-03-14T11:00:43Z",
          "updatedAt": "2016-03-14T11:01:20Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> implementation experience showed that developers conveniently only supported the identifer \"variant\" they cared about (i.e., they produced), leading to non-interoperable implementations.\n\nif someone doesn't care about interoperability i think we all need to simply accept it and don't expect to interoperate with systems developed by those people.\ni would really like to focus on how to agree with people who do care about interoperability and do best with making it possible for them to do what they/we care about and develop interoperable systems \n",
          "createdAt": "2016-03-14T18:53:21Z",
          "updatedAt": "2016-03-14T18:53:21Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-03-14 18:53, elf Pavlik wrote:\n\n> if someone doesn't care about interoperability i think we all need to\n> simply accept it and don't expect to interoperate with systems developed\n> by those people.\n\nit's not that they didn't care. it's just that the rules were bad and \nmade it easy do not do the right thing. non-unique identifiers are a bad \nidea. that this idea breaks things has been proven to happen. seeing if \nit happens again may not be the best way forward.\n\n> i would really like to focus on how to agree with people who do care\n> about interoperability and do best with making it possible for them to\n> do what they/we care about and develop interoperable systems\n\nsure, i think we all agree on the end goal. but you can design \ninteroperability in many ways, some of them good, others maybe not so \nmuch. if we have real-world experience with one of these ways, we \nprobably should not ignore it.\n",
          "createdAt": "2016-03-14T20:10:25Z",
          "updatedAt": "2016-03-14T20:10:25Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "https://github.com/mnot/I-D/blob/gh-pages/rfc5988bis/draft.md#extension-relation-types\n\n> Note that while extension relation types are required to be URIs, a serialisation of links can specify that they are expressed in another form, as long as they can be converted to URIs.\n\nMaybe in a similar way serialisation of links can specify weather to use URIs for registered relations or not? Conversion to official registered identifiers in that case happens by simply removing the prefix we discuss here.\n",
          "createdAt": "2016-03-14T21:29:38Z",
          "updatedAt": "2016-03-14T21:32:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@elf-pavlik I don't think you'd be able to convince folks that HTML, HTTP headers or Atom should effectively change their API to do this. However, another serialisation (such as RDF) certainly could.\n\nAnother option would be for an _application_ of linking to specify how this should be done for it, independent of the serialisation. See #142.\n",
          "createdAt": "2016-03-14T23:01:15Z",
          "updatedAt": "2016-03-14T23:01:15Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-03-14 21:29, elf Pavlik wrote:\n\n> https://github.com/mnot/I-D/blob/gh-pages/rfc5988bis/draft.md#extension-relation-types\n>     Note that while extension relation types are required to be URIs, a\n>     serialisation of links can specify that they are expressed in\n>     another form, as long as they can be converted to URIs.\n> \n> Maybe in a similar way serialisation of links can specify weather to use\n> URIs for registered relations or not? Conversion to official register\n> identifiers in that case happens by simply removing the prefix we\n> discuss here.\n\nif a serialization defines a mapping from a value adhering to the value \nspace defined by the spec to some serialization-specific representation \nof that value, then that's something that cannot even be controlled by \nthe spec defining the value space.\n\ni'd still think that there's a risk for the serialization-specific \nrepresentations to leak out into the world, but that's a risk that the \ndesigners of such a mapping scheme would have to consider.\n",
          "createdAt": "2016-03-16T10:35:10Z",
          "updatedAt": "2016-03-16T10:35:10Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just throwing it into the mix, because it exists: https://tools.ietf.org/html/rfc3553 defines URIs for any \"Registered Protocol Parameters\". it could be used as a foundation to turn non-URI parameters into URIs, by simply using the URNs themselves as values. using RFC 3553, link relation values would then look something like `urn:ietf:params:link-relations:alternate`. of course, adopting this scheme would not also be a breaking change to RFC 5988 values, but it would avoid the problem of creating URIs that could suffer from excessive load.\n",
          "createdAt": "2016-03-22T09:15:07Z",
          "updatedAt": "2016-03-22T09:15:07Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "@dret thanks for point out that urn: spec.  That hierarchical URN does make sense, and would be an improvement on what we have today, for many systems.  It's the logical URN to use, I think.\n\nCouple of observations, one that is it quite long, and shorter URIs tend to correlate well with adoption.  Ive personally always wondered why the URI spec does not allow simple variable definitions such as `urn:foo`\n\nThe advantage of an HTTP URIs, at least in principle, is that it is easily dereferencable.  I suppose it would be possible to make a one to one link between a URN and an http URI, but that might extra complexity in the software.  \n",
          "createdAt": "2016-03-22T09:56:41Z",
          "updatedAt": "2016-03-22T09:56:41Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I feel that choosing URNs instead of (dereferencable) HTTP URIs to avoid load on the URIs is premature optimisation.\n\n>  I suppose it would be possible to make a one to one link between a URN and an http URI, but that might extra complexity in the software.\n\nI don't really see the value of this when we can just use an HTTP URI in the first place. It is worth mentioning that the load on W3C's HTML DTD is, as far as I know, not longer a problem. And the infrastructure (CDN's, etc.) to handle this in a scalable way is better today than it was [8 years ago when W3C had this problem](https://www.w3.org/blog/systeam/2008/02/08/w3c_s_excessive_dtd_traffic/).\n",
          "createdAt": "2016-03-22T14:23:13Z",
          "updatedAt": "2016-03-22T14:23:13Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-03-22 10:56, Melvin Carvalho wrote:\n\n> Couple of observations, one that is it quite long, and shorter URIs tend\n> to correlate well with adoption. Ive personally always wondered why the\n> URI spec does not allow simple variable definitions such as |urn:foo|\n\nthat's actually a problem of the spec for the URN URI scheme (not of the \nURI spec itself). since a URN is just one kind of URI, they kind of had \nto start their syntax with an \"authority\" component, hence that second \nstep: http://tools.ietf.org/html/rfc2141\n\ni don't think the resulting URIs are overly long. all steps kind of make \nsense, and the URIs are pretty succinct and readable.\n\n> The advantage of an HTTP URIs, at least in principle, is that it is\n> easily dereferencable. I suppose it would be possible to make a one to\n> one link between a URN and an http URI, but that might extra complexity\n> in the software.\n\nthe IETF URNs explicitly have no defined resolution mechanism. that's \npartly because it's not even clear what they should resolve to. if you \nhave a protocol parameter, what matters is the identity of that \nparameter, and that's uniquely identified by the URN. there's simply \nnothing left to say. URNs usually are identifiers that are meant to be \nused as values, not as references.\n\nif for an application you want those URNs to resolve, then you define a \nresolution process for your context. for example, i am using IETF \ndocument URNs and want them to resolve to the spec text (that's just my \nchoice for my context). i can easily do this by writing simple code, or \neven simpler (in my case), by writing regex-based mappings:\n\nhttps://github.com/dret/sedola/blob/master/XSLT/specs.xml\n",
          "createdAt": "2016-03-22T20:13:22Z",
          "updatedAt": "2016-03-22T20:13:22Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "after digging around a lot more, i have now learned that RFC 3553 also allows namespaces to be defined and registered (http://www.iana.org/assignments/params/params.xhtml#urn-subnamespaces lists the currently registered ones). this has to be done when a registry is created (or possibly updated). this means that following RFC 3553 procedure, it would be possible to use the IETF URN namespace to identify both the link relation registry and registered values via URNs. this would fit into the way how IETF is already doing this (for select registries, i.e. those where registry creators chose to also define and register an IETF URNs namespace).\n",
          "createdAt": "2016-03-24T09:39:32Z",
          "updatedAt": "2016-03-24T09:39:32Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "Great findings @dret \n\nI see some cases where using HTTP URIs and allowing dereferencing them offers advantages. For example:\n- A _describedby_ B\n- B _describes_ A\n\nhttps://tools.ietf.org/html/rfc6892\n\nIf C wants to make such statement, often choice between using 'describedby' or 'describes' becomes arbitrary. Also when someone gets this information from C, will need to always check for both cases.\n\nBoth _describesby_ and _described_ could after dereferencing provide information that one can treat the other as the same but in reverse direction e.g. [owl:inverseOf](https://www.w3.org/TR/owl2-primer/#Property_Characteristics)\n\nGoing down the URN path seems like not taking advantage from potential of making identifiers self describing. When things evolve, one could use HTTP redirects to mark that one identifier got superseded by another one, or provide such information in the body of the response using assertions like https://schema.org/supersededBy\n",
          "createdAt": "2016-03-24T13:49:31Z",
          "updatedAt": "2016-03-24T16:49:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, re-reading this thread. We originally re-opened it to talk about putting stronger constraints around the use of the Atom base URL, so I've done that; see above.\n\nDoes anyone want to argue that there needs to be a base URL (whether it's HTTP, URN, or whatever) that is constant across applications that opt into it -- i.e., that this specification should define a default that applications can opt into?\n\nIf not, will close.\n",
          "createdAt": "2016-04-26T07:10:31Z",
          "updatedAt": "2016-04-26T07:10:31Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "isn't that last commit making things even a bit less predictable, because now applications have the green-ish light to add any prefix, and there's no clear definition when that would be ok and when not? i think the reason why this was creating interop problems was that it was weakly worded. however, it is introducing alias values for identifiers, so in order to me robust it must be strongly worded (in which case implementations may still ignore it, which happened and which imho would continue to be the case), or disallowed. if the latter, then no explicit wording is necessary: if you want to refer to a registered value, you have to use the defined value. that's the reality we have now and that seems to work.\n",
          "createdAt": "2016-04-26T12:56:40Z",
          "updatedAt": "2016-04-26T12:59:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I don't think that's a green light, it's a warning that if you create your own name space for registered relation types, other applications won't necessarily understand them, so you do it at your own risk.\n\nHappy to make changes to clarify that.\n",
          "createdAt": "2016-04-27T01:00:03Z",
          "updatedAt": "2016-04-27T01:00:03Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-04-26 18:00, Mark Nottingham wrote:\n\n> I don't think that's a green light, it's a warning that if you create\n> your own name space for registered relation types, other applications\n> won't necessarily understand them, so you do it at your own risk.\n\nbut why put that in there at all? if there's exactly one correct way to \nrefer to a registered value (which i would strongly suggest there should \nbe), then that's all that needs to be said. i think there's no need to \npoint out that if you're using an incorrect value by using some \nproprietary mapping such as using a prefix, that you shouldn't expect it \nto be interoperable.\n",
          "createdAt": "2016-04-27T01:49:12Z",
          "updatedAt": "2016-04-27T01:49:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "How about something like:\n\n> Historically, applications have sometimes referred to registered relation types with a URI {{RFC3986}} (e.g., {{atom}}) by prefixing their names with an application-defined base URI. This practice is NOT RECOMMENDED, because the resulting strings will not be considered equivalent to the registered relation types by other processors. Applications that do use such URIs internally MUST NOT use them in serialisations that do not explicitly accommodate them.\n",
          "createdAt": "2016-04-27T04:22:57Z",
          "updatedAt": "2016-04-27T04:22:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> How about something like:\n>     Historically, applications have sometimes referred to registered\n>     relation types with a URI {{RFC3986}} (e.g., {{atom}}) by prefixing\n>     their names with an application-defined base URI. This practice is\n>     NOT RECOMMENDED, because the resulting strings will not be\n>     considered equivalent to the registered relation types by other\n>     processors. Applications that do use such URIs internally MUST NOT\n>     use them in serialisations that do not explicitly accommodate them.\n\nwhat are \"serialisations that explicitly accommodate them\"? values will \nvery easily disseminate through perceived format boundaries. for \nexample, if you have JSON-LD, then you would like to see the registered \nvalues to be used in the actual JSON. but people using RDF tooling may \nend up creating URIs, because from their perspective, they have been \nusing RDF so using URIs was kind of ok. and their JSON-LD toolbox may \nnot even have support for value mapping when serializing  RDF to JSON-LD.\n\nwell, i don't want to hold up things here all by myself. i just think \nwe're trading spec clarity and robustness for a rather fuzzy value \nproposition and introducing quite a bit of risk and brittleness. \nallowing value aliases is one of the cardinal sins of managing \nidentifier namespaces.\n",
          "createdAt": "2016-04-27T04:44:33Z",
          "updatedAt": "2016-04-27T04:44:33Z"
        },
        {
          "author": "danbri",
          "authorAssociation": "NONE",
          "body": "/cc @chaals\n",
          "createdAt": "2016-04-27T07:37:31Z",
          "updatedAt": "2016-04-27T07:37:31Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "I think it should only be NOT RECOMMENDED if you can use the short form - e.g. in the Link header - while we do mandate the base URI where a full IRI is required by the application.\n\nSomething like: \n\n> In applications that require absolute IRIs (e.g. RDF 1.1) for referencing IANA relations, the fixed base IRI http://www.iana.org/assignments/relation/ SHOULD be used, e.g. http://www.iana.org/assignments/relation/describes. It is NOT RECOMMENDED to use such IRIs in applications that support the IANA shortform (e.g. \"describes\") because the resulting strings will not be considered equivalent to the registered relation types by other processors.\n",
          "createdAt": "2016-04-27T09:16:58Z",
          "updatedAt": "2016-04-27T09:16:58Z"
        },
        {
          "author": "stain",
          "authorAssociation": "NONE",
          "body": "In other words - 2 specified identifier schemes is better than `n` identifier schemes.\n",
          "createdAt": "2016-04-27T09:17:49Z",
          "updatedAt": "2016-04-27T09:17:49Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@stain With some langauge identifying the `describes` relation as the one defined in RFC 6892, I think your wording provides sufficient guidance and clarification. :+1: \n",
          "createdAt": "2016-04-27T13:36:48Z",
          "updatedAt": "2016-04-27T13:38:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On Apr 27, 2016, at 02:17, Stian Soiland-Reyes notifications@github.com wrote:\n> In other words - 2 specified identifier schemes is better than n identifier schemes.\n\n+1\n\nbut 2 representations of one value is still worse than 1.\n",
          "createdAt": "2016-04-27T14:48:20Z",
          "updatedAt": "2016-04-27T14:48:20Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ```\n> In applications that require absolute IRIs (e.g. RDF 1.1) for\n> referencing IANA relations, the fixed base IRI\n> http://www.iana.org/assignments/relation/ SHOULD be used, e.g.\n> http://www.iana.org/assignments/relation/describes.\n> ```\n\ni think my main concern with all of these attempts to (a) make sure \nregistered values are used, but (b) also half-heartedly bless the use of \nURIfied aliases is this:\n\none of the main tenets of web architecture is that i shouldn't have to \ncare about how some service is implemented behind the REST surface. \nallowing the implementation to shine through (oh, somebody used RDF for \nimplementation, so all my link relations now show up as URIs) undermines \nthis. it also shouldn't matter to me as a service user if an \nimplementation changes from RDF to non-RDF, or vice versa. if it does, \nsomething in the service fabric broken.\n\nsaying that \"it is fine to use the URIfied variants if both sides agree \nthat they like it that way\" introduces tight coupling based on \nimplementation details. this is one of the popular antipatterns of REST, \nwhich is why i am (as you can probably tell ;-) so worried about \nblessing this kind of rift in the web's service ecosystem, however \nhedged this blessing is by \"please try to not let those aliases escape \ninto the wild\" language.\n",
          "createdAt": "2016-04-27T17:43:35Z",
          "updatedAt": "2016-04-27T17:43:35Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> > In other words - 2 specified identifier schemes is better than n identifier schemes.\n> \n> +1\n> but 2 representations of one value is still worse than 1.\n\nfrom https://tools.ietf.org/html/rfc3987\n\n> This document creates a new sub-delegation below the \"ietf\" [2]URN namespace [1] called 'params' which acts as a standardized mechanism for naming the items registered for IETF standards.\n\nI think that RFC 3987 and prefix introduced in Atom spec, prove need for identifying registered parameters with URIs. Of course we can argue about advantages of `urn:` scheme vs. advantages of `http:` scheme. Still if something can have one and only one identifier, URI seems like a obvious choice. URIs also have clear rules for compacting them https://www.w3.org/TR/curie/\n\nTo my understanding in this issue we don't discuss how perfect world would look like but our best options to improve the current state of things. While URIs in `urn:` scheme already allow to use them as identifiers in RDF. I see some evidences of utility in retrieving structured data by resolving URI.\n- https://www.iana.org/assignments/media-types/application/json\n\n> Additional information:  Magic number(s): n/a\n>    File extension(s): .json\n>    Macintosh file type code(s): TEXT\n- https://www.iana.org/assignments/media-types/application/ld+json\n\nStandardizing `http:` prefix for identifying link relations can serve as field test for usefulness of identifying registered parameters with URIs with well defined resolution mechanism. RFC4287 already opened that door, which makes it a good candidate for giving it a chance.\n",
          "createdAt": "2016-04-27T22:02:56Z",
          "updatedAt": "2016-04-27T22:02:56Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-04-27 15:02, elf Pavlik wrote:\n\n> Standardizing |http:| prefix for identifying link relations can serve as\n> field test for usefulness of identifying registered parameters with URIs\n> with well defined resolution mechanism. RFC4287 already opened that\n> door, which makes it a good candidate for giving it a chance.\n\nthat's an odd way of looking at where we are. RFC 4287 opened it, maybe, \nbut RFC 5988 closed it (being specific about the fact that URIs are \nlegacy and maybe are used in atom, but shouldn't). so what we're having \ntoday is a world with a lot deployed applications that use the \nregistered values, and depend on them being used. that's simply the \nreality we have to deal with, regardless of the options we would have if \nwe started with a clean slate.\n",
          "createdAt": "2016-04-28T01:00:46Z",
          "updatedAt": "2016-04-28T01:00:46Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@dret What seems to be missing from your equation is the use-case of distributed creation of link relations, which was the reasoning behind section 4.2.7.2 of RFC 4287, IIRC. I also don't read RFC 5988 the same way as you, which I believe is one of the reasons this issue exists in the first place.\n\nI think the internet community still needs a way to mint proprietary link relations without the overhead of registering them in IANA. I believe that use-case will exist even if the process of registering relations is made a global showcase of bleeding edge user-friendlyness and simplicity.\n\nThe solution we came up with in Atom WG to allow for distributed creation of link relations was to use a URI. To make that consistent with the non-URI relations that already existed, we invented a prefix that made `http://www.iana.org/assignments/relation/describes` and `describes` equal. Looking back, I think it might have been wiser to obsolete the non-URI relations and mandate the use of the IANA base URI prefix.\n\nAccidentally, the idea of using URIs have shown to fit with other use-cases as well, such as in RDF. However, I do think those are two different use-cases that shouldn't be conflated.\n",
          "createdAt": "2016-04-28T08:38:09Z",
          "updatedAt": "2016-04-28T08:38:09Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-04-28 01:38, Asbj\u00f8rn Ulsberg wrote:\n\n> @dret https://github.com/dret What seems to be missing from your\n> equation is the use-case of distributed creation of link relations,\n> which was the reasoning behind section 4.2.7.2 of RFC 4287, IIRC. I also\n> don't read RFC 5988 the same way as you, which I believe is one of the\n> reasons this issue exists in the first place.\n\nfor distributed creation, there are extension relation types, which seem \nto work just fine in practice, afaict.\n\nhttps://tools.ietf.org/html/rfc5988#section-4.2\n\n> I think the internet community still needs a way to mint proprietary\n> link relations without the overhead of registering them in IANA.\n\nthat's a very different discussion, on whether a registry is the right \npattern to use for keeping track of link relation identifiers. to me the \n\"overhead issue\" is a problem of perception, but than nevertheless is a \nproblem. but regardless of that, \"namespace design\" and \"namespace \nmanagement\" are two different issues.\n\n> I\n> believe that use-case will exist even if the process of registering\n> relations is made a global showcase of bleeding edge user-friendlyness\n> and simplicity.\n\nthen let's look at those use cases. so far i see little problems in \npractice. many register their link relations, the registry is growing \nslowly but steadily. and for those that see it as a hurdle as you do, i \nhave helped with the registration process a number of times for \ncurrently evolving w3c specs. i did not do that much, and it did not \ntake a lot of time or effort, just the willingness to make those values \nwell-known.\n\n> The solution we came up with in Atom WG to allow for distributed\n> creation of link relations was to use a URI. To make that consistent\n> with the non-URI relations that already existed, we invented a prefix\n> that made |http://www.iana.org/assignments/relation/describes| and\n> |describes| equal. Looking back, I think it might have been wiser to\n> obsolete the non-URI relations and mandate the use of the IANA base URI\n> prefix.\n\nmaybe. but that train has left the station a long time ago. there really \nis no point to discuss that any more, we cannot change the past.\n\n> Accidentally, the idea of using URIs have shown to fit with other\n> use-cases as well, such as in RDF. However, I do think those are two\n> different use-cases that shouldn't be conflated.\n\nafaict, RDF seems to be the only model that has trouble using non-URI \nidentifiers. everybody else seems to be happy either way, happily living \nin RFC 5988 land using link relation types that are either short names \nor strings.\n\nalso, please keep in mind that originally, this issue _was not_ about \nchanging the registered values from strings to URIs. that notion just \ncrept in and maybe should be factored out anyway. originally, this issue \nis _only_ about having dereferencable URIs for link relation types, but \nthe identifiers that must be used would still be the short names and not \nthe URI.\n",
          "createdAt": "2016-04-28T15:08:22Z",
          "updatedAt": "2016-04-28T15:08:22Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> also, please keep in mind that originally, this issue _was not_ about changing the registered values from strings to URIs. that notion just crept in and maybe should be factored out anyway. originally, this issue is _only_ about having dereferencable URIs for link relation types, but the identifiers that must be used would still be the short names and not the URI.\n\nI understood that as of last iteration, depending on _application_ spec marks identifying link relations with URIs as **NOT RECOMMENDED** but allowed. Which I see enough so that people who have reason to use NOT RECOMMENDED option can still do so.\n\nNow for example, after parsing HTTP Link header, RDF applications can simply store all the links as triples, of course during serializing triples for use in HTTP Link header, application must always remove the _http://www.iana.org/assignments/relation/_ prefix. While one can argue that each application can choose one's own prefix for that purpose, having a standard prefix to only use it in very specific cases makes thing interoperate better in many cases. For example if `application/trig` response wants to make information from HTTP Link header also available in the payload as separate named graph.\n\n:+1: from me for providing standard prefix, marking it as **NOT RECOMMENDED** and shortly explaining possible interoperability issue when using it in not appropriate application.\n",
          "createdAt": "2016-04-28T15:45:00Z",
          "updatedAt": "2016-04-28T15:45:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "> what are \"serialisations that explicitly accommodate them\"? \n\nE.g., as Atom does, or as RDF probably would. \n\n> values will very easily disseminate through perceived format boundaries. for\n> example, if you have JSON-LD, then you would like to see the registered\n> values to be used in the actual JSON. but people using RDF tooling may\n> end up creating URIs, because from their perspective, they have been\n> using RDF so using URIs was kind of ok. and their JSON-LD toolbox may\n> not even have support for value mapping when serialising  RDF to JSON-LD.\n\nIf you implement a parser that ingests links from a serialisation that has such a mapping, it's your responsibility to convert them to registered link relations before serialising them into another format. It _needs_ to be a requirement of the serialisation.\n",
          "createdAt": "2016-04-29T01:13:35Z",
          "updatedAt": "2016-04-29T01:13:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "WRT 2 specified vs n -- The problem is that Atom already specifies one extra way to serialise registered relation types, and many have expressed dissatisfaction with that base URI (because it's controlled by IANA, because what's at the URL isn't what is desired, because it isn't a # URI, etc.). \n\nTherefore, I highly suspect we're going to have at least three. Baking the third into this spec raises the chances that we'll get it wrong, for some community (the Semantic Web isn't the only game in town).\n\nAs with many things, the right number is likely to be zero, one, or many.\n",
          "createdAt": "2016-04-29T01:23:43Z",
          "updatedAt": "2016-04-29T01:23:43Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-04-28 18:13, Mark Nottingham wrote:\n\n> If you implement a parser that ingests links from a serialisation that\n> has such a mapping, it's your responsibility to convert them to\n> registered link relations before serialising them into another format.\n> It /needs/ to be a requirement of the serialisation.\n\ni agree. but isn't that saying that if you claim to use/expose link \nrelation types as spec'ed and registered, you MUST use the identifiers \nin their single correct representation? and if so, then why even say \nthat in some contexts, people may do things differently?\n\ni understand the RFC 5988 language to acknowledge the RFC 4287 legacy, \nbut by now we might be over that hump of introducing and then having to \ndeal with aliases. i haven't seen any of these in the wild for quite a \nwhile. people haven't used them, afaict, because they weren't interoperable.\n\nto me, this is like knowing that in some implementations/contexts, \npeople decide to use numbers instead of media type identifiers. there's \nnothing we can do to stop them from doing it, but there's no need to \neven acknowledge that it's happening. if you want to represent a media \ntype, it must be in the x/y form; anything else is not a media type \nidentifier.\n\n[[ btw, anybody know of an dataset of HTTP headers harvested in the wild \n(preferably even over time) that we could analyze and see which link \nrelations show up in link headers? not necessarily a representative way \nof measuring link relation type usage in general, but maybe interesting \nnevertheless. ]]\n",
          "createdAt": "2016-04-30T01:13:36Z",
          "updatedAt": "2016-04-30T01:13:36Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> WRT 2 specified vs n -- The problem is that Atom already specifies one extra way to serialise registered relation types, and many have expressed dissatisfaction with that base URI (because it's controlled by IANA, because what's at the URL isn't what is desired, because it isn't a # URI, etc.). \n\nI would see comments on current `http:` prefix more as proposals for various possible improvements than dissatisfaction that one standard prefix exists. As of today, registered link relations act just as unique identifiers and to my knowledge no one expects to discover additional information by dereferencing them. Possibly at some point in the future IETF will find interest to leverage this currently dormant potential, but as of today I believe everyone, who shared mentioned feedback, can live with agreeing just on the standard `http` prefix. I think that keeping question, what response one can expect when dereferencing link relation URIs, as separate issue makes a lot of sense here. Once we agree on the prefix it can take as much time as needed and available to work on answering that question.\n\nNot sure if we still should take just a quick look at HTTP vs HTTPS ? AFAIK schema.org started moving their prefix to HTTPS http://schema.org/docs/faq.html#19\n",
          "createdAt": "2016-04-30T23:22:50Z",
          "updatedAt": "2016-04-30T23:22:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@dret it's pretty clear that there are some communities that want to use them, so some guidance would help avoid common pitfalls.\n\nI don't think that having One True Prefix in the spec is going to be helpful, because AIUI there are some fairly exacting requirements on how that namespace is run, both in terms of the URIs and potentially what happens when you dereference them (based on discussion with @timbl). \n\nIn this approach, a serialisation of links like JSON-LD can use URIs for registered relation types as it wishes, and have appropriate assurances that it controls that name space; much easier than offloading that task to IANA. \n\nFurthermore, as long as it assures that they're converted back to \"native\" registered link relations at the appropriate time, it can interoperate well with other applications / serialisations, whether they recognise the prefix or don't.\n",
          "createdAt": "2016-05-03T01:05:22Z",
          "updatedAt": "2016-05-03T01:05:22Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-05-02 18:05, Mark Nottingham wrote:\n\n> @dret https://github.com/dret it's pretty clear that there are some\n> communities that want to use them, so some guidance would help avoid\n> common pitfalls.\n\ni am sorry to be pedantic, but what is \"them\"? i think we have to be \nreally clear about what we are talking about, and in the discussions so \nfar, i think to things get mixed up:\n- the normative lexical value of registered relation types.\n- stable URIs that can be used to refer to the types, but are not the \n  lexical value of the type.\n\nsorry if this is a dumb example, but just to make it clear, it is like \nthis when talking about language tags (a la RFC 5646)\n- the normative lexical value for english is \"en\"\n- http://www-01.sil.org/iso639-3/documentation.asp?id=eng is the URI \n  that is closest to a being a URI for the \"en\" language tag.\n\ni have to admit that i have a hard time distinguishing the cases when \nthe discussion is about changing the lexical value (or adding a second \nallowed lexical value, which is a URI), and when it is about being more \ndisciplined in having stable and well-defined URIs.\n\n> I don't think that having One True Prefix in the spec is going to be\n> helpful, because AIUI there are some fairly exacting requirements on how\n> that namespace is run, both in terms of the URIs and potentially what\n> happens when you dereference them (based on discussion with @timbl\n> https://github.com/timbl).\n\n+1, i think it is unlikely that IANA's substantial registry \ninfrastructure can be changed easily. and so far i have not heard any \nargument on why you would need the URIs to be dereferencable: they are \nidentifiers, and their semantics are defined by the specs that register \nthem. the registry is there to make those specs discoverable. even if it \nwere possible to dereference the URIs and you would get some RDF as a \nresult, it would do little more than containing a link to spec that \nregistered the value, and effectively say \"go and read this spec\".\n\n> In this approach, a serialisation of links like JSON-LD can use URIs for\n> registered relation types as it wishes, and have appropriate assurances\n> that it controls that name space; much easier than offloading that task\n> to IANA.\n\njust to make sure: the URIs would not actually show up in JSON values, \nright? i assume they would only show up if somebody put on their RDF \ngoggles and processed the JSON as JSON-LD and then looked at the \nresulting RDF? and when serializing RDF as JSON via JSON-LD the opposite \nthing would happen and the URIs would get serialized as the registered \nstrings?\n",
          "createdAt": "2016-05-03T02:50:07Z",
          "updatedAt": "2016-05-03T02:50:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "The lexical value of the type as defined in the standard is not what may appear on the wire, depending upon the transformations that a serialisation applies to it.\n\nTrivial (and common) examples of such a transformation are character encoding, compression and encryption.\n\nThe draft is saying that other transformations are possible, including mapping registered relation types into a separate space, for the convenience of the users of that serialisation. \n\nHow JSON-LD and friends decide to handle this is up to them.\n\nIf you can suggest ways to clarify this in the spec, it'd be much appreciated.\n",
          "createdAt": "2016-05-03T03:09:00Z",
          "updatedAt": "2016-05-03T03:09:00Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-05-02 20:09, Mark Nottingham wrote:\n\n> The lexical value of the type as defined in the standard is not what may\n> appear on the wire, depending upon the transformations that a\n> serialisation applies to it.\n\nagreed, but that is entirely out of scope of the spec, is it not? the \nspec says which lexical value represents a registry entry.\n\n> Trivial (and common) examples of such a transformation are character\n> encoding, compression and encryption.\n\nsure, but these are layered concerns and do not affect the spec.\n\n> The draft is saying that other transformations are possible, including\n> mapping registered relation types into a separate space, for the\n> convenience of the users of that serialisation.\n\ni am still not clear about why that needs to be said. of course if \nthere's agreement on two sides, they can apply whichever transformation \nmakes them happy and as long as the mapping works robust in both ways, \nthings will work out.\n\nwe do not say that a value can be compressed or encrypted or unicode \nencoded, because we don't have to. what's different here?\n\n> If you can suggest ways to clarify this in the spec, it'd be much\n> appreciated.\n\nif we keep the model that registered values have one lexical value which \nis the simple string we have today, then i think there is no need to \ntalk about possible ways to map this string to URIs. it could be mapped \nto many other things as well, as you point out.\n\nmy concern is that this language is confusing readers and developers to \nassume that the URIs _are_ legitimate lexical representations, which \nthey are not. i don't see which value this adds, and i see a risk of \ninviting misunderstandings.\n",
          "createdAt": "2016-05-03T03:29:17Z",
          "updatedAt": "2016-05-03T03:29:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "#142 has a TODO to add a section about creating new serialisations. I think moving this text into that might help.\n",
          "createdAt": "2016-05-03T04:53:30Z",
          "updatedAt": "2016-05-03T04:53:30Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Thanks for finally providing a conclusion on this issue. The more I think about it, the more I agree with you in that it's not up to rfc5988bis to provide mapping to other serialisations of link relations. That can and probably should be solved externally in another RFC or W3C REC.\n",
          "createdAt": "2016-05-03T08:08:00Z",
          "updatedAt": "2016-05-03T08:08:00Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> just to make sure: the URIs would not actually show up in JSON values, right? i assume they would only show up if somebody put on their RDF goggles and processed the JSON as JSON-LD and then looked at the resulting RDF? and when serializing RDF as JSON via JSON-LD the opposite thing would happen and the URIs would get serialized as the registered strings?\n\nJSON - 'application/json'\ndoesn't specify how to use link relations, `\"rel\": \"next\"` can as well mean the name of a cat \n\nJSON-LD - 'application/ld+json' ([plus 3 profiles](https://www.w3.org/TR/json-ld/#iana-considerations))\nHAL - 'application/hal+json'\nJSON API - 'application/vnd.api+json'\nUBER - 'application/vnd.amundsen-uber+json'\nMason - 'application/vnd.mason+json'\nSiren - 'application/vnd.siren+json'\nAll above have some differences in how to serialize link relations, some use relation lexical form in name/key in objects, some as value of `\"rel\":`. In JSON-LD expanded profile they would appear as URIs used as name/key in objects, also sometimes as value in case of reification or n-ary relations. In JSON-LD compacted profile, one could provide `@context` which would alias all URIs denoting link relations to short strings matching their lexical form in IANA registry. I could consider writing a script which would generate such `@context` from IANA page, than one could just add link to it to `\"@context\": []`.\n\n@dret If you would like to continue discussing use of link relations in JSON and JSON-based media types, maybe we could move it to comments of this article: https://dracoblue.net/dev/overview-of-json-hypermedia-link-formats/ ?\n",
          "createdAt": "2016-05-10T14:07:28Z",
          "updatedAt": "2016-05-10T14:10:21Z"
        },
        {
          "author": "sbp",
          "authorAssociation": "NONE",
          "body": "> The more I think about it, the more I agree with you in that it's not up to rfc5988bis to provide mapping to other serialisations of link relations. That can and probably should be solved externally in another RFC or W3C REC.\r\n\r\n@asbjornu Did this ever actually happen?\r\n",
          "createdAt": "2021-07-20T08:54:26Z",
          "updatedAt": "2021-07-20T08:54:26Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@sbp not to my knowledge, no.",
          "createdAt": "2021-07-20T12:53:12Z",
          "updatedAt": "2021-07-20T12:53:12Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "I know of https://www.w3.org/ns/iana/link-relations/relation but to my knowledge it doesn't have any official status. Maybe @csarven has some more information about it.\r\n\r\nPersonally I think that if someone defining new relation wants it to be available as full IRI, they should just use full IRI and don't register short string. With this in mind some kind of directory with common full IRI link relation could be useful complementary reference to make it easier for community to discover existing relations. Some arguments for registering short string are purely for making them known to others. It would be great to have similar option for full IRI relations.",
          "createdAt": "2021-07-20T14:03:33Z",
          "updatedAt": "2021-07-20T14:04:23Z"
        },
        {
          "author": "sbp",
          "authorAssociation": "NONE",
          "body": "@elf-pavlik Thanks. The W3C have a persistence policy at https://www.w3.org/Consortium/Persistence which mentions that everything starting \"`https://www.w3.org/ns/`\" will be carefully maintained. Of course anyone can make and maintain URI aliases for the IANA link relation registry entries. I was just surprised that the IANA would consider it out of scope to do this themselves and create an obviously canonical source, especially since they're already maintaining a CSV version of the registry. Maintaining JSON-LD or N-Triples or something would not be much more work. Certainly not as onerous a task as @mnot seemed to fear it would be!\r\n",
          "createdAt": "2021-07-20T15:33:39Z",
          "updatedAt": "2021-07-20T15:33:39Z"
        },
        {
          "author": "melvincarvalho",
          "authorAssociation": "NONE",
          "body": "There's also:\r\n\r\nhttps://w3id.org/\r\n\r\nSo, after all this time, I'm guessing that IANA doesnt really want to prioritize throwing cycles at this\r\n\r\nI did push for quite a few years for keys to be used as nicely self-describing http URIs, conforming to link data standards\r\n\r\nFrom my experience, I've found that a large chunk (perhaps majority) of developers are content with strings and short names.  My conclusion is that rather than trying to get people to conform to Linked Data, perhaps we should try and make Linked Data conform to real world usage, and allow normal strings as keys, rather than only (http) URIs\r\n\r\nSo, I'll withdraw my previous requests, and if IANA has cycles to address this so much the better",
          "createdAt": "2021-07-20T16:33:29Z",
          "updatedAt": "2021-07-20T16:33:29Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWUxMTE3Mzc3Mzc=",
      "title": "\"semantically equivalent\"",
      "url": "https://github.com/mnot/I-D/issues/141",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "> [the link header field] is semantically equivalent to the &lt;LINK&gt; element in HTML, as well as the atom:link feed-level element in Atom.\n\nNo, it's not; an application has to opt into using the link header field.\n",
      "createdAt": "2015-10-16T01:07:19Z",
      "updatedAt": "2015-10-19T07:33:24Z",
      "closedAt": "2015-10-16T01:08:44Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Even though it is not semantically equivalent, don't you think it's good to at least reference the `<link>` and `atom:link` elements to provide some context? Once the `Link` header is present, it provides very similar semantics to the two `link` elements. How about:\n\n> The Link entity-header field provides a means for serialising one or more links in HTTP headers. When present, it is semantically equivalent to the `<LINK>` element in HTML, as well as the `atom:link` feed-level element in Atom {{RFC4287}}.\n",
          "createdAt": "2015-10-19T06:24:07Z",
          "updatedAt": "2015-10-19T06:24:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "That's just as confusing. The point is that an application (e.g., web browsing with HTML) has to opt into using the Link header; e.g., rel=stylesheet isn't defined for that, so it doesn't work.\n",
          "createdAt": "2015-10-19T06:30:05Z",
          "updatedAt": "2015-10-19T06:30:05Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Good point! I thought \"an application has to opt into using the link header field\" was the only reason the semantics were different, but `rel=\"stylesheet\"` indeed shows that there's more separating them. Perhaps something should be said to that effect, then? I.e. that while the `Link` header looks similar to `<link>` and `atom:link` and even share quite a few `rel` values, they are in fact different?\n",
          "createdAt": "2015-10-19T07:33:24Z",
          "updatedAt": "2015-10-19T07:33:24Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWUxMTE3MzgyNDg=",
      "title": "Clarify \"applications\" and \"serialisations\"",
      "url": "https://github.com/mnot/I-D/issues/142",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "These are core concepts that aren't yet well spelled out.\n",
      "createdAt": "2015-10-16T01:14:47Z",
      "updatedAt": "2016-11-22T07:23:44Z",
      "closedAt": "2016-11-22T07:23:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Still TODO (possibly): \"Defining New [Applications | Serialisations]\"\n",
          "createdAt": "2016-04-26T07:36:07Z",
          "updatedAt": "2016-04-26T07:36:07Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWUxMTE3NDkwNDg=",
      "title": "Error handling on Link headers",
      "url": "https://github.com/mnot/I-D/issues/143",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "- syntax recovery\n- multiple instances of [rel, target attributes]\n",
      "createdAt": "2015-10-16T03:06:07Z",
      "updatedAt": "2016-05-17T07:15:44Z",
      "closedAt": "2016-05-13T02:44:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke - IIRC you have some tests for Link; where are they?\n\n@annevk, any useful references / thoughts?\n",
          "createdAt": "2015-10-27T05:40:29Z",
          "updatedAt": "2015-10-27T05:40:29Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a few tests here: http://greenbytes.de/tech/tc/httplink/, but they do not cover error handling.\n",
          "createdAt": "2015-10-27T06:48:14Z",
          "updatedAt": "2015-10-27T06:48:14Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "No, sorry. Just that it would be good to have this defined.\n",
          "createdAt": "2015-10-28T05:09:53Z",
          "updatedAt": "2015-10-28T05:09:53Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Definitely would be great to have the multiple instances of [rel, target attributes] dealt with. For [LINK/UNLINK](https://tools.ietf.org/html/draft-snell-link-method-12) these would be handled as entirely separate, independent Links so it would be good to have this clearly defined.\n",
          "createdAt": "2015-10-28T17:25:30Z",
          "updatedAt": "2015-10-28T17:25:30Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "As I mention in #170, some guidance on this in the RFC would be excellent. Also, a full test suite (referenced from the RFC) would be **awesome**.\n\n@reschke That looks like a great start. Could this perhaps be morphed into a GitHub repository so it can be forked and contributed to? I've encountered and thought of a few variations that you haven't covered yet.\n",
          "createdAt": "2016-03-21T10:42:50Z",
          "updatedAt": "2016-03-21T10:45:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, I've started a parsing appendix. I think the multiple reps (etc.) issue is already clear in the text now (thanks @asbjornu).\n\n@annevk et al would you please do a quick sanity check on the commit above?\n\nAlso at:\n  http://mnot.github.io/I-D/rfc5988bis/?#parse\n",
          "createdAt": "2016-05-12T04:36:12Z",
          "updatedAt": "2016-05-12T04:36:12Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Looks reasonable, though I suspect in practice browsers probably assume UTF-8 as encoding, or maybe multiple encodings if parsing headers mostly goes in terms of bytes (initially).\n\nYou'll need to define \"whitespace\". Also URLs...\n",
          "createdAt": "2016-05-12T07:13:29Z",
          "updatedAt": "2016-05-12T07:13:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@annevk - thanks, have defined whitespace, will punt on URL for now :)\n\nWRT encoding - firefox appears to assume ISO-8859-1 encoding (at least for title on rel=stylesheet); see:\nhttp://test.mnot.net/foo/\n\nThat's actually based upon the original definition of the title attribute of Link, which used the `quoted-pair` ABNF from 2616 (and predecessors), which referred to the `TEXT` ABNF, which was explicitly 8859-1.\n\nThat kind of sucks; see #180. Closing this (it's been sketched in and we can always open new issues), and moving discussion of encoding over there.\n",
          "createdAt": "2016-05-13T02:44:28Z",
          "updatedAt": "2016-05-13T02:44:28Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I mainly suspect the URL to be UTF-8.\n",
          "createdAt": "2016-05-13T05:58:58Z",
          "updatedAt": "2016-05-13T05:58:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Nope; it appears to assume 8859-1 in the URL too.\n",
          "createdAt": "2016-05-17T06:35:25Z",
          "updatedAt": "2016-05-17T06:35:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Testing a bit more with Location (since only FF honours Link rel=stylesheet), it appears that when non-ascii characters appear in the URL, the bytes are just percent-encoded as is.\n\nE.g., if I send UTF-8 `\u00fc` on the wire in Location, the resulting URL will have `%C3%BC`. If I send ISO-8859-1, it'll be `%FC`. \n\nTested with FF and Chrome.\n",
          "createdAt": "2016-05-17T06:56:19Z",
          "updatedAt": "2016-05-17T06:56:19Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "That makes sense.\n",
          "createdAt": "2016-05-17T07:15:44Z",
          "updatedAt": "2016-05-17T07:15:44Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWUxMTE5MjUwNzM=",
      "title": "Requirements for IANA page",
      "url": "https://github.com/mnot/I-D/issues/144",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Assuming that the final product of the registry is still an IANA page (and it appears that is the case), what requirements should we place upon it? E.g.\n- URL\n- Text at top of page\n- Registry entries\n- URL anchors\n- XML format\n\nI think it's reasonable to assume that IANA will product exactly one non-HTML format, and that will be XML; this is what they do for other registries, and we shouldn't expect a unicorn.\n",
      "createdAt": "2015-10-16T22:49:02Z",
      "updatedAt": "2016-02-19T14:47:51Z",
      "closedAt": "2015-10-29T06:07:59Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i like unicorns! well, maybe we can set an example by being more explicit about whatever they produce. here's my unicorn wishlist:\n- stable and human-readable URI with no extension: http://registry.iana.com/link-relations\n- serving a human-readable document at that URI: http://registry.iana.com/link-relations serves HTML\n- working and discoverable fragment identifiers that are equal to the registered names; those should identify the fragment of the page that contains the name entry: http://registry.iana.com/link-relations#start identifies the fragment that's about the \"start\" link relation type\n- URI linking to the document that requested the registration (preferably to the fragment in there that is the actual registration template, if such a fragment is available and stable): http://registry.iana.com/link-relations#start should link to http://www.w3.org/TR/1999/REC-html401-19991224/types.html#h-6.12 (sadly, \"start\" has no fragment identifier in the HTML spec)\n- link to discussion thread that requested, discussed, and resolved the registration request\n- link to history of registry, in particular when entries get updated and the registration data changes; there should be a complete registry history, sorted by date of substantial changes, and one for each entry, sorted by date\n\nmaybe that's a fancy unicorn. but then again, implementing something like this really isn't that hard, and there is a large variety of solutions out there that would you allow to do it. it does not even has to be any dynamic code and database, all of this is perfectly doable with a bit of structured data and some relatively simple build process. you could easily build it in any language you'd prefer, be it XML, JSON, or RDF (or something else entirely). this could become the blueprint for the many other registries that probably could use a little data management and openness love.\n",
          "createdAt": "2015-10-16T23:08:40Z",
          "updatedAt": "2015-10-16T23:08:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "> stable and human-readable URI with no extension: http://registry.iana.com/link-relations\n\n\ud83d\udc4d\ud83c\udffc\n\n> serving a human-readable document at that URI: http://registry.iana.com/link-relations serves HTML\n\n\ud83d\udc4d\ud83c\udffc\n\n> working and discoverable fragment identifiers that are equal to the registered names; those should identify the fragment of the page that contains the name entry: http://registry.iana.com/link-relations#start identifies the fragment that's about the \"start\" link relation type\n\n\ud83d\udc4d\ud83c\udffc (although some could be tricky, esp. if the more permissive rules in HTML5 are used)\n\n> URI linking to the document that requested the registration (preferably to the fragment in there that is the actual registration template, if such a fragment is available and stable): http://registry.iana.com/link-relations#start should link to http://www.w3.org/TR/1999/REC-html401-19991224/types.html#h-6.12 (sadly, \"start\" has no fragment identifier in the HTML spec)\n\n\ud83d\udc4d\ud83c\udffc\n\n> link to discussion thread that requested, discussed, and resolved the registration request\n\nHmm. How about a link to a way to find that easily (e.g., github search of the issues list)?\n\n> link to history of registry, in particular when entries get updated and the registration data changes; there should be a complete registry history, sorted by date of substantial changes, and one for each entry, sorted by date\n\nI think that follows from the previous.\n",
          "createdAt": "2015-10-16T23:36:52Z",
          "updatedAt": "2015-10-16T23:36:52Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-10-16 13:36, Mark Nottingham wrote:\n\n> ```\n> link to discussion thread that requested, discussed, and resolved\n> the registration request\n> ```\n> \n> Hmm. How about a link to a way to find that easily (e.g., github search\n> of the issues list)?\n\nnot good enough, otherwise people might just add links to google search? \nit should be a link to a managed, persistent archive, with a controlled \ntagging/categorization strategy (email subjects or github issue/PRs \nwould qualify). also, come to think of it, that archive also MUST \nsupport subscription, so that people interested in following ongoing \ndiscussions can subscribe and get notified.\n\n> ```\n> link to history of registry, in particular when entries get updated\n> and the registration data changes; there should be a complete\n> registry history, sorted by date of substantial changes, and one for\n> each entry, sorted by date\n> ```\n> \n> I think that follows from the previous.\n\ni don't think so. for example, \"next\" at some point was RFC 5005, and \nfor some (surprising) reason now is listed as HTML5. afaict, the RFC \n5005 history and discussion is completely lost in the current registry. \nwhat i'd like to see is:\n- have a way to find out that \"next\" at some point was registered by RFC \n  5005.\n- have a way to find the discussion that was held when RFC 5005 was \n  registering \"next\". that is probably a different \"thread id\" or PR than \n  that of the later HTML5 \"next\" discussion.\n",
          "createdAt": "2015-10-17T00:50:20Z",
          "updatedAt": "2015-10-17T00:50:20Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe some interesting data points from these long-running experiments of mine... i have tracked three (REST-relevant) registered concepts, which are link relation types, HTTP headers, and media types. https://github.com/dret/sedola/tree/master/IETF contains a set of service descriptions for IETF specs. for example, https://github.com/dret/sedola/blob/master/IETF/RFC/5005.xml represents the concepts registered by RFC 5005. all the service descriptions are then combined into the MD lists at https://github.com/dret/sedola/tree/master/MD, such as https://github.com/dret/sedola/blob/master/MD/linkrels.md for link relation types. this is not a complete solution, but with a bit of extra effort (better tracking and archiving the service descriptions, along with some metadata), this is actually not too far away from being a substantial improvement over IANA's current practice.\nall of this was started as an effort to describe RESTful services. they will usually use existing concepts (such as existing HTTP header fields), and maybe invent some new ones that they need. with a framework like this, it is easy to describe the \"service surface\" in terms of the concepts that a consumer of a specific service needs to understand in order to understand the service itself. using this model for describing \"just\" specifications is a nice side-effect of the larger goal of describing any kind of service.\n",
          "createdAt": "2015-10-17T06:28:26Z",
          "updatedAt": "2015-10-17T06:28:26Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> Assuming that the final product of the registry is still an IANA page (and it appears that is the case), what requirements should we place upon it? E.g.\n> \n> URL\n> Text at top of page\n> Registry entries\n> URL anchors\n> XML format\n\n@mnot since all the relations will still stay _describedby_ a single page, I think answer to your question https://github.com/mnot/I-D/issues/140#issuecomment-148592859 may suggest _URL + '(/)#'_ as prefix with relations themselves used as _URL anchors_\n\n@timbl @kidehen maybe you could offer your expertise on this issue?\n\n> I think it's reasonable to assume that IANA will product exactly one non-HTML format, and that will be XML; this is what they do for other registries, and we shouldn't expect a unicorn..\n\nMaybe this canonical 'text/html' page hosted by IANA could include link rel=\"alternate\" to other pages which _describe_ those relations in 'text/turtle', 'application/ld+json', 'application/rdf+xml'. Possibly hosted in http://www.w3.org/ or https://w3id.org/ namespaces and automatically generated from 'text/xml' page provided by IANA (possibly using [GRDDL](http://www.w3.org/TR/grddl/)?)\n\n@gkellogg @iherman would that address your needs captured in https://github.com/w3c/csvw/issues/297 ?\n",
          "createdAt": "2015-10-18T09:18:12Z",
          "updatedAt": "2015-10-18T09:22:15Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot wrote:\n\n> I think it's reasonable to assume that IANA will product exactly one non-HTML format, and that will be XML; this is what they do for other registries, and we shouldn't expect a unicorn.\n\nCould you please provide a link to a discussion that has lead to the (repeated) conclusion that IANA and IETF should not host HTML documents? I'm completely unable to fathom the decision and would love some reasoning.\n\n@elf-pavlik wrote:\n\n> Maybe this canonical 'text/html' page hosted by IANA could include link rel=\"alternate\" to other pages which describe those relations in 'text/turtle', 'application/ld+json', 'application/rdf+xml'. Possibly hosted in http://www.w3.org/ or https://w3id.org/ namespaces and automatically generated from 'text/xml' page provided by IANA (possibly using GRDDL?)\n\nThat would solve a lot of problems, but as I understand @mnot, there won't be a canonical `text/html` representation hosted by IANA; it will be in XML or `text/plain`. I guess the XML document can borrow `atom:link` and use `rel=\"alternate\"` to reference other representations, but the best would be to have **one HTTP resource** that could be retrieved as `application/xml`, `text/html`, `text/turtle`, `application/ld+json`, `application/rdf+xml`, etc.\n\nI understand from the discussion that this is wishing for unicorns, I just don't understand why. Why oh why! :smile:\n\nWhen it comes to the registry requirements, I think @dret nails it.\n",
          "createdAt": "2015-10-19T06:36:02Z",
          "updatedAt": "2015-10-19T06:36:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@asbjornu read again -- they can and do host HTML; I said \"exactly one **non-**HTML format\" :)\n",
          "createdAt": "2015-10-19T06:47:51Z",
          "updatedAt": "2015-10-19T06:47:51Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Aha. Sorry; I probably got it mixed up with XML becoming the normative representation of RFC's, which you wrote elsewhere (on e-mail, I think).\n",
          "createdAt": "2015-10-19T06:53:11Z",
          "updatedAt": "2015-10-19T06:53:11Z"
        },
        {
          "author": "iherman",
          "authorAssociation": "NONE",
          "body": "> On 18 Oct 2015, at 11:18, elf Pavlik notifications@github.com wrote:\n> \n> Assuming that the final product of the registry is still an IANA page (and it appears that is the case), what requirements should we place upon it? E.g.\n> \n> URL\n> Text at top of page\n> Registry entries\n> URL anchors\n> XML format\n> \n> @mnot since all the relations will still stay describedby a single page, I think answer to your question #144 may suggest URL + '(/)#' as prefix with relations themselves used as URL anchors\n> \n> @timbl @kidehen maybe you could offer your expertise on this issue?\n> \n> I think it's reasonable to assume that IANA will product exactly one non-HTML format, and that will be XML; this is what they do for other registries, and we shouldn't expect a unicorn..\n> \n> Maybe this canonical 'text/html' page hosted by IANA could include link rel=\"alternate\" to other pages which describe those relations in 'text/turtle', 'application/ld+json', 'application/rdf+xml'. Possibly hosted in http://www.w3.org/or https://w3id.org/ namespaces and automatically generated from 'text/xml' page provided by IANA\n> \n> @gkellogg @iherman would that address your needs captured in w3c/csvw#297 ?\n> \n> Unfortunately (and this just underlines the urgency of solving this whole issue) the CSVW Working Group had to move on, because we plan to issue a Recommendation at the end of January. Ie, we had to close all technical issues quite some times ago. As a consequence, our only choice was to close that issue by exchanging the only 'rel' like property to a property in our own namespace. Ain't pretty, but there we go.\n\nI also have to add one more comment to the general discussion (I must admit I did not follow it very closely): once everything is closed and finalized, ie, we get to a situation whereby the rel values can be expressed in a `rel:XXX` in an RDFa or JSON-LD CURIE (with a fixed `rel` value), then this `rel` should also be added to the [RDFa initial context](http://www.w3.org/2011/rdfa-context/rdfa-1.1) which would, eventually, be picked up by RDFa and JSON-LD processors, ie, users can use `rel` without an explicit definition. Because, at the moment, I maintain that initial context, you should ping me when it is all set up:-)\n\nCc: @gkellogg\n",
          "createdAt": "2015-10-19T08:40:30Z",
          "updatedAt": "2015-10-19T08:40:30Z"
        },
        {
          "author": "gkellogg",
          "authorAssociation": "NONE",
          "body": "JSON-LD does not use an implicit context, but it will be useful for people to add to their own definitions.\n",
          "createdAt": "2015-10-19T14:17:50Z",
          "updatedAt": "2015-10-19T14:17:50Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "> I also have to add one more comment to the general discussion (I must admit I did not follow it very closely): once everything is closed and finalized, ie, we get to a situation whereby the rel values can be expressed in a `rel:XXX` in an RDFa or JSON-LD CURIE (with a fixed `rel` value), then this `rel` should also be added to the [RDFa initial context](http://www.w3.org/2011/rdfa-context/rdfa-1.1) which would, eventually, be picked up by RDFa and JSON-LD processors, ie, users can use `rel` without an explicit definition. Because, at the moment, I maintain that initial context, you should ping me when it is all set up:-)\n\n@iherman I worry that using CURIE rel:XXX in RDFa may contribute to what @dret to my understanding sees as a concern. [HTML5 4.8 Links](http://www.w3.org/TR/html5/links.html) recommend using link relations without prefix as implicitly mapping to registered link relations, in case of HTML5 spec [delegating it to other than IANA registry](http://www.w3.org/TR/html5/links.html#other-link-types). Preferably let's not reopen this can of worms in this issue and simply move all the eventual conversation about use of link relations in HTML and RDFa elsewhere! (even better F2F during TPAC2015)\n\n@gkellogg I would see useful to publish in an easy to discover way JSON-LD context which will have definitions like `\"describes\": { \"@type\": \"@id\" }` for all the relations. Maybe simple link from IANA page would do?\n`<link rel=\"alternate\" type=\"application/ld+json\" href=\"http://www.w3.org/ns/iana/link\">`\n\nIn general to avoid mentioned by Mark unicorns, I would see it in place that W3C would need to take responsibility for generating and hosting RDF compatible files based on canonical HTML (or XML)  published by IANA and do all the magic by simply including relevant links to \"follow one's nose\" from discussed here canonical page hosted by IANA.\n",
          "createdAt": "2015-10-20T11:22:24Z",
          "updatedAt": "2015-10-20T11:29:32Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "I just noticed that W3C provides namespaces for various HTTP terms\nhttp://www.w3.org/TR/HTTP-in-RDF/#namespaces\n\nAnd hosts documents which describe them in RDF\n",
          "createdAt": "2015-10-24T20:25:34Z",
          "updatedAt": "2015-10-24T20:25:34Z"
        },
        {
          "author": "iherman",
          "authorAssociation": "NONE",
          "body": "> On 25 Oct 2015, at 05:25, elf Pavlik notifications@github.com wrote:\n> \n> I just noticed that W3C provides namespaces for various HTTP terms\n> http://www.w3.org/TR/HTTP-in-RDF/#namespaces http://www.w3.org/TR/HTTP-in-RDF/#namespaces\n> And hosts documents which describe them in RDF\n> \n> Well, yes, but it is just a Working Draft, and I am not sure it will be pursued until a Recommendations.\n",
          "createdAt": "2015-10-24T20:57:32Z",
          "updatedAt": "2015-10-24T20:57:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Discussed with @timbl at TPAC. My inclination is to specify:\n- The Expert(s) will provide the registry data to IANA in a format that's negotiated by them (likely, the current XML).\n- IANA will publish text (including links and other formatting) as directed by the Experts(s) on the HTML of the registry page\n- IANA will generate HTML from that\n- IANA will also publish the canonical format\n- IANA will also publish other formats as requested by the Expert(s)\n- IANA will emit HTTP headers for all of the resources above as requested by the Expert(s)\n",
          "createdAt": "2015-10-27T05:36:15Z",
          "updatedAt": "2015-10-27T05:36:15Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2015-10-27 06:36, Mark Nottingham wrote:\n\n> Discussed with @timbl https://github.com/timbl at TPAC. My inclination\n> is to specify:\n> - The Expert(s) will provide the registry data to IANA in a format\n>   that's negotiated by them (likely, the current XML).\n> - IANA will publish text (including links and other formatting) as\n>   directed by the Experts(s) on the HTML of the registry page\n> - IANA will generate HTML from that\n\nmaybe i am not following this completely. there will be text and then \nHTML generated from that? frankly, i would not care so much about which \nrepresentation the registry page has, as long as:\n- there are working fragment identifiers into this page that effectively \n  give all registry entries stable URI references (the \n  registryURI#registryValue URI reference mentioned earlier).\n- for each registry entry, there is a link to the discussion/thread that \n  led to the creation of that entry.\n\nand ideally, i'd like to add this:\n- there is a registry history that allows people to see which entries \n  where changed and when and why. this does not need to be a complete \n  history, but some record of what happened would be great.\n\nas mentioned earlier, \nhttps://github.com/dret/sedola/blob/master/MD/linkrels.md is one example \nof how this could look like (but it does not have the fragment \nidentifiers because MD does not support them, so this would nee to be \nadded).\n\nhttps://github.com/dret/sedola/commits/master/MD/linkrels.md is (sort of \na) history and i'd like to make that a little prettier than just a \ngeneric github commit log, but at least there is an open record of when \nand how values were changed.\n",
          "createdAt": "2015-10-27T08:40:02Z",
          "updatedAt": "2015-10-27T08:40:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See above. Re: discussion and history, that'll be a separate thing.\n",
          "createdAt": "2015-10-29T06:07:59Z",
          "updatedAt": "2015-10-29T06:07:59Z"
        },
        {
          "author": "timbl",
          "authorAssociation": "NONE",
          "body": "\"I think it's reasonable to assume that IANA will product exactly one non-HTML format, and that will be XML; this is what they do for other registries, and we shouldn't expect a unicorn.\"\nIANA took a look time to move to HTML and is still clearly suspicious of it.   We still have an obligation to lead them into more powerful formats, as in text > HTML and XML > turtle.  \nPlus, when this stuff is used by the RDF community to not have the properties we use dereferenceable  on the web suggests we use use full URI which is in a domain where the rdf community can make sure that it works.   Or we can hack every single client code to have a magic redirect from the iana namespace to another domain under the covers.\n",
          "createdAt": "2016-02-05T16:53:38Z",
          "updatedAt": "2016-02-05T16:53:38Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-02-05 08:53, Tim Berners-Lee wrote:\n\n> Plus, when this stuff is used by the RDF community to not have the\n> properties we use dereferenceable on the web suggests we use use full\n> URI which is in a domain where the rdf community can make sure that it\n> works. Or we can hack every single client code to have a magic redirect\n> from the iana namespace to another domain under the covers.\n\nthe thing is that rather few registries have namespaces that are or even \ncould be URIs. and like @mnot mentioned, we shouldn't expect a unicorn.\n\nmany registries have namespaces that cannot be URIs even if you wanted \nbecause their context requires them to be 16bit numbers or something \nsimilarly constrained.\n\ni am working on a draft looking at the use of registries from many \npossible angles, and the identifier namespace of course is an important one.\n\nhttps://tools.ietf.org/html/draft-wilde-registries-01#section-3.4\n\nso while i think it is impossible to strive for IANA registries to \n_always use_ URIs as registered values (it would be interesting to know \nhow many of the existing 1'903 registries at least in theory could use \nURIs as their namespace), it may make sense to say that the registry \nentries should _have URIs_, thus making it possible to link to a \nregistry entry when referring to it.\n\nthis would require some management effort in order to assign and use \nlocal identifiers for each submitted value. it's not hard to do, but it \nneeds to be done and implemented robustly. also, registry users must be \neducated to understand the difference between a value's URI, and the \nactual value.\n\nfor example, it is clear that TCP port 80 never can be changed as a \nregistered value to _be_ a URI. but it would be useful for it to be \nbetter referencable on the web than having to manually page to this URI \nto find the value:\n\nhttp://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?&page=2\n\ninstead, it would be possible to either use the value as part of the URI \n(but this would be brittle and may break as a scheme if there are \nregistries keeping history and doing reassignments), or to simply assign \nrandom \"entry keys\" and keep those stable.\n\nfor example, the following entry key could be used as a stable link to \nthe port 80 entry:\n\nhttp://www.iana.org/assignments/service-names-port-numbers#2387642\n\nbut this would very likely require a change to RFC 7500, which of course \nis a much bigger effort than revising RFC 5988.\n",
          "createdAt": "2016-02-05T17:15:43Z",
          "updatedAt": "2016-02-05T17:15:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "From my chats with IANA staff, I think they'd consider hosting other formats, providing they were clearly specified and either produced for them, or reasonable for them to produce (e.g., with an XSLT transform). \n\nWould need to confirm this, of course, but if we had a proposal we could take it to them. One of the questions they'll ask is how much traffic we'd expect such things to get.\n",
          "createdAt": "2016-02-06T01:32:33Z",
          "updatedAt": "2016-02-06T01:32:33Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-02-05 17:32, Mark Nottingham wrote:\n\n> Would need to confirm this, of course, but if we had a proposal we could\n> take it to them. One of the questions they'll ask is how much traffic\n> we'd expect such things to get.\n\nhttps://tools.ietf.org/html/draft-wilde-registries-01#section-5.6 tries \nto address this issue. if the model is that any implementation can and \nwill get registry contents at runtime, then this can be very hard to \nscale up. currently, the pattern is that _developers_ look at the \nregistry, not their code at runtime. that's a very different thing.\n",
          "createdAt": "2016-02-06T04:22:09Z",
          "updatedAt": "2016-02-06T04:22:09Z"
        },
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": "maybe schema.org crew has some experience here to share? in mailing list conversation below @danbri @mfhepp @gkellogg and others discuss this issue, even referencing post about W3C\u2019s Excessive DTD Traffic\n- https://lists.w3.org/Archives/Public/public-vocabs/2014Jan/0035.html\n- https://www.w3.org/blog/systeam/2008/02/08/w3c_s_excessive_dtd_traffic/\n",
          "createdAt": "2016-02-19T02:00:04Z",
          "updatedAt": "2016-02-19T02:00:04Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@elf-pavlik Your comment seems related to dret/I-D#21 and not so much this discussion. :) But yea, [schema.org](http://schema.org/) should have plenty of experience to share.\n",
          "createdAt": "2016-02-19T08:12:15Z",
          "updatedAt": "2016-02-19T08:12:15Z"
        },
        {
          "author": "danbri",
          "authorAssociation": "NONE",
          "body": "I would like to investigate the load on schema.org, however I didn't yet figure out whether Google AppEngine's generic logging can easily tell us about homepage requests that ask for application/ld+json. Expert advice on that would be welcomed; if nobody here happens to know I can ask around within Google of course, or even(!) revisit the documentation. Presumably there are probably also custom logging python APIs in appengine. /cc @RichardWallis\n",
          "createdAt": "2016-02-19T13:14:09Z",
          "updatedAt": "2016-02-19T13:14:09Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-02-19 14:14, Dan Brickley wrote:\n\n> I would like to investigate the load on schema.org, however I didn't yet\n> figure out whether Google AppEngine's generic logging can easily tell us\n> about homepage requests that ask for application/ld+json. Expert advice\n> on that would be welcomed; if nobody here happens to know I can ask\n> around within Google of course, or even(!) revisit the documentation.\n> Presumably there are probably also custom logging python APIs in\n> appengine. /cc @RichardWallis https://github.com/RichardWallis\n\nit definitely would be great to hear more about what is happening and \nhow much load it is.\n\nin this case it hit a company that has among the world's best people and \ncomputing/network resources to handle this. it all depends on how a \nspec, its vocabulary, and the registry are supposed to be used. i still \nthink that in most cases, the general model is that runtime access is a \nBad Idea, and for whoever is hosting the registry, this can make a big \ndifference. definitely something to keep in mind when considering how to \nsplit a spec into static and evolvable parts.\n\nhttps://tools.ietf.org/html/draft-wilde-registries-01#section-5.5\n",
          "createdAt": "2016-02-19T14:13:51Z",
          "updatedAt": "2016-02-19T14:13:51Z"
        },
        {
          "author": "gkellogg",
          "authorAssociation": "NONE",
          "body": "We discussed this some time ago. I believe the best practice for an implementation is to cache retrieved contexts and reuse between successive requests. Ideally, the context is served with reasonable cache control directives. The Ruby JSON-LD processor does runtime caching of retrieved contexts.\n",
          "createdAt": "2016-02-19T14:47:51Z",
          "updatedAt": "2016-02-19T14:47:51Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWUxMTE5ODY1NzA=",
      "title": "Avoid clashing of URI relation types, and the \"pseudo URIs\" for registered types",
      "url": "https://github.com/mnot/I-D/issues/145",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "depending on what #140 proposes as the prefix to \"URIfy\" registered strings, maybe the section on URIs as \"non-registered relation types\" should mention that prefix explicitly and state than extension types MUST NOT use that prefix? if that sounds reasonable, i could add something to that effect.\n",
      "createdAt": "2015-10-17T21:42:38Z",
      "updatedAt": "2016-05-10T05:53:57Z",
      "closedAt": "2016-05-10T05:53:57Z",
      "comments": [
        {
          "author": "elf-pavlik",
          "authorAssociation": "NONE",
          "body": ":+1:\nIt could also recommend to either reuse exiting URIs, which one can find in aggregation services like http://lov.okfn.org/dataset/lov/terms?&type=property or offer guidance on how to choose appropriate namespace for defining a new URI e.g. for HTTP URIs a domain name under one's own control.\n",
          "createdAt": "2015-10-17T21:47:22Z",
          "updatedAt": "2015-10-18T11:03:28Z"
        },
        {
          "author": "dschulten",
          "authorAssociation": "NONE",
          "body": "+1 \n",
          "createdAt": "2015-10-18T10:46:13Z",
          "updatedAt": "2015-10-18T10:46:13Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Yes. Something like this:\n1. Registered strings **must not** be prefixed in environments where they are recognized (such as `text/html`, `Link` headers and `application/atom+xml`)\n2. Registered strings **should** be prefixed in environments where they are not recognized (such as RDFa, JSON-LD, etc.)\n\nThe list should probably be longer, but it's a start.\n",
          "createdAt": "2015-10-27T12:57:04Z",
          "updatedAt": "2015-10-27T12:57:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing, based upon the changes above. \n",
          "createdAt": "2016-05-03T01:06:22Z",
          "updatedAt": "2016-05-03T01:06:22Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i commented on the commit, it seems to be at odds with the current state of #140.\n",
          "createdAt": "2016-05-03T02:27:38Z",
          "updatedAt": "2016-05-03T02:27:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Would removing the \"These URIs also...\" sentence work for everyone? \n",
          "createdAt": "2016-05-03T02:44:27Z",
          "updatedAt": "2016-05-03T02:44:27Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "works for me. since i opened this issue: this was meant as a clean-up item in case there was a change to the spec turning registered strings into URIs, or allowed URIs as aliases. afaict, that's currently not the case, and thus this issue does not apply (yet).\n",
          "createdAt": "2016-05-03T02:56:24Z",
          "updatedAt": "2016-05-03T02:56:24Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot Works for me. :+1: \n",
          "createdAt": "2016-05-03T08:11:41Z",
          "updatedAt": "2016-05-03T08:11:41Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWUxMTMyMTUxNjk=",
      "title": "XML Namespace URI",
      "url": "https://github.com/mnot/I-D/issues/147",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "the current \"JSON Problem\" draft uses a URN as XML namespace URI, based on what http://tools.ietf.org/html/rfc2648 suggests. now that http://tools.ietf.org/html/rfc7669 has been published, would it be better to use a DOI (in its URI form) instead? sadly, RFC 7669 does not say anything about RFC 2648, but maybe the newer convention should be preferred? afaict, it does not make a big difference because all this has to be is a well-known identifier, but if there's a preference for the newer convention, maybe make that change before the document gets finalized.\n",
      "createdAt": "2015-10-25T09:21:02Z",
      "updatedAt": "2015-11-03T13:54:16Z",
      "closedAt": "2015-11-03T13:22:33Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "A HTTP URL as namespace URI would be highly appreciated! :smile: \n",
          "createdAt": "2015-10-27T08:30:15Z",
          "updatedAt": "2015-10-27T08:30:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Seems like way too late to do this, given that other folks are depending on this doc.\n",
          "createdAt": "2015-11-03T12:33:38Z",
          "updatedAt": "2015-11-03T12:33:38Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot, Is it illegal for an RFC to use a different naming scheme than those defined in RFC 2648 and 7669? Even though RFC 4287 came after 2648, it uses a resolvable HTTP URL (hosted by W3C), and not `urn:ietf:rfc:4287`.\n\nI understand that it's too late to do anything about RFC 7669, but since JSON Problem is not a published RFC yet, it's not too late to change its namespace URI, is it? If it can be changed, is it possible to change it to something not described by RFC 2648 or 7669?\n",
          "createdAt": "2015-11-03T12:41:58Z",
          "updatedAt": "2015-11-03T12:41:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "_sigh_ If this had come up a few months ago, sure, but there's already WG consensus and it's going to the IESG. You can bring this up in IETF Last Call, but I'd argue that the slight benefits of a HTTP URL are easily outweighed by breaking the people already using it.\n",
          "createdAt": "2015-11-03T12:54:57Z",
          "updatedAt": "2015-11-03T12:54:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, i just wanted to bring up the point that the RFC 2648 naming scheme seems to be replaced by RFC 7669, but since it's not quite clear how, and since the namespace URI has been around for quite a while, it may be best to just keep it. closing the issue.\n",
          "createdAt": "2015-11-03T13:22:33Z",
          "updatedAt": "2015-11-03T13:22:33Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot, @dret: Okay. Can anything be done about this for future RFC's, then? Or will RFC 7669 mandate that any namespace URI being minted for any RFC \"forever\" _must not_ be a resolvable URL? I find it peculiar that IETF has moved in this direction and in 2015 specifies a new namespace scheme that is still not based on resolvable HTTP URLs. It creates a lot of dead-ends that are incompatible with linked data, which end up causing a lot of duplicated effort. Can anything be done to remedy this?\n",
          "createdAt": "2015-11-03T13:54:16Z",
          "updatedAt": "2015-11-03T13:54:16Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "MDU6SXNzdWUxMTM0OTUwMDk=",
      "title": "Positive / negative rights",
      "url": "https://github.com/mnot/I-D/issues/148",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "As per andrew s -- positive rights don't make sense, in that you can't guarantee internet access, unmolested transit (e.g., content blocking, firewalling), etc.\n\nMake it more clear that permission-less innovation is a key feature of the internet and negative right.\n",
      "createdAt": "2015-10-27T02:51:04Z",
      "updatedAt": "2016-12-25T17:56:10Z",
      "closedAt": "2016-12-25T17:56:10Z",
      "comments": []
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWUxMTM0OTUwMzI=",
      "title": "OPES",
      "url": "https://github.com/mnot/I-D/issues/149",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "good example of damage we're trying to avoid.\n",
      "createdAt": "2015-10-27T02:51:19Z",
      "updatedAt": "2016-11-23T10:54:53Z",
      "closedAt": "2016-11-23T10:54:53Z",
      "comments": []
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWUxMTQ1OTM3MzU=",
      "title": "More repositories, please",
      "url": "https://github.com/mnot/I-D/issues/150",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sorry about this, but I just want to raise this to make it a bit easier to collaborate on the pretty large amounts of RFC's you've contributed to, @mnot. Since there are a lot of RFC's and increasing interest in them, there's now quite a bit of activity in issues, discussions and pull requests that are mostly completely unrelated.\n\nEven though it involves a bit of work, I think it would be wise to separate each RFC into its own repository, so they get their own revision history, their own related issues, pull requests, etc. Although that means each repository becomes very small, it will make everything a bit more organized and easier to follow. Perhaps not so much for you, but at least for everyone else who might not be interested in all of the ongoing I-D work, but just in that of a few specific RFC's.\n\nIn order to separate the repositories, you can quite easily [move a subdirectory of your current repository into a new repository](https://help.github.com/articles/splitting-a-subfolder-out-into-a-new-repository/) and then [move all related issues to the new repository](https://github.com/google/github-issue-mover). I'd love to help you out, so please let me know if you think this is a good idea or not and whether you'd like help doing it.\n",
      "createdAt": "2015-11-02T13:30:05Z",
      "updatedAt": "2015-11-03T12:36:43Z",
      "closedAt": "2015-11-03T12:28:15Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i am interested to see what @mnot thinks about this...\n",
          "createdAt": "2015-11-03T09:40:06Z",
          "updatedAt": "2015-11-03T09:40:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think that I'm not a standards body, and people shouldn't give too much weight to what I do here; these are all proto-specs. Administratively, it's MUCH easier for me to have these all in one repo.\n\nThat said, if 5988bis (or any other spec) is adopted somewhere, I'll be happy to split it off (assuming the work stays in my repo and doesn't move elsewhere anyway).\n",
          "createdAt": "2015-11-03T12:28:15Z",
          "updatedAt": "2015-11-03T12:28:15Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> I think that I'm not a standards body\n\nYou're too humble! ;-)\n\n> and people shouldn't give too much weight to what I do here; these are all proto-specs. Administratively, it's MUCH easier for me to have these all in one repo.\n\nI understand. Okay, then. Moving on. :-)\n",
          "createdAt": "2015-11-03T12:36:43Z",
          "updatedAt": "2015-11-03T12:36:43Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWUxMTUyMDc5ODE=",
      "title": "IANA interaction",
      "url": "https://github.com/mnot/I-D/issues/151",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "I talked with Michelle Cotton from IANA at IETF94. \n\nOne issue that came up was integration with their workflow; they often update registry contents (e.g., when a document's status changes, such as when an RFC goes from `draft` to `published`).\n\nWe need to figure out a way to minimise extra work and avoid errors; this might mean keeping the \"source of truth\" at IANA, or splitting the sources into RFC-sourced entries and those from elsewhere.\n",
      "createdAt": "2015-11-05T04:38:00Z",
      "updatedAt": "2016-05-13T02:25:02Z",
      "closedAt": "2016-05-13T02:25:02Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Probably best to discuss this once it's actually in IETF process formally; closing for now.\n",
          "createdAt": "2016-05-13T02:25:02Z",
          "updatedAt": "2016-05-13T02:25:02Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWUxMTUzNDA5MDA=",
      "title": "Remove/Deprecate \"Link Relation Application Data Registry\"",
      "url": "https://github.com/mnot/I-D/issues/152",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "http://tools.ietf.org/html/rfc5988#section-6.3 defines a \"Link Relation Application Data Registry\", which never caught on. http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-2 has zero entries, and a successor of RFC 5988 probably should take note and either get rid of the registry altogether (if that's even possible), or mention that this one never saw adoption (and maybe also suggest that new registrations shouldn't be made).\n",
      "createdAt": "2015-11-05T18:08:10Z",
      "updatedAt": "2017-02-24T06:02:45Z",
      "closedAt": "2015-11-06T07:22:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Dup of #37.\n",
          "createdAt": "2015-11-06T07:22:34Z",
          "updatedAt": "2015-11-06T07:22:34Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "searched the issues beforehand but did not find #37, and yes, this here is a duplicate.\n",
          "createdAt": "2015-11-06T07:54:05Z",
          "updatedAt": "2015-11-06T07:54:05Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWUxMTkxMzQzMTU=",
      "title": "Invariants",
      "url": "https://github.com/mnot/I-D/issues/155",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "http://www.internetsociety.org/internet-invariants-what-really-matters\n",
      "createdAt": "2015-11-27T05:35:19Z",
      "updatedAt": "2016-11-13T13:05:39Z",
      "closedAt": "2016-11-13T13:05:39Z",
      "comments": []
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWUxMTk2ODIyNzQ=",
      "title": "incomplete media type registration templates",
      "url": "https://github.com/mnot/I-D/issues/161",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "Minor nit: the media type registration templates miss a few fields defined in https://tools.ietf.org/html/rfc6838#section-5.6.\n",
      "createdAt": "2015-12-01T09:59:07Z",
      "updatedAt": "2015-12-01T20:25:52Z",
      "closedAt": "2015-12-01T20:25:52Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": " Fixed in 4ec8142\n",
          "createdAt": "2015-12-01T20:25:52Z",
          "updatedAt": "2015-12-01T20:25:52Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "MDU6SXNzdWUxMTk4NzUyMjk=",
      "title": "Expert decisions",
      "url": "https://github.com/mnot/I-D/issues/163",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Assuming that the experts remain, how they interact with IANA needs to be clarified to indicate whether there needs to be consensus among the experts, or whether first answer is sufficient.\n",
      "createdAt": "2015-12-02T06:22:40Z",
      "updatedAt": "2016-04-26T06:58:03Z",
      "closedAt": "2016-04-26T06:58:03Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "given the history of expert feedback, at least having some time-out might be advisable. it seemed often that the biggest bottleneck of the registration isn't the process itself, but the sometimes long delays to get through it.\n",
          "createdAt": "2016-01-13T22:17:56Z",
          "updatedAt": "2016-01-13T22:17:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Talking to Michelle C, this seems like something that the experts and ICANN can work out in the background, no need to specify it up-front.\n",
          "createdAt": "2016-04-26T06:58:03Z",
          "updatedAt": "2016-04-26T06:58:03Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "MDU6SXNzdWUxNDEyMjMwMDY=",
      "title": "Duplicate links",
      "url": "https://github.com/mnot/I-D/issues/170",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "I can't find the word \"duplicate\" or any variation thereof in RFC 5899 explaining how to handle duplicate links and what should be considered duplicate links. If two links have the same `rel` value, but different target URIs, should both be considered \"valid\" and if so, how should a client find the correct one between the two?\n\nIf the two links have `type`, `title` or other parameters that distinguish them, then that helps, but since these parameters are optional, I'd appreciate some explanation on what to do when the links have duplicate `rel` values.\n\nSeen from an implementation perspective, you'd be likely to choose a dictionary where the `rel` value in some form or another is used as a lookup key, returning one or more links with a matching `rel` parameter. Should the implementation of RFC 5899 not care about duplicates, leaving that problem up to the client application or user, or should duplicates be handled in some prescribed, algorithmic way?\n",
      "createdAt": "2016-03-16T09:57:14Z",
      "updatedAt": "2016-05-03T15:31:43Z",
      "closedAt": "2016-05-03T00:58:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "In Section 3 of 5988:\n\n> This specification does not place restrictions on the cardinality of links; there can be multiple links to and from a particular IRI, and multiple links of different types between two given IRIs.  Likewise, the relative ordering of links in any particular serialisation, or between serialisations (e.g., the Link header and in-content links) is not specified or significant in this specification; applications that wish to consider ordering significant can do so.\n\nThe current draft makes a slight change to this (relevant part **bolded**):\n\n> This specification does not place restrictions on the cardinality of links; there can be multiple links to and from a particular target, and multiple links of **the same or** different types between a given context and target. Likewise, the relative ordering of links in any particular serialisation, or between serialisations (e.g., the Link header and in-content links) is not specified or significant in this specification; applications that wish to consider ordering significant can do so.\n",
          "createdAt": "2016-03-16T23:58:17Z",
          "updatedAt": "2016-03-16T23:58:17Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "As an implementor, I'm still confused on how to treat duplicate links, parameters, etc. Is this specified in another RFC and if so, shouldn't RFC 5899 reference it? When parsing the following link, what should I do?\n\n```\nLink: </up-or-first>; rel=\"up\"; rel=\"first\"\n```\n\nWhat's the link relation here, `up` or `first`? And how about the following:\n\n```\nLink: </up>; rel=\"up\", </up.html>; rel=\"up\"\n```\n\nWhich link should be considered to be authoritative for the `up` relation? Should the RFC say anything about this, or at least that a `type` parameter `SHOULD` be added given such duplication, to give the client a way of differentiating the two links from each other?\n",
          "createdAt": "2016-03-17T09:03:10Z",
          "updatedAt": "2016-03-17T09:13:14Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot After reading the RFC a bit more closely, I've now found a few sections making it clearer what to do with duplicate parameters:\n\nSection 5.3 states:\n\n> The \"rel\" parameter MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.\n\nSection 5.4 states:\n\n> The \"title\" parameter MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.\n\nSection 5.4 states:\n\n> There MUST NOT be more than one type parameter in a link-value.\n\nI think the last section here relating to `type` could be made clearer as the others on what to do. For consistency, I suggest that the section be changed to:\n\n> The \"type\" parameter MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.\n\nSo now I'm only wondering about what to do about duplicate `link-value`s in the header. Although the specification states that it places no restriction on the cardinality of links, it's hard to know what to do when parsing a header and finding several that semantically are equal.\n\nIf a link is equal to another down to the octet, should it be added or ignored?\n",
          "createdAt": "2016-03-18T09:43:57Z",
          "updatedAt": "2016-03-18T09:43:57Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "What should be done with parameters not defined in RFC 5899? Are they at all allowed and if they are, what should be done with duplicates?\n",
          "createdAt": "2016-03-18T10:36:56Z",
          "updatedAt": "2016-03-18T10:36:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "> If a link is equal to another down to the octet, should it be added or ignored?\n\nDo you mean a link that has the same target, context, relation type and attributes? \n\nI think it's _probably_ safe to fold those into one, unless the application is something like \"counting links\" -- after all, an HTML page can (and often does) have duplicate links.\n\nFrom an abstract library standpoint, it's probably safer to leave them separate.\n\nWRT parameters -- assuming you're talking about target attributes more generally, they are allowed, and duplicates can occur. Unless the defining party (typically either the rel type or the application) says they can't.\n",
          "createdAt": "2016-03-19T04:54:42Z",
          "updatedAt": "2016-03-19T04:54:42Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> Do you mean a link that has the same target, context, relation type and attributes?\n\nYep.\n\n> I think it's probably safe to fold those into one, unless the application is something like \"counting links\" -- after all, an HTML page can (and often does) have duplicate links.\n\nTrue, but an HTML page also has a lot of more context than an HTTP `Link` header, especially if you're talking about the `a` element.\n\n> From an abstract library standpoint, it's probably safer to leave them separate.\n\nShould the RFC state anything in this regard, so libraries have the same behavior? Personally, I find it a bit silly to keep all of the following links separate:\n\n``` http\nLink: </alternate>; rel=\"alternate\",\n      </alternate>; rel=\"AlterNate\",\n      </alternate>; rel=\"ALTERNATE\",\n      </alternate>; rel=\"alternate\",\n      </alternate>; rel=\"http://www.iana.org/assignments/relation/alternate\"\n```\n\nSemantically, they're all **exactly** the same, according to the RFC, unless I've misunderstood something. Seeing how `rel` is a natural key on which to look up links, it makes the example above difficult to handle if the links are to be kept separate.\n\n> WRT parameters -- assuming you're talking about target attributes more generally, they are allowed, and duplicates can occur. Unless the defining party (typically either the rel type or the application) says they can't.\n\nRight. Does the RFC say anything about this already? Since the RFC is explicit about `type`, `rel`, etc. not being duplicate, it's natural (to me, anyways) to treat all parameters the same and add them as non-duplicate in a hashtable (dictionary). That this may lead to an invalid implementation should perhaps somehow be mentioned in the RFC? If it already is, I'd love a pointer to the relevant paragraph.\n",
          "createdAt": "2016-03-21T10:41:18Z",
          "updatedAt": "2016-03-21T10:41:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing based upon changes above; if they aren't enough / right / clear, please reopen.\n",
          "createdAt": "2016-05-03T00:58:10Z",
          "updatedAt": "2016-05-03T00:58:10Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot I think this is a clear improvement. If we can get some traction on #143 as well, implementers would have a much easier job. Thanks!\n",
          "createdAt": "2016-05-03T15:31:43Z",
          "updatedAt": "2016-05-03T15:31:43Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWUxNDcyMzE0MzY=",
      "title": "link attribute registry",
      "url": "https://github.com/mnot/I-D/issues/171",
      "state": "CLOSED",
      "author": "darshakthakore",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "The use of web-linking has expanded a lot since RFC5988, specifically its usage in CoRE and other IoT ecosystems. For example, [RFC 6690](http://tools.ietf.org/html/rfc6690) adds new attributes ('rt', 'if', 'sz'), [RFC 7641](http://tools.ietf.org/html/rfc7641) adds the 'obs' attribute and various other drafts are adding additional attributes. Seems like a link attribute registry would be useful for ensuring there are no accidental name collisions and also for a place to look for what's already defined.\n",
      "createdAt": "2016-04-10T14:56:07Z",
      "updatedAt": "2016-04-26T07:27:21Z",
      "closedAt": "2016-04-26T07:27:21Z",
      "comments": [
        {
          "author": "darshakthakore",
          "authorAssociation": "NONE",
          "body": "this issue should be labeled rfc5988bis\n",
          "createdAt": "2016-04-10T14:58:37Z",
          "updatedAt": "2016-04-10T14:58:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Dup of #36, I think.\n",
          "createdAt": "2016-04-26T07:27:21Z",
          "updatedAt": "2016-04-26T07:27:21Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWUxNDczNDgwMzI=",
      "title": "content-type with \"+ convention\"",
      "url": "https://github.com/mnot/I-D/issues/172",
      "state": "OPEN",
      "author": "RubenVerborgh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "I would have expected `application/home+json` in line with the \"+ convention\".\n",
      "createdAt": "2016-04-11T08:08:06Z",
      "updatedAt": "2017-10-10T13:50:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "That would also be more in line with [RFC 7807](https://tools.ietf.org/html/rfc7807)'s `application/problem+json`.\n",
          "createdAt": "2016-04-11T11:22:12Z",
          "updatedAt": "2016-04-11T11:22:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Yes. I've intentionally not registered the media type because I want the flexibility to change the format when it's more baked.\n",
          "createdAt": "2016-05-03T06:09:25Z",
          "updatedAt": "2016-05-03T06:09:25Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "as one additional data point: https://tools.ietf.org/html/draft-wilde-home-xml-03#section-4.1 defines `application/problem+xml` assuming that the structured syntax suffix is a useful pattern to follow.",
          "createdAt": "2017-10-10T13:38:33Z",
          "updatedAt": "2017-10-10T13:38:33Z"
        },
        {
          "author": "RubenVerborgh",
          "authorAssociation": "NONE",
          "body": "Seems like it's time to turn this convention into an officially meaningful thing.",
          "createdAt": "2017-10-10T13:39:32Z",
          "updatedAt": "2017-10-10T13:39:32Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@RubenVerborgh: it is an RFC (https://tools.ietf.org/html/rfc6838), but media types are free to follow or ignore this pattern.",
          "createdAt": "2017-10-10T13:50:35Z",
          "updatedAt": "2017-10-10T13:50:35Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "MDU6SXNzdWUxNDczNDg0NTA=",
      "title": "\"param\" instead of \"var\"",
      "url": "https://github.com/mnot/I-D/issues/173",
      "state": "CLOSED",
      "author": "RubenVerborgh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "In related specifications, in particular RFC6570, the term \"parameter\" (`param`) is used for components of a URI.\n",
      "createdAt": "2016-04-11T08:09:33Z",
      "updatedAt": "2016-11-23T06:34:56Z",
      "closedAt": "2016-11-23T06:34:56Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "6570 uses `parameter` most often to talk about syntactic constructs in URIs; `variable` is used to talk about the input to templates, which is what's happening here.\n",
          "createdAt": "2016-05-26T02:53:50Z",
          "updatedAt": "2016-05-26T02:53:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing; if I've misused these terms somewhere (keeping the above in mind), please reopen or open a new one. Thanks.",
          "createdAt": "2016-11-23T06:34:56Z",
          "updatedAt": "2016-11-23T06:34:56Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWUxNDgzMzg1NDY=",
      "title": "Relation to Webapp Manifest",
      "url": "https://github.com/mnot/I-D/issues/174",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "for the home documents spec, it would be interesting to at least discuss its relation to webapp manifests as specified over at https://github.com/w3c/manifest. there is an extension point in that spec that would allow new properties to be added in a graceful way. if that spec would establish a registry of some kind, these properties could even be established by a different spec and made well-known by registering them. it might be interesting to see what the difference would be between the home document draft as it is now, and a model it would be recast as a webapp manifest with some extension properties.\n",
      "createdAt": "2016-04-14T11:59:02Z",
      "updatedAt": "2016-05-26T09:27:29Z",
      "closedAt": "2016-05-26T09:27:29Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "created https://github.com/w3c/manifest/issues/452 as an issue for the webapp manifest draft.\n",
          "createdAt": "2016-04-14T12:35:59Z",
          "updatedAt": "2016-04-14T12:35:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@marcoscaceres any thoughts? I'm happy to chat, but not sure whether coordination is going to be worth the extra friction on both sides...\n",
          "createdAt": "2016-05-26T02:55:48Z",
          "updatedAt": "2016-05-26T02:55:48Z"
        },
        {
          "author": "marcoscaceres",
          "authorAssociation": "NONE",
          "body": "[We have a registry](https://github.com/w3c/manifest/wiki/Extensions-Registry) and @dret is in charge of it... so, go nuts and break all the things! :) \n",
          "createdAt": "2016-05-26T03:42:04Z",
          "updatedAt": "2016-05-26T03:42:04Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for having a look, @mnot and @marcoscaceres. it was maybe just an odd idea, and thinking of it a bit more, i don't think there's a lot of value in trying to shoehorn one of these formats into the other. i'll go ahead and close this issue.\n",
          "createdAt": "2016-05-26T09:27:29Z",
          "updatedAt": "2016-05-26T09:27:29Z"
        }
      ]
    },
    {
      "number": 175,
      "id": "MDU6SXNzdWUxNDg2ODY1Njc=",
      "title": "\"profile\" link hint",
      "url": "https://github.com/mnot/I-D/issues/175",
      "state": "CLOSED",
      "author": "hvdsomp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "I would like to propose adding a Link Hint to express the profile of the linked resource, that is, to express the same info on a link to a resource that would be expressed at that resource itself by means of a \"profile\" link. I assume that would mean adding a \"profile\" attribute for Link Hints. \n",
      "createdAt": "2016-04-15T15:11:47Z",
      "updatedAt": "2018-03-30T02:00:34Z",
      "closedAt": "2018-03-30T02:00:34Z",
      "comments": [
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "In addition, I would like to propose adding a Link Hint to express the semantic type of the linked resource, that is, to express the same info on a link to a resource that would be expressed at that resource itself by means of a \"type\" link. I understand that this can not be achieved by means of the existing and widely used \"type\" attribute (reserved for mime types). So, maybe a \"sem-type\" attribute could be used?\n",
          "createdAt": "2016-05-05T19:12:24Z",
          "updatedAt": "2016-05-05T19:12:24Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@hvdsomp since a profile may be given as a media type parameter, couldn't this be handled with the current \"formats\" hint?",
          "createdAt": "2016-12-25T22:13:19Z",
          "updatedAt": "2016-12-25T22:13:19Z"
        },
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "Thanks @handrews for feedback. A few things come to mind:\r\n* I have seen the \"profile\" attribute being used as a media type parameter, indeed. For example in the W3C's Linked Data Notifications spec, see https://www.w3.org/TR/ldn/ . But I do not where this use was officially specified. I am only aware as \"profile\" as a link relation type, defined in http://www.faqs.org/rfcs/rfc6906.html\r\n* Assuming using \"profile\" as a media type parameter is acceptable, indeed, I think using it to convey profile information about a linked resource (along with its media type) would indeed be OK. It would solve my first issue above. Not sure that also using it for the second issue would be appropriate though. The info intended by a link with the \"type\" relation type is really an indication (by means of a URI) of a class a resource is an instance of. Very much like rdf:type. I don't think \"profile\" is appropriate in this case as the info is definitely not related to media type.",
          "createdAt": "2017-01-03T13:36:50Z",
          "updatedAt": "2017-01-03T13:36:50Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@hvdsomp the use of profile as a media type parameter is covered in [section 3.1 of RFC 6906](https://tools.ietf.org/html/rfc6906#section-3.1).\r\n\r\n@dret is the author of the profile RFC so perhaps he can speak to its usage here.  I feel like \"profile\", \"type\", and \"describedBy\" all overlap somewhat and it's not clear to me exactly which should be used when.  Except that \"profile\" is an identifier and not necessarily a locator, while \"describedBy\" seems to be acceptable for use as a locator.",
          "createdAt": "2017-01-03T19:04:23Z",
          "updatedAt": "2017-01-03T19:04:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-01-03 12:04, Henry Andrews wrote:\n> @dret <https://github.com/dret> is the author of the profile RFC so\n> perhaps he can speak to its usage here. I feel like \"profile\", \"type\",\n> and \"describedBy\" all overlap somewhat and it's not clear to me exactly\n> which should be used when. Except that \"profile\" is an identifier and\n> not necessarily a locator, while \"describedBy\" seems to be acceptable\n> for use as a locator.\n\n1. a profile media type parameter has to be allowed by the media type. \nvery few media types do this. so while i think that it's possible (and \nmaybe even better) to use a media type profile parameter, if that \nmechanism is required, in many cases the media type simply will not \nallow such a parameter to be used.\n\n2. in my mind, \"profile\", \"type\", and \"describedBy\" are distinct, but i \nhave heard world views where they are more similar and do have quite \nsome overlap. for this issue, however, i think it only matters what to \ndo if there is a profile in use and how to signal it. since there are \nmany cases where a profile media type parameter is not allowed (see 1), \ni think that supporting a profile hint might be a good idea.\n",
          "createdAt": "2017-01-04T04:38:19Z",
          "updatedAt": "2017-01-04T04:38:19Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> a profile media type parameter has to be allowed by the media type.\r\n\r\nAs this restriction is pretty much impossible to enforce in practice, what value does it have? I see great value in tagging on `profile` as authors see fit for their application, especially for loose media types such as `application/json` and `application/ld+json`.\r\n\r\n> since there are many cases where a profile media type parameter is not allowed (see 1), i think that supporting a profile hint might be a good idea.\r\n\r\nI agree.",
          "createdAt": "2017-01-04T08:13:46Z",
          "updatedAt": "2017-01-04T08:13:46Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> As this restriction is pretty much impossible to enforce in practice\r\n\r\nI have to admit my first reaction to that part was \"what, are the JSON Police (`application/police+json`) going to arrest me?\"\r\n\r\nAlthough if it really is not valid to use with `application/json` then JSON Schema will need to define an `application/instance+json` or something so that the profile parameter can be used to connect the schema.  Blerg.",
          "createdAt": "2017-01-04T08:20:06Z",
          "updatedAt": "2017-01-04T08:20:06Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this is off-topic:\r\n\r\nOn 2017-01-04 01:20, Henry Andrews wrote:\r\n> Although if it really is not valid to use with |application/json| then\r\n> JSON Schema will need to define an |application/instance+json| or\r\n> something so that the profile parameter can be used to connect the\r\n> schema. Blerg.\r\n\r\nprofile was not intended to refer to a schema. it is intended to refer \r\nto a profile, which is defined as extending and/or constraining the \r\noriginal media type. the spec gives examples.\r\n\r\nhttp://dret.typepad.com/dretblog/2016/05/resource-profiles-and-types.html\r\n",
          "createdAt": "2017-01-04T16:35:35Z",
          "updatedAt": "2017-01-04T16:42:40Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@dret I wasn't expecting a response on the JSON Schema aside, my point was about the usage of profiles with `application/json` (although admittedly poorly expressed- I shouldn't comment on issues after midnight :-)\r\n\r\nJSON Schema part moved to json-schema-org/json-schema-spec#222",
          "createdAt": "2017-01-04T19:13:52Z",
          "updatedAt": "2017-01-04T19:13:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think this is good discussion, but I don't think there's enough agreement (or adoption) to justify putting profile in the initial link-hints document. No argument against registering it separately though.",
          "createdAt": "2018-03-30T02:00:34Z",
          "updatedAt": "2018-03-30T02:00:34Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWUxNTI5Mzg4NzY=",
      "title": "Flag to indicate partial digest",
      "url": "https://github.com/mnot/I-D/issues/176",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "As discussed in #167, we need a flag to indicate whether the digest is partial or complete for the origin.\n\nFor discussion: should this be a flag in the frame header, or the payload?\n",
      "createdAt": "2016-05-04T06:25:49Z",
      "updatedAt": "2016-05-31T07:29:21Z",
      "closedAt": "2016-05-31T07:29:21Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> should this be a flag in the frame header, or the payload?\n\nWould it be better to have the flag in the payload, considering the fact that we _may_ add a field to the payload that modifies the scope of the digest (e.g. the `origin` attribute)?\n",
          "createdAt": "2016-05-04T22:19:41Z",
          "updatedAt": "2016-05-04T22:19:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See #177 for updated frame layout. \n\nI don't have a strong feeling on this. If we put it into the frame, I think we'll end up with something like:\n\n```\n+-----------+-------+-------+\n| flags (8) | N (5) | P (5) |\n+-----------------------------------------------+\n|              Digest-Length (24)               |\n+-----------------------------------------------+\n|              Digest-Value? (*)              ...\n+-----------------------------------------------+\n```\n\nWhich is a bit odd, because (a) there's already a flags field in the frame header, and (b) extensions will go at the bottom, not the top with the flags.\n\nWDYT?\n",
          "createdAt": "2016-05-18T07:05:42Z",
          "updatedAt": "2016-05-18T07:05:42Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would it be strange if we define the indicator for a partial digest directly in the format (like shown below) instead of defining `flags`?\n\nAlso, shouldn't Digest-Length and Digest-Value be aligned to 8-bit boundary?\n\nIf the two are OK to you, how does the following look to you?\n\n```\n+--------------+-------------+-------+-------+\n| Reserved (5) | Partial (1) | N (5) | P (5) |\n+--------------------+-----------------------+\n| Digest-Length (24) |\n+--------------------++\n| Digest-Value? (*) ...\n+---------------------+\n```\n",
          "createdAt": "2016-05-18T07:57:26Z",
          "updatedAt": "2016-05-18T07:57:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Please reopen if you see any issue.\n",
          "createdAt": "2016-05-31T07:29:21Z",
          "updatedAt": "2016-05-31T07:29:21Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWUxNTI5Mzg5MTY=",
      "title": "Extensibility",
      "url": "https://github.com/mnot/I-D/issues/177",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "... to express things like evolved digest formats, inclusion of stale cache entries, etc. as discussed in #167. \n",
      "createdAt": "2016-05-04T06:26:24Z",
      "updatedAt": "2016-05-31T07:28:40Z",
      "closedAt": "2016-05-31T07:28:40Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See changes above. I don't think it's necessary to establish a registry at this point; a future spec can do that if necessary, or they can just update this one.\n",
          "createdAt": "2016-05-18T06:59:36Z",
          "updatedAt": "2016-05-18T06:59:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not firmly against having `Digest-Length` field, but can't we just send multiple CACHE_DIGEST frames in case we want to send digests in other formats or stale entries?\n\nConsider the case of using another encoding.  In the case, it is likely that we would need to have attributes other than `N` and `P`, and that means that the structure prior to `Digest-Length` would become different.  In other words, there might be no merit in having the `Digest-Length` field (at this position) for the case.\n\nAlso in the case of sending stale digest only (a browser may not have any fresh resources cached), there's no need to send a Digest-Value of fresh entries.\n\nTo summarize, number of octets saved for having the Digest-Length field is as follows.\n1. -3 in case only fresh digest is sent\n2. 6 in case both fresh and stale digests are sent\n3. 3 in case only stale digest is sent\n4. -3 in case the digest is sent using another encoding\n\nAs can be seen, it is unclear if we gain or loose.  Considering the fact that digests would be more than just a few octets, I think we can live out without trying to make this small optimization.\n\nPS. If we are to use separate CACHE_DIGEST frames for sending every kind of digest (in other encoding or covering stale cache entries), I think we should use _the `flags` fleld of the frame header_ to distinguish them.\n",
          "createdAt": "2016-05-18T09:51:00Z",
          "updatedAt": "2016-05-18T09:51:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm absolutely fine with not having Digest-Length; I'd just thought that the conclusion of the discussion on the pull request was that the frame type needed to be extensible, and that seemed like the simplest way to allow it.\n\n>  If we are to use separate CACHE_DIGEST frames for sending every kind of digest (in other encoding or covering stale cache entries), I think we should use the flags fleld of the frame header to distinguish them.\n\nIn #176 you prefer putting the partial/complete flag in the payload; I tend to think that we should have one place for flags. \n\nWe _could_ just go ahead and define the following two header flags:\n1. `reset` - if `1`, indicates that _all_ cache state should be cleared before processing the frame (i.e., a client that always sends complete digests will send `reset` each time).\n2. `fresh/stale` - `0` indicates stale entries, `1` indicates fresh.\n\n... leaving the rest for future definition.\n\nWRT changing the digest encoding/format - I tend to think that we might as well define a new frame type if we want to do that (that's very much in the spirit of H2 extensibility; frame types are reasonably cheap).\n",
          "createdAt": "2016-05-18T11:07:37Z",
          "updatedAt": "2016-05-18T11:07:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm absolutely fine with not having Digest-Length; I'd just thought that the conclusion of the discussion on the pull request was that the frame type needed to be extensible, and that seemed like the simplest way to allow it.\n\n:+1: Thank you for the clarification.\n\n> > If we are to use separate CACHE_DIGEST frames for sending every kind of digest (in other encoding or covering stale cache entries), I think we should use the flags fleld of the frame header to distinguish them.\n> > In #176 you prefer putting the partial/complete flag in the payload; I tend to think that we should have one place for flags. \n\nSounds sensible.  No objections.\n\n> We could just go ahead and define the following two header flags:\n> 1. `reset` - if `1`, indicates that all cache state should be cleared before processing the frame (i.e., a client that always sends complete digests will send `reset` each time).\n> 2. fresh/stale - 0 indicates stale entries, 1 indicates fresh.\n> \n> ... leaving the rest for future definition.\n\n+1 to adding `reset`.\n\nFor stale digest, I believe we need to figure out how to push a cache validator (and my preference goes to `HEAD`).  Do you have any plans to write an I-D for that, or shall we?\n\nAnd as said, I have no objections on defining `partial` as the third flag.\n\n> WRT changing the digest encoding/format - I tend to think that we might as well define a new frame type if we want to do that (that's very much in the spirit of H2 extensibility; frame types are reasonably cheap).\n\nYeah! Thank you for standardizing H2.\n",
          "createdAt": "2016-05-18T12:55:12Z",
          "updatedAt": "2016-05-18T12:55:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "`reset` has the same effect as `partial` -- it indicates when the frame's contents should be added to the set of current digests, or when it should remove them all and start fresh. Does that make sense, or did you have another semantic in mind?\n",
          "createdAt": "2016-05-25T06:01:55Z",
          "updatedAt": "2016-05-25T06:01:55Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the clarification. It does make sense and I agree that we should have it.\n",
          "createdAt": "2016-05-25T06:05:09Z",
          "updatedAt": "2016-05-25T06:05:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the updates!\n\n> Note that Last-Modified is not included (yet); do we need it, or can we get away with just ETag?\n\nI have no objections to omitting `last-modified` (esp. considering the fact that users can work-around the issue\u00a0by coverting `last-modified` to `etag` in their reverse proxy configuration).\n\n> Also, server-side behaviour is not defined; I think we need a separate \"how to do server push\" document for that.\n\nSounds like a sensible thing to do.\n\nRegarding the flags, could we define `VALIDATORS` and `STALE` defined as a single flag?\n\nI am not sure what we can gain by having the two defined separately - I believe they would always be used together (both set to 1, or both set to zero).\n",
          "createdAt": "2016-05-31T06:16:55Z",
          "updatedAt": "2016-05-31T06:16:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It would allow you to push the validators for fresh responses, in case someone wanted to invalidate something that's fresh. Not a use case now, but it might be interesting in the future.\n",
          "createdAt": "2016-05-31T06:42:37Z",
          "updatedAt": "2016-05-31T06:42:37Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It would allow you to push the validators for fresh responses, in case someone wanted to invalidate something that's fresh. Not a use case now, but it might be interesting in the future.\n\nThank you for the clarification.  Understood.  No objection to having two flags.\n",
          "createdAt": "2016-05-31T06:50:54Z",
          "updatedAt": "2016-05-31T06:50:54Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWUxNTQzODQ3Mzc=",
      "title": "LWS",
      "url": "https://github.com/mnot/I-D/issues/178",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Need to make whitespace explicit in Link ABNF.\n",
      "createdAt": "2016-05-12T02:38:41Z",
      "updatedAt": "2016-11-16T04:52:08Z",
      "closedAt": "2016-11-16T04:52:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Being resolved by #33.\n",
          "createdAt": "2016-11-16T04:52:08Z",
          "updatedAt": "2016-11-16T04:52:08Z"
        }
      ]
    },
    {
      "number": 179,
      "id": "MDU6SXNzdWUxNTQzODY3MDU=",
      "title": "Value space of target attribute names",
      "url": "https://github.com/mnot/I-D/issues/179",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "case-insensitive \n",
      "createdAt": "2016-05-12T03:00:24Z",
      "updatedAt": "2016-05-13T01:20:18Z",
      "closedAt": "2016-05-13T01:20:18Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Also, need to clarify that it's up to individual types to talk about whether to check for RFC5987,\n",
          "createdAt": "2016-05-12T04:39:20Z",
          "updatedAt": "2016-05-12T04:39:20Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWUxNTQ2MTUyMzI=",
      "title": "RFC5987(bis) processing on extension attributes",
      "url": "https://github.com/mnot/I-D/issues/180",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Right now, the link header defines _two_ serialisations for extension target attributes, differentiating them with a * on the end of the name (thanks to RFC5987 encoding).\n\nHow should this be surfaced in the generic link model? A few possibilities:\n1. They're automatically processed and write over the *-less version of the attribute.\n2. Both versions are exposed to the consumer; it can pick what to use.\n3. Don't allow RFC5987 encoding for extension attributes.\n\nThere are downsides to all of them:\n1. This could have security implications for some relations, and relations that support more than one occurrence on the link are forced to use one or the other.\n2. Now relations have to define whether they support the * version in this serialisation.\n3. No i18n in link relations (unless we can assume that the header value is UTF-8).\n\nNext steps:\n- [ ] Figure out whether the security implications are real\n- [ ] Investigate whether assuming UTF-8 (effectively deprecating 5987, at least for extensions) is a possibility\n",
      "createdAt": "2016-05-13T01:26:49Z",
      "updatedAt": "2016-11-22T06:48:50Z",
      "closedAt": "2016-11-22T06:48:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Firefox appears to assume ISO-8859-1 encoding (at least for `title` on `rel=stylesheet`); see:\n  http://test.mnot.net/foo/\n",
          "createdAt": "2016-05-13T02:36:54Z",
          "updatedAt": "2016-05-13T02:36:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "... and that appears to be based upon Link's original use of `quoted-string`, which in turn used `TEXT`. \n\nHowever, RFC7230 obsoleted `%x80-FF` in `quoted-string`.\n\nIt's tempting to say that at a minimum, extension parameters don't use `quoted-string`, but instead a new ABNF rule that contains UTF-8, not ISO-8859-1. Title might have to stay with RFC5987 encoding for backwards compatibility.\n",
          "createdAt": "2016-05-13T02:50:56Z",
          "updatedAt": "2016-05-13T02:50:56Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I'm :+1: for defaulting to UTF-8. Does RFC 7230 and an UTF-8 default mean that there isn't a problem with `*` and encoding, or does that still need to be tackled somehow?\n",
          "createdAt": "2016-05-13T06:20:05Z",
          "updatedAt": "2016-05-13T06:20:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@reschke any thoughts?\n",
          "createdAt": "2016-05-26T04:44:21Z",
          "updatedAt": "2016-05-26T04:44:21Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Firefox is consistent in how it treats non-ASCII in quoted-string (the same is true for Content-Disposition, AFAIK). I don't believe that having rules per header field is a good idea.\n\nI don't understand \"This could have security implications for some relations, and relations that support more than one occurrence on the link are forced to use one or the other.\", could you elaborate?\n",
          "createdAt": "2016-05-26T05:48:32Z",
          "updatedAt": "2016-05-26T05:50:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think spec authors would find it surprising (in a bad way) that someone could inject/override a parameter field value into a header by adding another instance of it suffixed with `*`.\n\nWhat's not clear is whether that surprise is potentially a vulnerability. However, it feels somewhat similar to HTTP response splitting and the like, especially since the recipient is allowed to fall back to the other form if they don't do 5987 decoding.\n\n@mikewest @rlbmoz any thoughts?\n",
          "createdAt": "2016-05-26T06:44:52Z",
          "updatedAt": "2016-05-26T06:44:52Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"I think spec authors would find it surprising (in a bad way) that someone could inject/override a parameter field value into a header by adding another instance of it suffixed with *.\"\n\nHow is that different from injecting the same parameter without the \"*\"?\n\nReminder: parameters are not supposed to repeat; but that might be just folklore (Keith told me that back when RFC5987-to-be mentioned multiple instances of \"title*\" to provide information in multiple languages).\n",
          "createdAt": "2016-05-26T07:03:02Z",
          "updatedAt": "2016-05-26T07:03:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "An author can specify exactly one instance of a parameter, first match wins, and still be vulnerable to having it interpreted different by different recipients -- even if the payload is an integer (for example).\n",
          "createdAt": "2016-05-26T07:29:37Z",
          "updatedAt": "2016-05-26T07:29:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK. Approach #2 sounds better then.\n",
          "createdAt": "2016-05-26T07:43:14Z",
          "updatedAt": "2016-05-26T07:43:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "That's the least desirable option to me; It is really, really nasty to expose a serialisation-specific encoding convention to a consumer. Every link relation that defines parameters that take non-ASCII input would have to talk about this special case. \n",
          "createdAt": "2016-05-26T07:59:07Z",
          "updatedAt": "2016-05-26T07:59:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...but then it's at least simple and predictable in that all parameters are treated uniformly.\n",
          "createdAt": "2016-05-26T08:02:10Z",
          "updatedAt": "2016-05-26T08:02:10Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I'd say go for option 3 and figure out a better i18n solution.\n",
          "createdAt": "2016-05-26T09:14:41Z",
          "updatedAt": "2016-05-26T09:14:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Talked to @reschke about this a bit in Berlin.\n\nI'm currently leaning towards (1), with a fair chunk of text (and maybe requirements) in Security Considerations. \n",
          "createdAt": "2016-07-19T08:29:27Z",
          "updatedAt": "2016-07-19T08:29:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Now wondering if it needs the sec considerations.\n",
          "createdAt": "2016-11-16T06:59:44Z",
          "updatedAt": "2016-11-16T06:59:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing for now.",
          "createdAt": "2016-11-22T06:48:50Z",
          "updatedAt": "2016-11-22T06:48:50Z"
        }
      ]
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWUxNTYxOTAyNTk=",
      "title": "digest of stale resources",
      "url": "https://github.com/mnot/I-D/issues/181",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "If we are to support sending cache digest of stale resources (https://github.com/mnot/I-D/issues/177#issue-152938916), we:\n- MUST define how to hash a stale resource\n- SHOULD define how to push a cache validator using H2\n\nFor the first topic, I believe:\n- if a stale response has a etag, then the hash value should be calculated as `H(URL + entity-tag)`\n- if a stale response does not have a etag but has a last-modified header, then the hash value should be calculated as `H(URL + last-modified-value)`\n\nA server should test the digest using the URL and the validators of a preload URL, and if a match has been found, push a cache validator.  Or else, should push the resource of the preload URL.  This way, the preload resource will be delivered zero-RTT regardless of whether if it was stale-cached or not.\n\nThe second topic is problematic.\n\nI have previously argued for using `HEAD` for pushing cache validators (https://github.com/mnot/I-D/issues/177#issuecomment-220017094), but now I think the best way is to introduce a new 3xx status code.  The details follow.\n\nConsider an edge server terminating H2 that loads resource from other servers.  The server recognizes `link: rel=preload` header and uses the cache digest to find out whether or not the specified resource should be pushed.\n\nAt the time the edge server receives the preload headers of the main request from an upstream server, it cannot _instantaneously_ determine if the specified resource is marked in the stale digest, since the server cannot find out the cache validator without contacting an upstream server that serves the specified resource.\n\nThat means that in either of the proposed ways of sending cache validators (push HEAD or push conditional GET), the edge server needs to delay sending the HEADERS frame of the main response, considering the requirement that _the server SHOULD send PUSH_PROMISE frames prior to sending any frames that reference the promised responses_ ([RFC 7540 section 8.2.1](http://httpwg.org/specs/rfc7540.html#rfc.section.8.2.1)).\n\nOf course we would never want to delay sending things to client.  And that means that we must send a PUSH_PROMISE frame that does not depend on the cache validator, and then send just the cache validator or send the updated response.\n\nIdeally, a server should:\n- send PUSH_PROMISE frames containing unconditional GETs for all preload links expect those cached as fresh\n- for the resources that are later found to be stale-cached by the client, only send the cache-validators\n- for the resources that are later found to be _not_ stale-cached by the client, send the full response\n\nThis is why I propose introducing a new 3xx status code, possibly named as: Validator-Only.  The status code would be used against a unconditional GET request, but only includes cache validator(s), and does not have a message body.\n\n@mnot WDYT?\n",
      "createdAt": "2016-05-23T02:41:36Z",
      "updatedAt": "2016-05-31T07:31:12Z",
      "closedAt": "2016-05-31T07:28:53Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "This mechanism (3xx Validator Only) is an optimisation for the case where the client has a stale cached copy, but the edge doesn't have a copy, correct? \n\nI think there are two cases that are good to talk about here:\n1. If latency between the client and the edge is significantly higher than from the edge to the origin (e.g., the edge is a reverse proxy right in front of it), the edge can delay the PUSH_PROMISE until it has a response from the origin, without any impact upon latency; at worst, it might receive a GET from the client after it sends its PUSH_PROMISE, and need to RST_STREAM one of them.\n2. If latency between the client and the edge is lower than that from the edge to the origin (i.e., a highly distributed CDN), the edge can wait for the client's GET, rather than using server push; as long as it used the preload hint to initiate a fetch, the maximum latency gain should be seen.\n\nAlso, I _think_ most deployments in this pattern are going to be caching on the edge, so this (having a client with something stale in cache, but not fresh on the edge) is likely to be a pretty rare condition (and also one that the edge can use other means of avoiding, e.g., stale-while-revalidate). It _may_ not be worth optimising for.\n\nAll of that said -- if we do want to provide for this case, I don't see any reason why 304 can't be reused; its semantics are a match, it's just a bit odd to send it when the request wasn't conditional. What made you avoid using it?\n\nAnd, am I missing something?\n",
          "createdAt": "2016-05-25T05:15:45Z",
          "updatedAt": "2016-05-25T05:15:45Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the response.\n\n> This mechanism (3xx Validator Only) is an optimisation for the case where the client has a stale cached copy, but the edge doesn't have a copy, correct? \n\nYes.\n\n> 1 . If latency between the client and the edge is significantly higher than from the edge to the origin (e.g., the edge is a reverse proxy right in front of it), the edge can delay the PUSH_PROMISE until it has a response from the origin, without any impact upon latency; at worst, it might receive a GET from the client after it sends its PUSH_PROMISE, and need to RST_STREAM one of them.\n\nThe edge server should not reset one of the two, since the client might reset the other (trying to read from the stream that the edge server resets).\n\nSo if the edge server sends a PUSH_PROMISE of a link-preloaded resource after the HEADERS frame that contains the link-preload tag, then there is a chance that the client issues a pull for the same resource, and in such case, the bandwidth needs to be wasted for sending the same resource twice, or the edge server needs to wait for 1 RTT to see if the client resets one of the two.\n\nIn other words, sending the HEADERS frame needs be postponed until the cache validator is obtained by the edge server if the value of the PUSH_PROMISE frame needs to depend on the value of the validator.\n\nI agree that the delay is not likely to be as large as the latency between the client and the edge server. But even if the resource exists in a POP of a CDN, there is no guarantee that the resource exists on the same host that receives the HTTP/2 connection. So the necessity of a delay might not be very unlikely.\n\n> 2 . If latency between the client and the edge is lower than that from the edge to the origin (i.e., a highly distributed CDN), the edge can wait for the client's GET, rather than using server push; as long as it used the preload hint to initiate a fetch, the maximum latency gain should be seen.\n\nAgreed. Though it would be simpler if the edge server could use server push in this case as well.\n\n> All of that said -- if we do want to provide for this case, I don't see any reason why 304 can't be reused; its semantics are a match, it's just a bit odd to send it when the request wasn't conditional. What made you avoid using it?\n\nThere are (at least) two differences in the semantics from 304: 1) 3xx validator-only is a response against an non-conditional response, 2) the client needs to issue a new request if it receives 3xx validator-only but the validator found in the response headers did not match the one found in the cache.\n\nThe second point (by itself) might not justify the introduction of a new status code; such behavior could be argued as something necessary for H2 push in general.  But the first point clearly contradicts with the definition of 304 in RFC - that is why I thought we need to define a new status code.\n\nBut with that said, I have no objections on reusing 304 with the modified semantics in this case.\n",
          "createdAt": "2016-05-25T06:48:26Z",
          "updatedAt": "2016-05-25T06:48:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See changes above.\n\nI haven't included Last-Modified; do you think we need it, or can we just do ETag?\n\nI also haven't included server-side behaviour specification, as I'm starting to think we need a separate \"how to do server push\" spec altogether.\n",
          "createdAt": "2016-05-27T04:53:12Z",
          "updatedAt": "2016-05-27T04:53:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Unrelated but as I was doing this, I noticed:\n\n> 1. Let N be the count of `URLs`' members, rounded up to power of 2.  If N is greater than 2**32, then let N be 2**31.\n\nI think one of those numbers needs to change to the other, correct? 2**31?\n",
          "createdAt": "2016-05-27T04:54:25Z",
          "updatedAt": "2016-05-27T04:54:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > #. Let N be the count of URLs' members, rounded up to power of 2. If N is greater than 2**32, then let N be 2**31.\n> \n> I think one of those numbers needs to change to the other, correct? 2**31?\n\nThank you for noticing the issue.\n\nI believe it should be changed to: Round down N to power of 2, smaller than 2**32.\n\nBy changing as such, it would match the definition of P.  It also makes the definition clear since `log2(N)` always becomes an integer.\n",
          "createdAt": "2016-05-31T07:31:11Z",
          "updatedAt": "2016-05-31T07:31:11Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWUxNTc1NzQ0Nzg=",
      "title": "Specifying examples",
      "url": "https://github.com/mnot/I-D/issues/182",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Examples should include HTTP/1.1 headers, with both the request and response.\n",
      "createdAt": "2016-05-31T01:39:22Z",
      "updatedAt": "2017-12-14T01:40:24Z",
      "closedAt": "2017-12-14T01:40:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "In httpwg repo",
          "createdAt": "2017-12-14T01:40:24Z",
          "updatedAt": "2017-12-14T01:40:24Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWUxNTc1OTIxNjQ=",
      "title": "Off by one?",
      "url": "https://github.com/mnot/I-D/issues/183",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "> Let N be the count of `URLs`' members, rounded up to power of 2.  If N is greater than 2**32, then let N be 2**31.\n\nI think that should be \"If N is greater than 2**31\"...\n",
      "createdAt": "2016-05-31T05:25:38Z",
      "updatedAt": "2016-06-01T01:03:58Z",
      "closedAt": "2016-06-01T01:03:58Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe it should be changed to: Round N to nearest power of 2~~down to power of 2~~, smaller than 2**32.\n\nBy changing as such, it would match the definition of P. It also makes the definition clear since log2(N) always becomes an integer.\n\n(originally responded [here](https://github.com/mnot/I-D/issues/181#issuecomment-222612861) - link added to avoid confusion)\n\nEDIT. Changed to round-to-nearest from round-down.\n",
          "createdAt": "2016-05-31T07:43:06Z",
          "updatedAt": "2016-05-31T08:04:32Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "MDU6SXNzdWUxNTc1OTIyMjU=",
      "title": "Decoding",
      "url": "https://github.com/mnot/I-D/issues/184",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "As per @martinthomson, we need to specify how to use the digest.\n",
      "createdAt": "2016-05-31T05:26:08Z",
      "updatedAt": "2016-06-08T04:13:37Z",
      "closedAt": "2016-06-08T02:37:37Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Straw-man to start defining the algorithm:\n\n## Querying the Digest for a Value {#querying}\n\nGiven:\n- `digest-value`, an array of bits\n- `URL`, an array of characters\n- `ETag`, an array of characters\n- `validators`, a boolean\n\nwe can determine whether there is a match in the digest using the following algorithm:\n1. Read the first 5 bits of `digest-value` as an integer; let `N` be two raised to the power of that value.\n2. Read the next 5 bits of `digest-value` as an integer; let `P` be two raised to the power of that value.\n3. Let `hash-value` be the result of computing a hash value ({{hash}}).\n4. Let `C` be 0.\n5. Read '0' bits from `digest-value` until a '1' bit is found; let `Q` bit the number of '0' bits. Discard the '1'.\n6. Read log2(`P`) bits from `digest-value` after the '1' as an integer; let `R` be its value.\n7. Let `D` be `Q` \\* `P` + `R`.\n8. Increment `C` by `D`.\n9. If `C` is equal to `hash-value`, return 'true'.\n10. Otherwise, return to step 5 and continue processing; if no match is found before `digest-value` is exhausted, return 'false'.\n\nPing @kazuho \n\n_this assumes we factor out the computation of hash to a seperate section_\n",
          "createdAt": "2016-06-07T05:05:04Z",
          "updatedAt": "2016-06-07T05:05:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for your effort!\n\nI believe step 4 should start `C` from -1, and step 8 should increment `C` by `D + 1`.  In the encoding process we subtract 1 from the delta (because we do not encode duplicates), and we need to do the reverse during the decoding process.\n\nOther than that I do not see any issues.\n",
          "createdAt": "2016-06-07T18:56:07Z",
          "updatedAt": "2016-06-07T18:56:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At what point are the characters turned into octets?\n",
          "createdAt": "2016-06-08T04:04:06Z",
          "updatedAt": "2016-06-08T04:04:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note also that you can stop parsing when `C > hash-value`.\n",
          "createdAt": "2016-06-08T04:08:33Z",
          "updatedAt": "2016-06-08T04:08:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "> At what point are the characters turned into octets?\n\nThat's in {{hash}}.\n\n> Note also that you can stop parsing when C > hash-value.\n\nI think that's an optimisation we can leave up to the reader; this is pseudo-code, after all :)\n",
          "createdAt": "2016-06-08T04:13:36Z",
          "updatedAt": "2016-06-08T04:13:36Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWUxNTc2ODY4ODY=",
      "title": "Relationship between attributes and parameters",
      "url": "https://github.com/mnot/I-D/issues/185",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "I'm probably just dim, but I don't think RFC 5988 is clear on the difference between \"target attributes\" and \"link parameters\". Could a section describing the difference and the relationship between them be added, or at least described to me so I understand the difference? Thanks! :smile: \n",
      "createdAt": "2016-05-31T14:33:47Z",
      "updatedAt": "2016-11-16T05:02:20Z",
      "closedAt": "2016-11-16T05:02:20Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "target attributes are on the abstract link model; link parameters are on the concrete syntax of the link header serialisation. \n\nIf there's somewhere where they're used inconsistently, please do point it out.\n",
          "createdAt": "2016-06-01T01:05:53Z",
          "updatedAt": "2016-06-01T01:05:53Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@mnot I don't think they're used inconsistently, I just wish that they were discerned more expressively in the specification, because I'm still not sure what:\n\n> target attributes are on the abstract link model; link parameters are on the concrete syntax of the link header serialisation.\n\nactually means. Can you please elaborate, preferably in the specification?\n",
          "createdAt": "2016-06-01T05:46:44Z",
          "updatedAt": "2016-06-01T05:46:44Z"
        }
      ]
    },
    {
      "number": 190,
      "id": "MDU6SXNzdWUxNTgyNzM2NTU=",
      "title": "value-less parameters",
      "url": "https://github.com/mnot/I-D/issues/190",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "Link parameters are seen in the while without a value; e.g., `rel='preload' crossorigin` in http://w3c.github.io/preload/\n",
      "createdAt": "2016-06-03T01:27:06Z",
      "updatedAt": "2017-06-20T00:43:46Z",
      "closedAt": "2017-06-20T00:43:46Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "In HTML, value-less attributes are called [boolean attributes](https://www.w3.org/TR/html5/infrastructure.html#boolean-attributes), perhaps rfc5988bis should adopt that and call value-less parameters for \"boolean parameters\" too?\n",
          "createdAt": "2016-06-03T09:18:32Z",
          "updatedAt": "2016-06-03T09:18:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "ABNF in 5988 already supports this.\n",
          "createdAt": "2016-11-13T12:36:19Z",
          "updatedAt": "2016-11-13T12:36:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "No it doesn't (at least now).",
          "createdAt": "2017-06-12T12:47:41Z",
          "updatedAt": "2017-06-12T12:47:41Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also `nopush`: https://w3c.github.io/preload/#server-push-http-2",
          "createdAt": "2017-06-12T12:51:13Z",
          "updatedAt": "2017-06-12T12:51:13Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWUxNjA3OTMwMzg=",
      "title": "Add service link relation types",
      "url": "https://github.com/mnot/I-D/issues/191",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "this may be a bit of a long shot, but in particular if the \"home\" link relation gets added (#41), then what about also adding the two link relations proposed in https://tools.ietf.org/html/draft-wilde-service-link-rel? it's a separate draft now, but i think home documents would be a great home (ha!) for those link relations, making things a little less scattered across a variety of drafts.\n",
      "createdAt": "2016-06-17T01:04:58Z",
      "updatedAt": "2019-08-30T12:08:32Z",
      "closedAt": "2019-08-30T12:08:31Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "The less RFC's people have to read, the better, imho. While modularity is a good design pattern, I don't think there's much need for that here. So :+1:.\n",
          "createdAt": "2016-06-17T08:41:41Z",
          "updatedAt": "2016-06-17T08:41:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I've just sketched in a separate top-level member about the API itself, but am amenable to changes. Will have a read of that and think.",
          "createdAt": "2016-11-23T06:51:41Z",
          "updatedAt": "2016-11-23T06:51:41Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-22 22:51, Mark Nottingham wrote:\n> I've just sketched in a separate top-level member about the API itself,\n> but am amenable to changes. Will have a read of that and think.\n\nthanks, and any thoughts/issues/feedback/requirements you might have \nwould be very welcome at \nhttps://github.com/dret/I-D/issues?q=is%3Aopen+is%3Aissue+label%3Aservice-link-rel\n",
          "createdAt": "2016-11-27T20:50:13Z",
          "updatedAt": "2016-11-27T20:50:13Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the \"API Object\" now lists three link types (`author`, `describedBy`, `license`). https://github.com/dret/APIdocumentation/issues/1 has a few more (not all of them existing link relations yet) and generally attempts to look at what additional information might be interesting for some APIs.\r\n`describedBy` is recommended to be used for something where https://tools.ietf.org/html/draft-wilde-service-link-rel recommends `service-desc` and `service-doc`. the idea of the latter is to clearly separate machine- and human-oriented description/documentation.",
          "createdAt": "2017-10-10T04:55:30Z",
          "updatedAt": "2017-10-10T04:55:30Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://tools.ietf.org/html/rfc8631 has been published.",
          "createdAt": "2019-08-30T12:08:31Z",
          "updatedAt": "2019-08-30T12:08:31Z"
        }
      ]
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWUxNjE3MTMwODg=",
      "title": "How does \"formats\" work?",
      "url": "https://github.com/mnot/I-D/issues/192",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "reading through https://tools.ietf.org/html/draft-nottingham-json-home-04 and looking at the example i cannot quite figure out how \"formats\" (https://tools.ietf.org/html/draft-nottingham-json-home-04#section-4.2) works.\n- the section talks about GET and PUT, but those aren't the only methods for which it might be necessary to talk about \"formats\", right?\n- how does the key/value structure work? the example has one key with an empty value, and the section defining \"formats\" links to a section marked \"tbd\".\n\ni am working on getting an updated version of the XML syntax ready, and thus i am going through the syntax. however, this seems to be a general issue where it's hard to figure out how that specific feature is supposed to work.\n",
      "createdAt": "2016-06-22T15:26:09Z",
      "updatedAt": "2017-03-14T13:38:36Z",
      "closedAt": "2017-02-15T04:27:24Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/dret/I-D/commit/68ee1100624820b9c3b085ab91cc0ce3e5ae4f62 is my first stab at how to do this for the XML syntax. but i am sure this will need to be tweaked once i better understand the \"formats\" mechanism.\n",
          "createdAt": "2016-06-22T15:38:54Z",
          "updatedAt": "2016-06-22T15:38:54Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thinking about this some more: maybe this is a combined \"GET\"/\"PUT\" hint that's kind of analogous to the \"accept-*\" ones? if so, for consistency what about having an \"accept-put\" and leave \"formats\" to only talk about the formats for retrieval?\n",
          "createdAt": "2016-06-22T15:45:02Z",
          "updatedAt": "2016-06-22T15:45:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "now i realize that this is how -02 worked and accept-put then disappeared in -03. to me that seems like a loss, but i am sure there was some reason to do it.\n",
          "createdAt": "2016-06-22T15:52:29Z",
          "updatedAt": "2016-06-22T15:52:29Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i realize that this structure (using the example from the draft) is not good for the fine-grained \"hints\" concept. but it associates things more directly and maybe is easier to read and understand?\n\n``` javascript\n{\"hints\": {\"allow\": [\n  {\"GET\": [\"application/json\"]},\n  {\"PUT\": [\"application/json\"]},\n  {\"DELETE\": []},\n  {\"PATCH\": [\"application/json-patch\"]}\n]}}\n```\n",
          "createdAt": "2016-06-22T16:04:00Z",
          "updatedAt": "2016-06-22T16:04:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Good Q, although the phrasing reminds me of [this](https://www.youtube.com/watch?v=OvmvxAcT_Yc) :)\n\nWill need to dig into it, not sure I can get to it soon, as I'm on the road for a while.\n",
          "createdAt": "2016-06-22T21:18:34Z",
          "updatedAt": "2016-06-22T21:18:34Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-06-22 23:18, Mark Nottingham wrote:\n\n> Good Q, although the phrasing reminds me of this\n> https://www.youtube.com/watch?v=OvmvxAcT_Yc :)\n\nno intention to be offensive on my side, sorry if it came across like \nthis. simply trying to figure it out as the XML format needs to be aligned.\n\n> Will need to dig into it, not sure I can get to it soon, as I'm on the\n> road for a while.\n\nok. i'd be more than happy to help, and maybe simplifying the whole \nthing (as suggested in #193) to be more about interconnecting resources \nand not so much about capabilities would make it easier to move forward.\n",
          "createdAt": "2016-06-23T08:18:19Z",
          "updatedAt": "2016-06-23T08:18:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "> no intention to be offensive on my side, sorry if it came across like\n> this. simply trying to figure it out as the XML format needs to be aligned.\n\nOh, no, sorry! Was not trying to imply that, just being silly. Sorry.\n",
          "createdAt": "2016-06-23T22:26:36Z",
          "updatedAt": "2016-06-23T22:26:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think it boils down to whether the formats you can `GET` and `PUT` are always the same (provided you're `allow`ed to perform both methods, of course).\r\n\r\nI can imagine that an API only wants to consume data in one format, but can provide it in more than one.\r\n\r\n`acceptPut`, perhaps?",
          "createdAt": "2016-11-23T06:39:54Z",
          "updatedAt": "2016-11-23T06:39:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "BTW, I'm thinking about ditching representation hints altogether; I think all of the semantics necessary for a home doc can be communicated in the media type / link relation + target attributes. Thoughts?",
          "createdAt": "2016-11-23T06:48:43Z",
          "updatedAt": "2016-11-23T06:48:43Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I think the less JSON Home tries to do, the better. It can very quickly end up duplicating the efforts of Web API specification languages such as [Swagger](http://swagger.io/), [RAML](https://raml.org/), [API Blueprint](https://apiblueprint.org/), [Hydra](http://www.hydra-cg.com/), etc. As far as I understand, that's not the intention of JSON Home. The only thing I'd ensure is that these specification formats can easily be referenced from the JSON Home document.",
          "createdAt": "2016-11-23T15:59:43Z",
          "updatedAt": "2016-11-23T15:59:43Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-23 21:29, Asbj\u00f8rn Ulsberg wrote:\n> I think the less JSON Home tries to do, the better. It can very quickly\n> end up duplicating the efforts of Web API specification languages such\n> as Swagger <http://swagger.io/>, RAML <https://raml.org/>, API Blueprint\n> <https://apiblueprint.org/>, Hydra <http://www.hydra-cg.com/>, etc. As\n> far as I understand, that's not the intention of JSON Home. The only\n> thing I'd ensure is that these specification formats can easily be\n> referenced from the JSON Home document.\n\nhttps://tools.ietf.org/html/draft-wilde-service-link-rel should help \nwith that (without requiring any specific support in JSON home).\n",
          "createdAt": "2016-11-24T09:40:39Z",
          "updatedAt": "2016-11-24T09:40:39Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@dret: True, thanks for the pointer!",
          "createdAt": "2016-11-24T14:22:02Z",
          "updatedAt": "2016-11-24T14:22:02Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-22 22:48, Mark Nottingham wrote:\n> BTW, I'm thinking about ditching representation hints altogether; I\n> think all of the semantics necessary for a home doc can be communicated\n> in the media type / link relation + target attributes. Thoughts?\n\ni think that's a smart move. we had these discussions somewhere else \nalready, with a variety of parties (you and me included) trying to come \nup with something akin to representation hints, and the various \napproaches never seemed to quite make everybody happy.\n\nif the home format is extensible enough that later on, such \nrepresentation hints could be added, if a standard is created and people \nwant to embed them, then things are in good shape. i generally agree \nwith @asbjornu here that this should be rather minimal in scope.\n",
          "createdAt": "2016-11-29T04:37:18Z",
          "updatedAt": "2016-11-29T04:37:18Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@mnot does \"ditching representation hints\" just refer to \"formats\" or to the whole hints section?",
          "createdAt": "2016-12-27T20:25:56Z",
          "updatedAt": "2016-12-27T20:25:56Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-12-27 13:25, Henry Andrews wrote:\n> @mnot <https://github.com/mnot> does \"ditching representation hints\"\n> just refer to \"formats\" or to the whole hints section?\n\nmy interpretation is that it refers to the whole concept of \nrepresentation hints. but i am not sure.\n",
          "createdAt": "2016-12-29T19:44:21Z",
          "updatedAt": "2016-12-29T19:44:21Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@dret my question was more on what qualifies as a \"representation\" hint vs (possibly) other types of resource hints.  Like is the \"allow\" hint a representation hint?  It doesn't technically say anything about the representation itself.",
          "createdAt": "2016-12-29T19:54:29Z",
          "updatedAt": "2016-12-29T19:54:29Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-12-29 12:54, Henry Andrews wrote:\n> @dret <https://github.com/dret> my question was more on what qualifies\n> as a \"representation\" hint vs (possibly) other types of resource hints.\n> Like is the \"allow\" hint a representation hint? It doesn't technically\n> say anything about the representation itself.\n\ntrue, but it tells you how you can interact with it. and \"representation \nhints\" as a separate concept are gone from \nhttps://tools.ietf.org/html/draft-nottingham-json-home-05 anyway, now \nthere only are \"resource hints\".\n\nbut anyway, exegesis does not make a lot of sense here, let's see what \n@mnot says.\n",
          "createdAt": "2016-12-29T20:01:38Z",
          "updatedAt": "2016-12-29T20:01:38Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> but anyway, exegesis does not make a lot of sense here, let's see what\r\n@mnot says.\r\n\r\nAgreed.  My interest is that many of the hints complement what JSON Hyper-Schema does, and I'm trying to figure out if it makes sense to use JSON Hyper-Schema and JSON Home together.  It would also help me decide whether to push for HTTP-related hints in JSON Hyper-Schema or not.  It's been proposed, but honestly if JSON Home can address those in a way that complements JSON Hyper-Schema, I'd rather leave HTTP-specific things out of Hyper-Schema (not that I'm making that decision on my own, but I can push for or against it :-)",
          "createdAt": "2016-12-29T20:18:45Z",
          "updatedAt": "2016-12-29T20:18:45Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-12-29 13:18, Henry Andrews wrote:\n>     but anyway, exegesis does not make a lot of sense here, let's see what\n>     @mnot <https://github.com/mnot> says.\n>\n> Agreed. My interest is that many of the hints complement what JSON\n> Hyper-Schema does, and I'm trying to figure out if it makes sense to use\n> JSON Hyper-Schema and JSON Home together. It would also help me decide\n> whether to push for HTTP-related hints in JSON Hyper-Schema or not. It's\n> been proposed, but honestly if JSON Home can address those in a way that\n> complements JSON Hyper-Schema, I'd rather leave HTTP-specific things out\n> of Hyper-Schema (not that I'm making that decision on my own, but I can\n> push for or against it :-)\n\ngoing off-topic: the whole hyper-schema part is a pretty big burden on \nthe spec already. from what the majority of people are looking for, it \nmight make sense to factor that out into a separate spec and keep JSON \nschema lean and simple. i would definitely think very carefully about \nextending that part even further.\n",
          "createdAt": "2016-12-30T05:30:00Z",
          "updatedAt": "2016-12-30T05:30:00Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> going off-topic: the whole hyper-schema part is a pretty big burden on\r\nthe spec already.\r\n\r\nIt technically is a separate spec, we've just been updating their drafts at the same time.  But they don't have to reach RFC at the same time.  I don't want to derail this discussion further so if I'm missing your point feel free open an issue over on the JSON Schema repo or mailing list.",
          "createdAt": "2016-12-30T05:39:41Z",
          "updatedAt": "2016-12-30T05:39:41Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/mnot/I-D/commit/9f865dfee56f449a91509f457e0619b25c7e09c5 leaves the general concept more or less unchanged and adds `acceptPut` as discussed earlier in this issue. i am wondering about the comments made above about unbundling the home format and the general idea of link descriptions/hints. aren't these two orthogonal concepts that can be combined, but also both make sense as standalone specifications?",
          "createdAt": "2017-02-15T09:57:54Z",
          "updatedAt": "2017-02-15T09:57:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Well, it changes formats to cover GET (and by extension, HEAD), not PUT. \r\n\r\nWhich comments were about unbundling the home format? I read them as a side conversation about JSON Hyper Schema.",
          "createdAt": "2017-02-22T06:12:40Z",
          "updatedAt": "2017-02-22T06:12:40Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-02-22 07:12, Mark Nottingham wrote:\n> Which comments were about unbundling the home format? I read them as a\n> side conversation about JSON Hyper Schema.\n\nmaybe different people have different views and/or goals. my view still \nis (as mentioned in comments in this issue) that it might be best for \nhome documents to just provide a basic structure for home documents, and \nto leave the hinting part as a separate exercise. i think that's what \nboth https://tools.ietf.org/html/draft-nottingham-link-hint and \nhttps://tools.ietf.org/html/draft-wilde-link-desc had in mind.\n\nmy main motivation for this is that hints are a valuable thing in \nitself, and bundling them into the home document spec might make reuse \nharder and less attractive for others.\n\nto some extent the hints are visible by themselves through the proposed \nregistry and that is great, because this registry then can grow without \nupdates to the home spec. but just as a matter of trying to create a \nbetter separation of concerns, it might be better to separate home \ndocument and hints.\n",
          "createdAt": "2017-03-14T13:38:36Z",
          "updatedAt": "2017-03-14T13:38:36Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "MDU6SXNzdWUxNjE3MTM5ODk=",
      "title": "Drop URI Template Support",
      "url": "https://github.com/mnot/I-D/issues/193",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "this is a radical proposal but maybe will make it easier to proceed: i am not sure how many people need and use the descriptive structures for URI templates. these seem to introduce quite a bit of complexity in the draft, and maybe will only be used by a small fraction of users. having attempted describing URI templates myself (https://github.com/dret/I-D/tree/master/Abandoned/link-desc) i tend to think that this is a hard problem to get right, so maybe dropping them would speed up the development of the spec, not really impact many users, and make the spec considerably more simple to read and use?\n",
      "createdAt": "2016-06-22T15:29:43Z",
      "updatedAt": "2016-11-23T06:41:12Z",
      "closedAt": "2016-11-23T06:41:12Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "That means that you couldn't use json-home for generative URLs, which seems like a pretty big deal.\n",
          "createdAt": "2016-07-22T14:21:44Z",
          "updatedAt": "2016-07-22T14:21:44Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-07-22 07:21, Mark Nottingham wrote:\n\n> That means that you couldn't use json-home for generative URLs, which\n> seems like a pretty big deal.\n\ntrue. it just seems to me that defining the one description format for \ntemplate variables is not something that anybody so far has successfully \ndone. so maybe support templates yes, but stay away from also providing \nany description of the variables?\n\nat least for myself i can safely say that i have tried to come up with \nsuch a description format for quite a while, and it never seemed to make \na lot of sense as something to impose on all users of templates.\n\nbut then again, the latest draft does not really describe the variables, \nit simply maps the local template names to URIs, assuming that for \nthose, there might be some description (that's how i understand the \nmechanism). is that a general mechanism (mapping template-local vars to \nURIs) that people have been asking for? i am really just curious here as \nto where a good 80/20 balance is.\n",
          "createdAt": "2016-07-22T17:48:04Z",
          "updatedAt": "2016-07-22T17:48:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hm. Unknown for now -- would have to look at the proto-implementations to see what they're doing here (if at all). \n\nMore than anything, I just wanted to give the vars unique, global names. I agree that may not be enough motivation.\n",
          "createdAt": "2016-11-04T06:05:43Z",
          "updatedAt": "2016-11-04T06:05:43Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 23:05, Mark Nottingham wrote:\n\n> Hm. Unknown for now -- would have to look at the proto-implementations\n> to see what they're doing here (if at all).\n\nunderstood. and yes, it would be good to see how much URI template \nsupport is implemented and needed. without having any data i would guess \nthat the vast majority of use cases are not using them. but that's \nnothing but a guess.\n\n> More than anything, I just wanted to give the vars unique, global names.\n> I agree that may not be enough motivation.\n\nunderstood as well. and i think that's a very useful thing to do, i \ntoyed around with something similar. it does make implementing support \nfor home documents a bit harder, since URI template parsers may not be \nthat universally available.\n",
          "createdAt": "2016-11-04T08:00:03Z",
          "updatedAt": "2016-11-04T08:00:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "https://github.com/uri-templates/uritemplate-spec/wiki/Implementations\n",
          "createdAt": "2016-11-05T00:43:07Z",
          "updatedAt": "2016-11-05T00:43:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing for now, feel free to reopen if it's bugging you still.",
          "createdAt": "2016-11-23T06:41:12Z",
          "updatedAt": "2016-11-23T06:41:12Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "MDU6SXNzdWUxNjE3MjA3Mzc=",
      "title": "Inconsistency in JSON Home example?",
      "url": "https://github.com/mnot/I-D/issues/194",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "for the example shown in https://tools.ietf.org/html/draft-nottingham-json-home-03#section-2, is it an inconsistency that \"allow\" does not list POST, but that there is an \"accept-post\" hint?\n",
      "createdAt": "2016-06-22T15:56:31Z",
      "updatedAt": "2016-11-23T06:47:43Z",
      "closedAt": "2016-11-23T06:47:43Z",
      "comments": []
    },
    {
      "number": 196,
      "id": "MDU6SXNzdWUxNjQ0Mjc3Mzk=",
      "title": "Questions regarding h2_cache_digests",
      "url": "https://github.com/mnot/I-D/issues/196",
      "state": "CLOSED",
      "author": "nvwebd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "Hi to all that are following this spec.\n\nI would need some clarification on the hashing process:\n\nKey should be a SHA256 message digest expressed as integer...??? If I use the parseInt() - I'm dabling with a JavaScript Implementation - function to express the key in integer I get a biiiiIg exponential number. Am I thinking correctly?\n\nAnd then the second step with truncating the integer of SHA256 to calculated bits? Do I have to convert the SHA256 to bits?\n\nI'm a bit lost and need someone to shine some light for me.\n\nThanks to all!\n\nRegards,\n\nnVVEBd\n",
      "createdAt": "2016-07-07T23:13:01Z",
      "updatedAt": "2016-11-13T12:57:40Z",
      "closedAt": "2016-11-13T12:57:40Z",
      "comments": [
        {
          "author": "nvwebd",
          "authorAssociation": "NONE",
          "body": "It seems a bit hard to implement the hash-value 1/1 in JavaScript.\n\nSHA256 is represented with 256bits -> JavaScript can't handle more than 64bit floating point with 2^56 - 1 precision.\n\nI would like to know what do you think about this solution:\n- Representing the SHA as an ArrayBuffer and then add the buffer values to a variable to be represented as a Number -> converting the Number to binary and then doing the truncate.\n\nI don't see any other solutions to this. \n\nAny info would help me a lot...\n",
          "createdAt": "2016-07-13T23:19:20Z",
          "updatedAt": "2016-07-13T23:19:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What you should do is take the first `N + P` bits of the SHA output (i.e. the same way as is done in [RFC 2104 section 5](https://tools.ietf.org/html/rfc2104#section-5) or in [RFC 3874 section 2](https://tools.ietf.org/html/rfc3874#section-2).\n\nHow you would implement it depends on the output form of the SHA256 function you are using, and the maximum value of `N+P` that is going to be emitted by your implementation (the spec. allows the value to go up to 62, but an encoder can have its own restriction).\n\nThat said, assuming that your SHA function returns an ArrayBuffer of 32 octets, and your upper bound of `N+P` is less than 32, I believe the truncation code be written as simple as:\n\n```\nvar first32Bits = (new DataView(digest)).getUInt32(0);\n(first32Bits >> (32 - (N + P)) & ((1 << (N + P)) - 1)\n```\n\nNote that since `>>` operator of JavaScript converts the left-hand-side value to _signed_ int, you would need to mask the value as is done in the example.\n",
          "createdAt": "2016-07-14T00:16:12Z",
          "updatedAt": "2016-07-14T00:16:12Z"
        },
        {
          "author": "nvwebd",
          "authorAssociation": "NONE",
          "body": "I worked it out. \n\n@kazuho your solution was wrong I used : `let trunc = (f32bits & (Math.pow(2, thisBits)-1));`. But thanks for showing me the direction to go into.\n",
          "createdAt": "2016-07-14T23:24:35Z",
          "updatedAt": "2016-07-14T23:24:35Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nVVEBd Glad to hear.\n\n> @kazuho your solution was wrong I used : `let trunc = (f32bits & (Math.pow(2, thisBits)-1));`. But thanks for showing me the direction to go into.\n\nI am not sure how your implementation as a whole works, but if the URL is `https://example.com/style.css` and N+P is 12, then the expected hash value of the URL is 0xbaf (leftmost 12 bits of sha256(`https://example.com/style.css`).\n",
          "createdAt": "2016-07-15T00:57:31Z",
          "updatedAt": "2016-07-15T00:57:31Z"
        },
        {
          "author": "nvwebd",
          "authorAssociation": "NONE",
          "body": "Next questions: \n1. Let N be the count of URLs' members, rounded to the nearest power of 2 smaller than 2**32:\n   -> I have 4 members and the nearest is 2 - or should the rounding go up to 8? \n2. Let digest-value be an empty array of bits -> UInt32 ?\n3. Write log base2 of N to digest-value using 5bits -> I push this into the array as a byte with 5bits?\n",
          "createdAt": "2016-07-15T07:53:53Z",
          "updatedAt": "2016-07-15T07:53:53Z"
        },
        {
          "author": "nvwebd",
          "authorAssociation": "NONE",
          "body": "I figured out the way to implement the above questions but the last one remains:\n- Write R to digest-value as binary, using log2(P5) bits -> I get a float number 7.124124 -> do I round this number and then use the rounded value as bits?\n",
          "createdAt": "2016-07-19T13:10:57Z",
          "updatedAt": "2016-07-19T13:10:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing, as this is now in the httpwg repo.\n",
          "createdAt": "2016-11-13T12:57:40Z",
          "updatedAt": "2016-11-13T12:57:40Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "MDU6SXNzdWUxNjg0NzAxOTc=",
      "title": "Home implementation",
      "url": "https://github.com/mnot/I-D/issues/197",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "for tracking:\n  https://apidemo.w3ctag.org\n\ncc @plinss\n",
      "createdAt": "2016-07-30T14:34:09Z",
      "updatedAt": "2017-02-15T04:26:59Z",
      "closedAt": "2017-02-15T04:26:59Z",
      "comments": [
        {
          "author": "plinss",
          "authorAssociation": "NONE",
          "body": "Also:\nhttps://api.csswg.org/shepherd\n",
          "createdAt": "2016-07-30T14:35:15Z",
          "updatedAt": "2016-07-30T14:35:15Z"
        },
        {
          "author": "plinss",
          "authorAssociation": "NONE",
          "body": "Client implementation (used by Bikeshed):\nhttps://github.com/plinss/apiclient\n",
          "createdAt": "2016-07-30T14:36:17Z",
          "updatedAt": "2016-07-30T14:36:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "https://github.com/krainboltgreene/hsdk.js\r\n\r\ne.g., https://github.com/krainboltgreene/hsdk.js/blob/core/example/client.js",
          "createdAt": "2016-11-24T09:03:56Z",
          "updatedAt": "2016-11-24T09:03:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Now tracking here:\r\n  https://github.com/mnot/I-D/wiki/json-home",
          "createdAt": "2017-02-15T04:23:14Z",
          "updatedAt": "2017-02-15T04:23:14Z"
        }
      ]
    },
    {
      "number": 198,
      "id": "MDU6SXNzdWUxNjk4Nzc1OTU=",
      "title": "Different kinds of link relation types",
      "url": "https://github.com/mnot/I-D/issues/198",
      "state": "CLOSED",
      "author": "aef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "Since draft 4 you seem to have dropped any mention of classic link relation types and instead use URIs of the `tag` scheme now. How do these relate to the link relation types registered in the [IANA link relation type registry](http://www.iana.org/assignments/link-relations/link-relations.xhtml) and those classic custom link relation types that were defined as simple URIs of `http` scheme? Is there some kind of mapping necessary, or can all kinds be used in a JSON home document? If so, i think a mention and some examples about this would be very helpful.\n",
      "createdAt": "2016-08-08T09:18:46Z",
      "updatedAt": "2017-02-15T04:13:10Z",
      "closedAt": "2017-02-15T04:13:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Don't read too much into the examples -- I didn't use registered relation types because there wasn't a good example of one (and I suspect most APIs are going to be using api-specific ones).\n\nGenerally agree that the examples / supporting prose need more clarity though. Thanks!\n",
          "createdAt": "2016-08-11T03:51:00Z",
          "updatedAt": "2016-08-11T03:51:00Z"
        }
      ]
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWUxNjk4ODE0MjM=",
      "title": "Links to external sites (aka absolute URIs or network-path-references) in JSON home",
      "url": "https://github.com/mnot/I-D/issues/199",
      "state": "CLOSED",
      "author": "aef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "It seems that providing links to external sites (URIs that are not references to the context URI of the home document) is disallowed in JSON home.\n\nIs that really intentional? Why is that so?\n\nFor example, I would like to use a home document in one service to provide URIs and URI templates for its publicly exposed resources. Resources that are potentially mostly accessed by human users through a browser in the end. Another service could ask the first service for those URIs to display these to its human clients, so they can use the resources provided by the other service.\n\nA problem occurs now because all services are integrated into one single site for the human users. But each service owns his own site which is not publicly accessible. The services use these private sites to talk to each other. Providing links to the public site from a home document on one of the private sites seems to be disallowed by the current drafts.\n\nIs this a consequence of JSON home being tailored specifically for \"non-browser\" clients? If so, wouldn't it be a closer to the idea of REST to include all kinds of clients using the same URIs (but specific representations)? And shouldn't links to any site be allowed? If links to other sites are not allowed, is it still a \"web\" technology?\n",
      "createdAt": "2016-08-08T09:37:15Z",
      "updatedAt": "2016-08-11T08:14:34Z",
      "closedAt": "2016-08-10T23:37:31Z",
      "comments": [
        {
          "author": "aef",
          "authorAssociation": "NONE",
          "body": "Another example would be providing links to image resources on one site, but the images themselves are provided by an external CDN site.\n",
          "createdAt": "2016-08-09T14:13:38Z",
          "updatedAt": "2016-08-09T14:13:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "What text in the spec makes you believe this?\n",
          "createdAt": "2016-08-09T22:04:44Z",
          "updatedAt": "2016-08-09T22:04:44Z"
        },
        {
          "author": "aef",
          "authorAssociation": "NONE",
          "body": "In draft 4 it is in section 3 \"Resource Objects\" saying\n\n> In both forms, the links that \"href\" and \"href-template\" refer to are URI-references [RFC3986] whose base URI is that of the JSON Home Document itself.\n",
          "createdAt": "2016-08-10T13:22:03Z",
          "updatedAt": "2016-08-10T13:22:48Z"
        },
        {
          "author": "aef",
          "authorAssociation": "NONE",
          "body": "So this wasn't your intention. I guess I would have never thought about it meaning this if it said that \"In case it is a relative reference, the base URI is that of the JSON Home Document itself.\"\n",
          "createdAt": "2016-08-10T13:36:06Z",
          "updatedAt": "2016-08-10T13:36:06Z"
        },
        {
          "author": "aef",
          "authorAssociation": "NONE",
          "body": "Just to make it perfectly clear for everyone: You did not intend to limit linking to external sites in JSON home documents, right?\n",
          "createdAt": "2016-08-11T08:08:05Z",
          "updatedAt": "2016-08-11T08:08:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Correct.\n",
          "createdAt": "2016-08-11T08:14:34Z",
          "updatedAt": "2016-08-11T08:14:34Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "MDU6SXNzdWUxNjk5MDAxNzc=",
      "title": "Sets of link relation types",
      "url": "https://github.com/mnot/I-D/issues/200",
      "state": "CLOSED",
      "author": "aef",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "At least in HTML and the Link headers described in RFC 5988 it is possible to publish a link carrying a set of link relation types. Examples would be `rel=\"stylesheet alternate\"` or `rel=\"shortcut icon\"` (I am aware that there are issues about the meaning and formal specification of the `shortcut` link relation type). The current draft doesn't seem to explicitly describe how to handle such sets.\n\nCombining commonly known link relation types to form a meaningful predicate for a resource seems like a very good idea compared to defining new, complex link relation types for all kinds of resources. The former way at least theoretically allows clients with a basic knowledge of common link relation types to deduct the meaning of a resource (even when the meaning needs to be combined somehow), instead of requiring established knowledge of custom link relation types in use at a site before the client may know what a link is all about.\n\nSo have relation type sets been left out intentionally? If not, how are we supposed to handle these? Is there a specific lexical order expected so the JSON hash table based lookup doesn't fail if a set is given in a different order than was originally expected by a client?\n",
      "createdAt": "2016-08-08T11:21:58Z",
      "updatedAt": "2017-02-15T04:40:44Z",
      "closedAt": "2017-02-15T04:40:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "From 5988 Section 4:\r\n\r\n> Relation types SHOULD NOT infer any additional semantics based upon  the presence or absence of another link relation type, or its own cardinality of occurrence.  An exception to this is the combination of the \"alternate\" and \"stylesheet\" registered relation types, which has special meaning in HTML4 for historical reasons.",
          "createdAt": "2016-11-23T06:44:43Z",
          "updatedAt": "2016-11-23T06:44:43Z"
        },
        {
          "author": "aef",
          "authorAssociation": "NONE",
          "body": "I must have missed that part. Thank you very much for your clarification.",
          "createdAt": "2016-12-01T12:02:42Z",
          "updatedAt": "2016-12-01T12:02:42Z"
        }
      ]
    },
    {
      "number": 201,
      "id": "MDU6SXNzdWUxODI2MDI2MTc=",
      "title": "Relationship to JSON Hyper-Schema?",
      "url": "https://github.com/mnot/I-D/issues/201",
      "state": "CLOSED",
      "author": "handrews",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I apologize if this has been brought up and dismissed already- I don't see it as an issue but I have not scoured the internet for other discussions.\n\nHas there been any consideration to aligning the syntaxes of JSON Home and JSON Hyper-Schema as much as possible?  In particular, json-schema-org/json-schema-spec#52 (extended templating) defines a URI Template plus variable resolution syntax.  The variable resolution is set up to either allow resolution from an instance (by Relative JSON Pointer) or validating the value used for the variable (either by specifying a schema directly, or by using the schema referenced by the JSON Relative Pointer).  I'll note that Level 4 URI Templates are very useful in this context- I can go into detail with examples if needed.\n\nObviously JSON Home should not do JSON Schema-specific things, nor the other way around.  But as observed in json-schema-org/json-schema-spec#89 , the two proposal complement each other nicely and if we can do anything in either proposal to make the easy to use together that seems like a win.\n",
      "createdAt": "2016-10-12T18:45:01Z",
      "updatedAt": "2016-10-21T06:52:54Z",
      "closedAt": "2016-10-21T06:52:54Z",
      "comments": [
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "Based on discussions on the hyper-schema side, I don't think there's a ton of interest in doing anything about this.   Closing to reduce clutter, can always be opened again if interest grows.\n",
          "createdAt": "2016-10-21T06:52:54Z",
          "updatedAt": "2016-10-21T06:52:54Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWUxODU0MzMwNTQ=",
      "title": "Can/should extended link relations resolve to resource objects?",
      "url": "https://github.com/mnot/I-D/issues/202",
      "state": "CLOSED",
      "author": "conzett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "I stumbled on json-home while looking for a way to describe extended link relations as part of a hypermedia API per RFC5988. It looks like the scope is just to describe the entire application structure at the root of the API (hence \"home\") however, it seems like parts of the specification could be very useful for providing documentation about relations deeper in the API.\n\nFor example, if I've navigated to URI `http://example.org/foos/45` and I am presented with a link relation `rel=\"http://example.org/rel/widgets\"` (either as a LINK header, HAL body, etc.) it seems pretty useful to be able to resolve that relation URI to [a single resource object](https://mnot.github.io/I-D/json-home/#rfc.section.3) in order to provide \"a definition of the semantics of the relation type.\"\n\nIs this reasonable or totally beyond the scope of what json-home is trying to do? Describing the entire structure up front only seems a little at odds with \"discoverability,\" but even if it's not is there any downside to providing additional contextual definitions in the form of resource objects?\n",
      "createdAt": "2016-10-26T15:45:49Z",
      "updatedAt": "2016-11-23T13:46:03Z",
      "closedAt": "2016-11-23T06:47:18Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I hadn't really considered using it in this manner; it feels like you're talking about a sort of a RESTish version of an [EPR](https://www.w3.org/Submission/ws-addressing/#_Toc77464317) (which causes me to question some of my life choices).\n\n/cc @dret \n",
          "createdAt": "2016-11-03T06:44:53Z",
          "updatedAt": "2016-11-03T06:44:53Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i do not think that the idea of home is to \"describe the entire structure\". think of it rather than of a well-designed home page of a site: it has the most popular entry points to paths through the site, but is nowhere near to being a complete site map.\n\nwhen it comes to the dereferencing extended link relations: i do not think that JSON home has anything to do with that. if that's a pattern you'd like to follow (some people do it, not very many, though), then you can do that. if you not only want to interpret extended link relation as URIs, but also make them discoverable as resources (if i am understanding correctly what you want to do), then i think neither RFC 5988 nor JSON home give you the expressivity you want.\n\nif that is what you want to do, then isn't what you need a link relation that (and i am sorry for this confusing twist but it's unavoidable) would allow you to say \"this link relation identifies links to resources which themselves are used as link relation types.\" i do not think i have seen such a link relation being defined or used, afaict the people interested in using link relation URIs as identifiers for resources describing the link relations simply tend to do so and then assume that clients know about this.\n\nam i even close to understanding your question? if not, please rephrase a bit. thanks!\n",
          "createdAt": "2016-11-03T13:52:16Z",
          "updatedAt": "2016-11-03T13:52:16Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "> i do not think that the idea of home is to \"describe the entire structure\".\n\nI also don't view json-home as a replacement for [Sitemap](https://en.wikipedia.org/wiki/Sitemaps).\n\n> this link relation identifies links to resources which themselves are used as link relation types\n\nThat's a way JSON-LD (RDF) is used, isn't it? Every property in your JSON is a word in a vocabulary such as [schema.org](http://schema.org/), identifiable by its own URI. By using URIs to identify both the subject, the adjective and the verb of what you're modelling in your resources, you pretty much have the RDF triplet right there.\n",
          "createdAt": "2016-11-03T13:59:01Z",
          "updatedAt": "2016-11-03T13:59:01Z"
        },
        {
          "author": "conzett",
          "authorAssociation": "NONE",
          "body": "> when it comes to the dereferencing extended link relations: i do not think that JSON home has anything to do with that.\n\nI agree -  sorry if I wasn't very clear in my original issue. I was referring only to the [Resource Object](https://mnot.github.io/I-D/json-home/#rfc.section.3) concept discussed within the JSON Home draft spec.\n\n> isn't what you need a link relation that (and i am sorry for this confusing twist but it's unavoidable) would allow you to say \"this link relation identifies links to resources which themselves are used as link relation types.\"\n\nIt took me a second, but that does make sense \ud83d\ude00 . In this case I'm working on a [HAL-based API](https://tools.ietf.org/html/draft-kelly-json-hal-08) which encourages Custom link relation types to [\"be URIs that when dereferenced in a web browser provide relevant documentation\"](https://tools.ietf.org/html/draft-kelly-json-hal-08#section-8.2). I'm looking to expand that documentation with additional media types beyond HTML to provide a more machine readable format and thought that the Resource Objects might be a good representation for that.\n",
          "createdAt": "2016-11-03T15:01:26Z",
          "updatedAt": "2016-11-03T15:01:26Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 08:01, Graham Conzett wrote:\n\n> ```\n> when it comes to the dereferencing extended link relations: i do not\n> think that JSON home has anything to do with that.\n> ```\n> \n> I agree - sorry if I wasn't very clear in my original issue. I was\n> referring only to the Resource Object\n> https://mnot.github.io/I-D/json-home/#rfc.section.3 concept discussed\n> within the JSON Home draft spec.\n\ni'll leave the authoritative answer to @mnot. in the end, i wouldn't \nread too much into the name or the concept. it's simply the name \nassociated to _any_ resource made available through JSON home. i am not \nsure it is even necessary to define this term, but that's simply how the \ndraft is currently doing it.\n\nthe main point behind the concept is that it allows these resource \nobjects to be one of two things: a resource, or a set of resources made \navailable through a URI template. in other words, anything that is _not_ \na URI template is a \"resource object\", but keep in mind that the \n\"resource object\" (as i have come to read the spec) simply refers to the \n_object in the JSON home structure that links to a resource_. so in the \nend, the term _object_ here only refers to the fact that the resource \nhappens to be identified through a _JSON object_.\n\nthis terminology is a bit unfortunate for other ways of communicating \nthe JSON home model, such as in XML \n(https://tools.ietf.org/html/draft-wilde-home-xml), because there the \n\"resource object\" happens to be an XML element, and the _object_ part of \nthe term just gets in the way.\n\nregardless of these \"spec engineering\" issues: do not read too much into \nthe term _resource object_: it simply is JSON home's way of linking to a \nresource.\n\n> ```\n> isn't what you need a link relation that (and i am sorry for this\n> confusing twist but it's unavoidable) would allow you to say \"this\n> link relation identifies links to resources which themselves are\n> used as link relation types.\"\n> ```\n> \n> It took me a second, but that does make sense \ud83d\ude00 . In this case I'm\n> working on a HAL-based API\n> https://tools.ietf.org/html/draft-kelly-json-hal-08 which encourages\n> Custom link relation types to \"be URIs that when dereferenced in a web\n> browser provide relevant documentation\"\n\ni am glad i was on the right track!\n\n> https://tools.ietf.org/html/draft-kelly-json-hal-08#section-8.2. I'm\n> looking to expand that documentation with additional media types beyond\n> HTML to provide a more machine readable format and thought that the\n> Resource Objects might be a good representation for that.\n\ni don't think that resource objects are what you think they are, as i \nthink that you are looking for something else entirely.\n\nas @asbjornu pointed out, if you want to to RDF-ish kinds of things, \nsimply do it an run with it. neither RFC 5988 not JSON home are intended \nor designed to help or interfere with that.\n\nthe important (and confusing) part of this is that true hypermedia \ndistinguishes between links and identifiers. links are typed and \nnavigable interrelations that are explicitly identified as such in \nhypermedia formats.\n\nRDF has no such concept: RDF has no concept of links, all URIs are \nopaque identifiers. Linked Data (tm) then takes the other extreme and \nsays that _all_ identifiers/URIs should be treated as links. again, \nthere is no ability to distinguish between identifiers and links. that's \nwhat throws off many people, and maybe that's at the heart of your \nscenario. if it is, then you first and foremost have to decide if you \nwant to do hypermedia, or RDF/LinkedData. these are two different ways \nin which you can approach representing data and services.\n",
          "createdAt": "2016-11-03T15:20:49Z",
          "updatedAt": "2016-11-03T15:20:49Z"
        },
        {
          "author": "conzett",
          "authorAssociation": "NONE",
          "body": "@dret Thank you for the detailed reply! That clarifies terminology and focus of what JSON Home is trying to accomplish.\n\nAs a point of clarification (and I'm hopefully not drifting too far off topic here) when I mentioned RFC 5988 I was referencing [section 4.2](https://tools.ietf.org/html/rfc5988#section-4.2) specifically which says (emphasis added)\n\n> Applications that don't wish to register a relation type can use an\n>    extension relation type, which is a URI [RFC3986] that uniquely\n>    identifies the relation type.  Although the URI _**can point to a\n>    resource that contains a definition of the semantics of the relation\n>    type**_, clients SHOULD NOT automatically access that resource to avoid\n>    overburdening its server.\n\nSo while a custom link relation should be treated as an opaque identifier it seems to imply that optionally dereferencing the URI is acceptable on some level (I'm not using RDF currently).\n\nI guess what I'm really looking for is an existing media type that can describe the relation when the URI is dereferenced.\n",
          "createdAt": "2016-11-03T16:21:51Z",
          "updatedAt": "2016-11-03T16:21:51Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@dret -- \n\nRDF is a Language. It only prescribes the use of IRIs to identify the subject, predicate, and object (optionally) of RDF-Language sentences. \n\nLinked Data is simply about the \"best practice\" of using HTTP URIs to identify the subject, predicate, and object (optionally) of RDF-Language sentences. \n\nIf you create a document containing RDF-Language sentences, that adheres to  Linked Data principles, you end up with a hypermedia document (or resource). Note, that's achievable using a variety of sentence construction notations e.g., RDF-Turtle, JSON-LD, RDF-XML, CSV, and many others. \n\n@conzett -- You are correct in your assumptions about a link relation i.e., a relation identified by a hyperlink (e.g., HTTP URI). When said hyperlink is de-referenced it will resolve to a document that describes its semantics (meaning). \n\nSimple demonstration (best experienced via our [Structured Data Sniffer Extension](http://osds.openlinksw.com)):\n\n{ \n <#this> \n  a schema:WebPage ;\n  schema:name \"Can/should extended link relations resolve to resource objects?\" ;\n  schema:mainEntity `<https://twitter.com/hashtag/Hypermedia#this>`;\n  schema:mentions [\n  schema:mainEntityOf `<http://linkeddata.uriburner.com/describe/?url=https%3A%2F%2Ftwitter.com%2Fhashtag%2FHypermedia%23this>`], `<https://twitter.com/hashtag/LinkedData#this>, <http://osds.openlinksw.com/#this>` ;\n schema:mainEntityOfPage `<https://www.pinterest.com/pin/389561436502925516/>` ;\nschema:image `<https://s-media-cache-ak0.pinimg.com/originals/8f/e6/09/8fe6098b72c1b2a88f89eaf178edbd8f.png>` .\n\n`<https://twitter.com/hashtag/Hypermedia#this>` \nschema:name \"Hypermedia\" ;\nschema:sameAs dbpedia:Hypermedia .\n}\n\nIn the example above, you can look-up the semantics of relations such as schema:sameAs, schema:mentions, schema:mainEntity, schema:mainEntityOfPage, schema:name, or schema:image by simply clicking on the links by which they've identified. \n",
          "createdAt": "2016-11-03T16:55:24Z",
          "updatedAt": "2016-11-07T18:46:20Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 09:21, Graham Conzett wrote:\n\n> As a point of clarification (and I'm hopefully not drifting too far off\n> topic here) when I mentioned RFC 5988 I was referencing section 4.2\n> https://tools.ietf.org/html/rfc5988#section-4.2 specifically which\n> says (emphasis added)\n> \n> ```\n> Applications that don't wish to register a relation type can use an\n> extension relation type, which is a URI [RFC3986] that uniquely\n> identifies the relation type. Although the URI /*can point to a\n> resource that contains a definition of the semantics of the relation\n> type*/, clients SHOULD NOT automatically access that resource to avoid\n> overburdening its server.\n> ```\n> \n> So while a custom link relation should be treated as an opaque\n> identifier it seems to imply that optionally dereferencing the URI is\n> acceptable on some level (I'm not using RDF currently).\n> I guess what I'm really looking for is an existing media type that can\n> describe the relation when the URI is dereferenced.\n\n\"describe the relation when the URI is dereferenced\" is probably not \nexactly what you want to say there (my apologies for trying to channel \nyou). i am guessing that you either want to _describe the link relation \nas a dereferencable one_, and/or want to _define which media type to \nexpect when you're dereferencing such a dereferencable link relation_.\n\nRFC 5988 says link relation identifiers are opaque. end of story. there \nmay be some context somewhere that goes beyond that and says that these \nidentifiers can be meaningfully dereferenced, and what to expect if you \ndo that, but that is simply acknowledged in the spec and simply out of \nscope.\n\ni think what you _might_ be looking for (as mentioned in an earlier \ncomment) is a link relation that allows you to identify a link relation. \ni am not aware of such a link relation, but if you find one, let us \nknow, and maybe it would be worth registering (unless it itself is a \nURI-identified link relation in which case it is by definition an \nextension link relation and cannot be registered).\n\none place worth looking might be the hydra vocabulary, but you probably \nonly want to go this route if you're doing something RDF-ish. if you do, \nit may be worth a look.\n",
          "createdAt": "2016-11-03T17:47:48Z",
          "updatedAt": "2016-11-03T17:47:48Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> RFC 5988 says link relation identifiers are opaque. end of story.\n\nI'm not sure we're all interpreting \"opaque\" the same way, then, and I feel like I'm missing something.\n\nSince the RFC specifically allows that the identifiers might be meaningfully dereferenced, that is not the same (to me) as saying that they are completely opaque tokens.  It allows that you may be able to do something with them.  It just doesn't impose any requirements on whoever created the URI to support any such thing.  To me, \"opaque\" means that the identifier might as well be random gibberish.\n\nThere's some sort of subtle distinction here that I think I'm not quite getting.\n",
          "createdAt": "2016-11-03T18:01:57Z",
          "updatedAt": "2016-11-03T18:01:57Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 11:01, Henry Andrews wrote:\n\n> ```\n> RFC 5988 says link relation identifiers are opaque. end of story.\n> ```\n> \n> I'm not sure we're all interpreting \"opaque\" the same way, then, and I\n> feel like I'm missing something.\n> Since the RFC specifically allows that the identifiers might be\n> meaningfully dereferenced, that is not the same (to me) as saying that\n> they are completely opaque tokens. It allows that you may be able to do\n> something with them. It just doesn't impose any requirements on whoever\n> created the URI to support any such thing. To me, \"opaque\" means that\n> the identifier might as well be random gibberish.\n\nthe spec simply says it needs to be a URI, and that the only \"meaning\" \nof that URI is its given value. so you can use \"tag:42\" as a link \nidentifier (not a great idea, i'd say, but perfectly fine in the context \ngiven by RFC 5988). it's not completely random gibberish, but also not \nsomething that has any meaning when looked at out of context.\n\n> There's some sort of subtle distinction here that I think I'm not quite\n> getting.\n\nwe have this tendency to think that a URI is something beyond its pure \nvalue. that is not always the case. if you say (like RFC 5988 does) that \nin some context you expect a URI, but all you need it to be is to be a \nURI, then it simply is a \"by value\" identifier (i.e., the only \nmeaningful operation _in that context_ is to compare identifier values), \nand not a \"by reference\" identifier.\n",
          "createdAt": "2016-11-03T18:09:12Z",
          "updatedAt": "2016-11-03T18:09:12Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> in some context you expect a URI, but all you need it to be is to be a\n> URI, then it simply is a \"by value\" identifier (i.e., the only\n> meaningful operation _in that context_ is to compare identifier values),\n> and not a \"by reference\" identifier.\n\nThen why talk about what it might reference?\n",
          "createdAt": "2016-11-03T18:10:49Z",
          "updatedAt": "2016-11-03T18:10:49Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "To be clear, I'm not looking to assert that URIs used for identification purposes should be automatically dereferencable, that is clearly against the RFC.  I'm trying to figure out the point of both saying \"this is what it should point to if it points to anything\" and then completely refusing to allow that it _might_ point to something, which is what this feels like.\n",
          "createdAt": "2016-11-03T18:13:08Z",
          "updatedAt": "2016-11-03T18:13:08Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 11:10, Henry Andrews wrote:\n\n> ```\n> in some context you expect a URI, but all you need it to be is to be a\n> URI, then it simply is a \"by value\" identifier (i.e., the only\n> meaningful operation /in that context/ is to compare identifier values),\n> and not a \"by reference\" identifier.\n> ```\n> \n> Then why talk about what it might reference?\n\nare you talking about the RFC 5988 text here? RFC 5988 simply \nacknowledges the fact that somebody might be doing this, but itself \ndefines things so that you're not doing it. it does so just to say that \nclients should not blindly attempt to dereference URIs. i think the main \npain point it addressed was the \"HTML4 DTD\" problem and similar \nscenarios in which clients blindly dereferenced URIs, whether it was \nnecessary or not, and created problems for those hosting those URIs.\n\nbut we're drifting pretty far away from the original issue here.\n",
          "createdAt": "2016-11-03T18:17:00Z",
          "updatedAt": "2016-11-03T18:17:00Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-03 11:13, Henry Andrews wrote:\n\n> To be clear, I'm not looking to assert that URIs used for identification\n> purposes should be automatically dereferencable, that is clearly against\n> the RFC. I'm trying to figure out the point of both saying \"this is what\n> it should point to if it points to anything\" and then completely\n> refusing to allow that it /might/ point to something, which is what this\n> feels like.\n\nit does not refuse that at all. it simple is agnostic about that part, \nand says that clients should be careful when making such an assumption.\n",
          "createdAt": "2016-11-03T18:18:05Z",
          "updatedAt": "2016-11-03T18:18:05Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@conzett :\n\nExcerpting what @dret stated in his comment i.e., \"\"describe the relation when the URI is dereferenced\" is probably not\nexactly what you want to say there (my apologies for trying to channel\nyou). i am guessing that you either want to _describe the link relation\nas a dereferencable one_, and/or want to _define which media type to\nexpect when you're dereferencing such a dereferencable link relation_.\"\n\nDo you want to achieve the following? \nIdentify a Relation (a/k/a Entity Relationship Type)  using an HTTP URI such that any agent (machine or human) can lookup its description. The description in question, could take the form of a collection of RDF-Language sentences in a document. \n\nNaturally, in regards to the statement above, the document content type (or media type) may vary e.g., JSON, JSON-LD, RDF-Turtle, RDF-XML, CSV, or many others (each has an IANA media type). If so, then you have a working example in the document identified by the HTTP URI: https://github.com/mnot/I-D/issues/202#issuecomment-258204118 :) \n",
          "createdAt": "2016-11-03T18:19:11Z",
          "updatedAt": "2016-11-03T18:19:11Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@handrews : You are correct about identifier opacity. Confusion arises when HTTP URIs as used as Identifiers due to their implicit duality i.e., they serve two functions: 1) entity denotation 2) resolution to connotation (i.e., name->entity-description-document-address indirection). \n\nWhenever you encounter Linked Data for instance, it simply boils down to exploiting the aforementioned duality combined with the ubiquity of HTTP en route to a Semantic Web -- where the meaning of relations (links) become discernible by way of dereference :) \n",
          "createdAt": "2016-11-03T18:28:13Z",
          "updatedAt": "2016-11-03T18:28:13Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@kidehen Yeah I think we're on the same page.  @dret I don't think that the RFC refuses that, but your statement seemed to.  It's clear to me at this point that that was not your intention.  I still don't get why the RFC talks about what the referenced resource might be, but that's not a JSON Home issue so I'll go ponder it somewhere else :-)\n",
          "createdAt": "2016-11-03T18:35:13Z",
          "updatedAt": "2016-11-03T18:35:13Z"
        },
        {
          "author": "conzett",
          "authorAssociation": "NONE",
          "body": "Bringing this back around (after digesting everyone's comments) perhaps JSON home _would_ help me here.\n\nIf the preference is to not dereference link extension URIs for documentation, I need some place where I can provide additional information about the link. Things like URL template parameters and general documentation. I'm struggling with where that information would reside currently.\n",
          "createdAt": "2016-11-03T18:41:18Z",
          "updatedAt": "2016-11-03T18:41:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On Nov 3, 2016, at 11:41, Graham Conzett notifications@github.com wrote:\n> Bringing this back around (after digesting everyone's comments) perhaps JSON home would help me here. If the preference is to not dereference link extension URIs for documentation, I need some place where I can provide additional information about the link. Things like URL template parameters and general documentation. I'm struggling with where that information would reside currently.\n\nmaybe https://tools.ietf.org/html/draft-wilde-service-link-rel can help?\n",
          "createdAt": "2016-11-03T18:46:40Z",
          "updatedAt": "2016-11-03T18:46:40Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@conzett :  If you choose to follow Linked Data principles you will find that location becomes less of an issue for documents that describe entity relationship types (relations) that you identify using HTTP URIs (hyperlinks). For instance, using [nanotation](http://kidehen.blogspot.com/2014/07/nanotation.html), you can even use a Github post to hold your relation descriptions . \n\nSeeAlso: https://medium.com/openlink-software-blog/data-de-silo-fication-using-combined-power-of-rdf-language-nanotation-755f2e7a904d -- detailed examples of other notes-oriented data spaces as places to exploit Linked Data using nanotation. \n",
          "createdAt": "2016-11-03T21:33:58Z",
          "updatedAt": "2016-11-03T21:33:58Z"
        },
        {
          "author": "conzett",
          "authorAssociation": "NONE",
          "body": "@dret That looks promising, thank you! Now I just need to find a suitable media type for the machine consumable representation of the documentation resource.\n\n@kidehen How can I use your example for say, describing a resource and various URI parameters that can be used with it?\n",
          "createdAt": "2016-11-03T22:38:15Z",
          "updatedAt": "2016-11-03T22:38:15Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@conzett: Have you looked at [Hydra](http://www.hydra-cg.com/)? It has the hypermedia (linked data) functionality you seem to be looking for as well as the ability to describe operations, expected input parameters, data types, etc. \n",
          "createdAt": "2016-11-03T22:55:11Z",
          "updatedAt": "2016-11-03T22:55:11Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@conzett JSON Schema / Hyper-Schema?\n",
          "createdAt": "2016-11-03T23:00:21Z",
          "updatedAt": "2016-11-03T23:00:21Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@conzett : I have a few posts that describe the use of RDF-Language sentences to describes Web Service APIs and the Actions they provide:\n\n[1] https://medium.com/virtuoso-blog/describing-web-services-using-a-linked-data-doc-using-schema-org-terms-6caa399fc97a  -- Describing Web Services using terms from Schema.org vocabulary\n\n[2] https://medium.com/virtuoso-blog/api-descriptions-for-humans-machines-ec04ce1d1a9a -- Here I demonstrate description of Uber APIs that were originally described using Swagger.\n\n@conzett @handrews : If you follow the links that identify relations in my descriptions you will also see how integration with Hydra occurs. The key here is to be able to simply click on a link whenever you are curious about what an HTTP URI identifies. \n",
          "createdAt": "2016-11-04T01:14:02Z",
          "updatedAt": "2016-11-04T01:14:02Z"
        },
        {
          "author": "conzett",
          "authorAssociation": "NONE",
          "body": "@asbjornu I was very interested in Hydra before I started down this path but unfortunately I need to support some kind of XML format in addition to JSON. It looks like it could potentially be used with RDF/XML but I haven't seen any solid examples of that.\n",
          "createdAt": "2016-11-04T18:06:28Z",
          "updatedAt": "2016-11-04T18:06:28Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@conzett -- You can transform content of an RDF-Turtle or JSON-LD document into RDF-XML. Those notations and document content types have no bearing on terms defined in an Ontology or Vocabulary such as Hydra.  There are many tools that offer automatic content transformation circa., 2016 which means the document type used to publish an ontology or vocabulary shouldn't be an impediment to comprehension and use :) \n",
          "createdAt": "2016-11-04T19:29:07Z",
          "updatedAt": "2016-11-04T19:29:07Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2016-11-04 11:06, Graham Conzett wrote:\n\n> @asbjornu https://github.com/asbjornu I was very interested in Hydra\n> before I started down this path but unfortunately I need to support some\n> kind of XML format in addition to JSON. It looks like it could\n> potentially be used with RDF/XML but I haven't seen any solid examples\n> of that.\n\ndon't fall into the trap of thinking that RDF/XML qualifies as an \"XML \nformat\". it makes sense to use it for RDF tool chains that support or \nneed RDF/XML as an RDF serialization. but RDF/XML is useless if you want \nto support XML tool chains that need information to be readily available \nat the XML level.\n",
          "createdAt": "2016-11-08T23:06:42Z",
          "updatedAt": "2016-11-08T23:06:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing because AFAICT there isn't any action for the spec here. But feel free to keep chatting :)",
          "createdAt": "2016-11-23T06:47:18Z",
          "updatedAt": "2016-11-23T06:47:18Z"
        },
        {
          "author": "kidehen",
          "authorAssociation": "NONE",
          "body": "@mnot : Yes, I agree. \r\n\r\nFundamentally, an IRI is an acceptable value. If the resource owner wants said IRI to resolve to a document that describes what it denotes (i.e., its referent) then an HTTP URI can be used, in line with the principles outlined in the \"Linked Data\" meme. \r\n\r\nIn a nutshell, \"horses for courses\" :) ",
          "createdAt": "2016-11-23T13:46:03Z",
          "updatedAt": "2016-11-23T13:46:03Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWUxODg3MjA2NDY=",
      "title": "Performance of Cache Digests",
      "url": "https://github.com/mnot/I-D/issues/204",
      "state": "CLOSED",
      "author": "sebdeckers",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just implemented the spec (which was a lovely exercise) and had some thoughts on how to improve performance of the CD algorithm. Apologies if I misunderstood some parts of the spec or the authors' intentions.\r\n\r\n### De-dupe URLs before hashing them\r\n- Wastes time sorting and skipping through the list in a later stage.\r\n- Inflates value of `N`, needlessly increasing size of the entire digest.\r\n\r\n### Trim URL origin\r\n- Every URL has identical origin. Hashing this repetitive data is wasted effort.\r\n\r\n### SHA256 is overkill\r\n- Use a fingerprinting algorithm for better performance. See: https://github.com/rurban/smhasher\r\n- Spec limits `hashValue` to 62 bits so why generate 256 bits? Lots of algos return 64 bits which minimises waste.",
      "createdAt": "2016-11-11T09:38:06Z",
      "updatedAt": "2016-11-13T15:24:21Z",
      "closedAt": "2016-11-13T05:54:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See - https://github.com/httpwg/http-extensions\n",
          "createdAt": "2016-11-13T05:54:28Z",
          "updatedAt": "2016-11-13T05:54:28Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "Thanks @mnot \ud83d\udc4d\n\nI see interesting discussion on the hashing algo choice in https://github.com/httpwg/http-extensions/issues/228 It would perhaps be useful to run some benchmarks on real( world|istic) data to check whether hashing performance is really an issue. Will see what I can dig up and share any findings.\n",
          "createdAt": "2016-11-13T15:24:21Z",
          "updatedAt": "2016-11-13T15:24:21Z"
        }
      ]
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWUxODg5MDYwMzY=",
      "title": "Typo in draft-kazuho-h2-cache-digest-01",
      "url": "https://github.com/mnot/I-D/issues/205",
      "state": "CLOSED",
      "author": "sebdeckers",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "#### 2.2.1.  Querying the Digest for a Value\r\n```\r\n[...]\r\n   5.   Read '0' bits from \"digest-value\" until a '1' bit is found; let\r\n        \"Q\" bit the number of '0' bits.  Discard the '1'.\r\n```\r\n\r\nShould be:\r\n> let \"Q\" **be** the number of '0' bits.",
      "createdAt": "2016-11-12T11:04:59Z",
      "updatedAt": "2016-11-13T05:54:17Z",
      "closedAt": "2016-11-13T05:54:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Wrong repo - this has moved to https://github.com/httpwg/http-extensions\n",
          "createdAt": "2016-11-13T05:54:17Z",
          "updatedAt": "2016-11-13T05:54:17Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWUxOTEyMDU4MjQ=",
      "title": "Rate limiting",
      "url": "https://github.com/mnot/I-D/issues/206",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "resource hint",
      "createdAt": "2016-11-23T07:46:16Z",
      "updatedAt": "2017-02-15T04:39:03Z",
      "closedAt": "2017-02-15T04:39:03Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "... should be defined as an extension, since the core semantics aren't yet standardised.",
          "createdAt": "2017-02-15T04:39:03Z",
          "updatedAt": "2017-02-15T04:39:03Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWUxOTEyMDU4Njg=",
      "title": "POST to 201 (Created) pattern",
      "url": "https://github.com/mnot/I-D/issues/207",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "",
      "createdAt": "2016-11-23T07:46:31Z",
      "updatedAt": "2017-02-15T04:48:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Not sure what needs to be in the home document for this. The resulting URL is under control of the server, so shouldn't be exposed here. The media type(s) created *could* be exposed as a resource hint, I suppose; .e.g.,\r\n\r\n    \"postCreates\": [ \"application/foo\", \"text/bar\" ]\r\n\r\nor similar.",
          "createdAt": "2017-02-15T04:48:20Z",
          "updatedAt": "2017-02-15T04:48:20Z"
        }
      ]
    },
    {
      "number": 208,
      "id": "MDU6SXNzdWUxOTEyMDU5NDY=",
      "title": "Extensibility",
      "url": "https://github.com/mnot/I-D/issues/208",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "resource hints\r\nresource object properties\r\netc",
      "createdAt": "2016-11-23T07:47:06Z",
      "updatedAt": "2017-02-15T04:42:22Z",
      "closedAt": "2017-02-15T04:42:22Z",
      "comments": []
    },
    {
      "number": 209,
      "id": "MDU6SXNzdWUxOTEyMDU5Nzc=",
      "title": "Include?",
      "url": "https://github.com/mnot/I-D/issues/209",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "",
      "createdAt": "2016-11-23T07:47:21Z",
      "updatedAt": "2017-02-15T03:49:34Z",
      "closedAt": "2017-02-15T03:49:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Having an include facility increases complexity, and it's not clear it's necessary (since it can always be composed server-side). It also can increase latency (although there are mitigations like server push). \r\n\r\nClosing this with no action. If you have an urgent use case for include, please do mention it.",
          "createdAt": "2017-02-15T03:49:34Z",
          "updatedAt": "2017-02-15T03:49:34Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "MDU6SXNzdWUxOTE0NjU0NzM=",
      "title": "Suggestion: use an existing API spec format for the API description",
      "url": "https://github.com/mnot/I-D/issues/210",
      "state": "CLOSED",
      "author": "ivan-novakov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Having a standard for API \"home\" is not a bad idea really. But I would reconsider, whether not to use an existing API description format like Swagger, API Blueprint, RAML, etc.\r\n\r\nThe advantage is clear:\r\n- no need to reinvent the wheel\r\n- much larger community\r\n- existing ecosystem of tools & parsers\r\n\r\nIn fact, this standard may support various API specification formats. The client application can then choose the right one through content negotiation.",
      "createdAt": "2016-11-24T09:03:13Z",
      "updatedAt": "2016-11-24T09:54:10Z",
      "closedAt": "2016-11-24T09:54:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "The use cases aren't the same. The main target here is defining extensible, evolvable, standard HTTP APIs (e.g., by IETF Working Groups). Swagger et al are much more focused on delivering one-off, single instance APIs a la Twitter et al. \r\n\r\nLike @dret said in another issue just now, that doesn't mean that you can't link to swagger et al. from home doc.",
          "createdAt": "2016-11-24T09:54:10Z",
          "updatedAt": "2016-11-24T09:54:10Z"
        }
      ]
    },
    {
      "number": 211,
      "id": "MDU6SXNzdWUyMDk5NjU5Mzc=",
      "title": "link hints",
      "url": "https://github.com/mnot/I-D/issues/211",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "See also #55 and #192 \r\n\r\nThis issue is for general discussion about a standalone concept of \"link hints.\"",
      "createdAt": "2017-02-24T05:52:46Z",
      "updatedAt": "2018-03-27T06:41:02Z",
      "closedAt": "2018-03-27T02:49:21Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "For background - the current approach to target attributes (which are effectively link hints) in the proposed RFC5988bis document is that they can be defined by one of:\r\n\r\n* The link serialisation\r\n* The link relation type itself\r\n\r\nSo, e.g., HTML can define some that apply to all links (and it does), and individual link relations can define additional ones (and they do).\r\n\r\nAFAICT the ideas behind doing more (probably in a separate spec) are coming from roughly two directions:\r\n\r\n**1. Discomfort that there is potential for conflict/semantic duplication**. E.g., two serialisations might define conflicting attributes, or a relation type's attribute might be subsumed by that defined by a serialiation.\r\n\r\nThe counterargument is that we've got this far without this being a significant problem. I think that's largely because there are a couple of \"big\" serialisations (HTML and Atom), and their set of target attributes are relatively well-known and stable.\r\n\r\nIf we had a galaxy of serialisations with a number of potential conflicts, I could see how that would be annoying, but even then, a new serialisation could take steps to isolate its target attributes from those of the link relation types used in it. \r\n\r\nRegarding conflicts between target attributes defined by serialisations themselves -- again, it may be a bit annoying, but I don't see big interop problems here. \r\n\r\n**2. Reuse.** If I go to the trouble of defining a target attribute for one relation type (or serialisation), it'd be really nice if it was usable with others. \r\n\r\nThe counterargument here is that they are; you just need to reference the defined target attribute in the definition of your relation type / link serialisation, or copy it (but probably reference).\r\n\r\nAllowing a third party to add semantics (even if just hints) to an existing serialisation or relation type without coordination seems suboptimal, especially if they change the semantics of the link (e.g., overloading how the client interacts with the server). \r\n\r\nAnything else? Please feel free to add / challenge / etc., I'm just trying to summarise my current thinking.\r\n\r\nAlso, please note I'm not against a given serialisation defining its own concept of link hints, or even a generic concept of link hints w/ a registry that serialisations and/or relation types opt into in their definitions; I just don't want to make it a blanket thing.\r\n\r\nSo, I think it's out of scope for RFC5988bis (as discussed in #36). Regarding json-home, it feels premature to split out the link hints for that format into a generic solution for other serialisations. \r\n\r\ncc @dret",
          "createdAt": "2017-02-24T06:16:42Z",
          "updatedAt": "2017-02-24T06:16:42Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@mnot I'm trying to figure out how to best relate this to JSON Hyper-Schema and its Link Description Object (LDO) which is its link serialization mechanism.  \r\n\r\nMy main question is:  should URI scheme/protocol specific things, such as an \"allow\" hint corresponding to the HTTP `Allow` header, be part of this discussion?\r\n\r\nI feel like these are demanded primarily by people writing full API description formats that want all possible information presented from design-time.  Hypermedia-driven systems could make some use of these but it feels like less of a match.  A link hints standard could provide some guidance on whether and how to include these sorts of hints when designing link serialization formats.\r\n\r\n----\r\n\r\nFor a bit more context on how I'm looking at this, I mostly agree with @dret's [hypermedia concepts](https://github.com/dret/hyperpedia/blob/master/concepts.md), particularly the distinction between target resource hints vs traversal hints.  My only disagreement is that I consider URI template resolution separate from traversal hints.  So I see four questions about a link:\r\n\r\n_Q: Why should I use this link?_ \r\nA: link relation type\r\n\r\n_Q: Which resource out of the possible set should I use?_\r\nA: URI template and any guidance on how to resolve the template\r\n\r\n_Q: What options do I have for consuming the target resource, e.g. content negotiation_\r\nA: target resource hints per @dret\r\n\r\n_Q: How can I interact with this resource, e.g. HTTP usage?_\r\nA: traversal hints per @dret, excluding URI templating\r\n\r\n... and it's not clear to me whether links and link serialization formats should answer that last question.",
          "createdAt": "2017-02-28T23:13:59Z",
          "updatedAt": "2017-02-28T23:13:59Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@mnot while I think the comment above is pretty general, if this one is getting too down in the weeds of JSON Hyper-Schema I'll be happy to remove this comment.\r\n\r\nThere is a TL;DR at the bottom\r\n\r\n-----\r\n\r\nAside from traversal hints, I am also concerned over JSON Hyper-Schema's `\"targetSchema\"` LDO keyword.  Like all target resource hints, it is advisory.  But it is weird in that it is actually hinting the result of following two links.  In a fully dynamic system you would:\r\n\r\nFor a GET (without `\"targetSchema\"` in the LDO):\r\n\r\n   1. Start with resource A and its hyper-schema, and look at a link to B\r\n   1. Issue a GET to B\r\n   1. follow the \"describedBy\" link in B's response header to get B's hyper-schema\r\n   1.  If I want to issue a PUT, I know its request should validate against the same schema used for the GET (per HTTP semantics, both are representations)\r\n\r\nFor a PUT (without `\"targetSchema\"` in the LDO, and avoiding a GET)\r\n\r\n   1.  Start with resource A and its hyper-schema, and look at a link to B\r\n   1.  Issue a HEAD on B\r\n   1.  Check its \"allow\" header to see if PUT is supported, but more importantly\r\n   1.  follow the \"describedBy\" link in the response header to get B's hyper-schema\r\n   1.  Use the hyperschema to build a PUT request for B without issuing a GET\r\n\r\nFor a PUT that avoids a GET when `\"targetSchema\"` is present:\r\n\r\n   1. Start with resource A and its hyper-schema, and look at a link to B\r\n   1. Look at the `\"targetSchema\"`, which SHOULD be the schema for B and therefore the schema for a PUT request to B\r\n   1. Use the link's `\"targetSchema\"` to build and validate a PUT request to B\r\n\r\nThat last one is problematic.  There is no inherent guarantee that the `\"targetSchema\"` in the link from A is correct for B.  Even if it was correct at the time that A's hyper-schema was generated, in a sufficiently dynamic system it may be out of date by the time the PUT request is constructed and sent.\r\n\r\n* `\"targetSchema\"` feels like a target hint, particularly when you consider the schema to be part of the media type (in some proposals there is a media type parameter for it)\r\n* Implementations treat it as the schema to use for a PUT request, or the schema to use in combination with the media type from Accept-Patch to figure out how to build a PATCH request\r\n* This seems to go against the security considerations based on who owns which schema\r\n\r\n------\r\n\r\nTL;DR:\r\n\r\nIs this \"target hint\" really an API description / documentation \"feature\" masquerading as a link hint?  This is the sort of thing that I'd like to understand better when it comes to properly designing the LDO for Hyper-Schema.\r\n\r\nIf the main point of `\"targetSchema\"` is to enable documentation and static description, but it MUST or even SHOULD be ignored at runtime for things like building PUT or PATCH request documents, then I think it probably belongs in API description formats (which may build on hyper-schema) but not in hyper-schema's LDOs.  Thoughts?\r\n",
          "createdAt": "2017-03-02T00:26:14Z",
          "updatedAt": "2017-03-02T00:26:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I don't think @dret's *implicit* and *explicit* traversal hints are a dichotomy; rather, I tend to see the explicit hints as refining the semantics of the link relation with link-authoring-time information. \r\n\r\nThe ones that I define in json-home are limited to information that you can discover by interacting with the resource -- and importantly, that information that's already expressed through standard (not resource-specific) mechanisms. It's really just trying to save you a bit of trouble (and RTs) when you interact with those resources.",
          "createdAt": "2017-03-06T06:08:23Z",
          "updatedAt": "2017-03-06T06:08:23Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "> It's really just trying to save you a bit of trouble (and RTs) when you interact with those resources.\r\n\r\nThat seems to sum up both \"target hints\" and \"explicit traversal hints\".\r\n\r\nI think I agree with explicit traversal hints being refinements of the more general (and possibly nonexistent) implicit hints indicated by the link relation.  To rephrase to see if I understand this, a link relation might imply the ability to do any number of things, while an explicit traversal hint restricts that to allow a client to avoid attempting those things that are not implemented for this particular link and target resource.\r\n\r\n----\r\n\r\nI think one reason I'm struggling with target vs traversal hints is that target hints are generally about the target resource's representation (media type, character set, language).  These are applicable to pretty much any dereferenceable link, no matter the URI scheme.  So adding them to a link representation spec feels pretty natural.  \r\n\r\nBut traversal hints are, by definition, scheme/protocol specific.  And then I feel like we're back to one of:\r\n\r\n* Add protocol-specific hints directly to the link format, for however many protocols are desired.  That seems kinda gross, and easy to get out of hand from sheer volume.\r\n* Add a general pattern from protocol-specific hints, and (somewhere) specify how to map elements of each protocol into the hint syntax.  That defers the protocol-specific things to structures that are clearly protocol-specific\r\n* Attempt to generalize traversal hints to a protocol-neutral form.  Or at least protocol-neutral names, perhaps allowing protocol-specific values.  Which I'm guessing would end up as looking mostly like HTTP and could therefore end up rather limiting at some point.\r\n\r\nAm I missing something here?  It feels like there needs to be a decision on whether to provide explicit traversal hints, and if so which of these (or some other) approach to use.  Is that decision in-scope for this issue?",
          "createdAt": "2017-03-15T00:09:46Z",
          "updatedAt": "2017-03-15T00:09:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "When you say protocol, do you mean the-thing-roughly-identified-by-the-uri-scheme, or the application-specific protocol in use (e.g,. \"e-mail over HTTP\")?",
          "createdAt": "2017-03-20T01:49:11Z",
          "updatedAt": "2017-03-20T01:49:11Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@mnot I mean the-thing-roughly-identified-by-the-uri-scheme :-)  Is there a better name for that?  I realized when I was writing the above comment that it's not quite right but couldn't come up with anything else.  Maybe I should have just said URI-scheme-specific...",
          "createdAt": "2017-03-20T15:52:13Z",
          "updatedAt": "2017-03-20T15:52:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I guess I'm not feeling too much concern here, because my interests are around / needs are met by  HTTP(S), not other protocols (schemes). \r\n\r\nWhat other ones did you have in mind?",
          "createdAt": "2017-04-11T04:29:51Z",
          "updatedAt": "2017-04-11T04:29:51Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@awwright has often brought up the need to be HTTP-agnostic in JSON Hyper-Schema, so perhaps he can comment on this.\r\n\r\nFor my part, the most obvious other one is CoAP which of course draws heavily from HTTP and is therefore the least problematic alternative anyway.\r\n\r\nAnother realistic possibility is integrating something like Cap'n Proto RPC into a hypermedia system. \r\n That would require defining a media type for the serialization and a URI scheme for the RPC protocol, but those are solvable problems, and I've floated the idea with capnp's inventor/maintainer in the context of bridging web-oriented hypermedia and capability-based RPC.",
          "createdAt": "2017-05-19T18:11:40Z",
          "updatedAt": "2017-05-19T18:11:40Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "I think you just need to define the parameters/hints in an appropriate manner, perhaps (in so many words) \"When making HTTP-compatible requests for this resource, optimize the request expecting the specified HTTP methods to be supported by the resource\".\r\n\r\nWorded this way because, keep in mind, it's technically legal to make a request to an HTTP server for any URI of any scheme, and the semantics of the Web are by and large defined by HTTP even when it's a different protocol (especially see HTTP/2, CoAP).\r\n\r\nAnd then for any resources not retrievable over the network, a definition like this is just a no-op.",
          "createdAt": "2017-05-19T22:44:16Z",
          "updatedAt": "2017-05-20T18:47:09Z"
        },
        {
          "author": "algermissen",
          "authorAssociation": "NONE",
          "body": "Reading this briefly (so excuse if I end up OT) it sounds as if there is too much desire to somehow establish more contract than is inherently possible in a decentralised system. Over-emphasising hints does not make them any more reliable - after all, they are just hints and the server can still do what it wants.\r\n\r\nA developer will best introspect servers anyhow at implementation time and assume reasonable stability - and then code for the unhappy paths. Hints do not make that go away - they just look as if they could. But they can't :-)\r\n\r\nRegarding non HTTP-like protocols: I'd probably see JSON Home as for the HTTP family and let other protocols deal with whatever 'home info' approach they deem suitable for themselves.\r\n",
          "createdAt": "2017-05-20T11:34:38Z",
          "updatedAt": "2017-05-20T11:34:59Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@algermissen the point of hints is not to establish a further contract (use OpenAPI or RAML or something for that).  It is to advertise what is reasonably likely to be supported and therefore worth attempting and coding for at the application level.  Yes, you always have to handle all errors, I'm well aware of that thank you.\r\n\r\nThere's this tendency to act as if the only choices for applications are fully dynamic hypermedia with runtime introspection, or hardcoding everything.  This is not the case.  The point of hints and other non-authoritative information is narrowing down the set of *likely* scenarios that are worth attempting and handling.  In any kid of programming, you make tradeoffs about how much effort to put into different things, ranging from very thorough handling to exiting at the first sign of something unexpected.  There are a great many possible things one can do with HTTP in particular, but not all of them are always reasonable to attempt, and not all of the results are always worth handling in detail.\r\n\r\nAlso, as noted in the first comment, this is about the standalone concept of \"link hints\", not JSON Home, specifically.  Unless I am really misreading that sentence.\r\n\r\nAnyway, if there's no interest in the concept, @awwright and I can just go back to arguing about it for JSON Hyper-Schema and related work.  I had thought @dret had some interest in this as well, but if he doesn't see anything worth supporting here, and no one else has shown up with interest in the last three months, I'm not particularly interested in trying to sell the idea myself.\r\n\r\nI would find it ideal to base anything in JSON Hyper-Schema off of a more generic approach to link hinting, but we certainly don't need such an approach to move forward and one project is not enough to motivate an independent spec.  Link hints aren't even the only possible approach to solving Hyper-Schema's needs here.",
          "createdAt": "2017-05-20T17:51:04Z",
          "updatedAt": "2017-05-20T17:51:04Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-05-20 20:51, Henry Andrews wrote:\n> @algermissen <https://github.com/algermissen> the point of hints is not\n> to establish a further contract (use OpenAPI or RAML or something for\n> that). It is to advertise what is reasonably likely to be supported and\n> therefore worth attempting and coding for at the application level. Yes,\n> you always have to handle all errors, I'm well aware of that thank you.\n\n+1; it's as much about documenting capabilities (i.e., design time) as \nit is about making them usable for runtime discovery. the more we make \nthese capabilities describable and discoverable in a coherent way, the \neasier we make it for designers/developers to describe, discover, and \nuse them.\n\nbecause of this, factoring them out of specific formats is a useful, \neven though of course as @mnot mentioned, there always is the risk of \npremature optimization/standardization.\n\n> Also, as noted in the first comment, this is about the standalone\n> concept of \"link hints\", not JSON Home, specifically. Unless I am really\n> misreading that sentence.\n\nyes. the connection is that JSON home's inclusion of some form of link \nhints spawned this discussion. if those were reusable standalone, JSON \nhome described resources could directly reuse them. and anybody else \ncould reuse them as well (such as JSON hyperschema).\n\n> Anyway, if there's no interest in the concept, @awwright\n> <https://github.com/awwright> and I can just go back to arguing about it\n> for JSON Hyper-Schema and related work. I had thought @dret\n> <https://github.com/dret> had some interest in this as well, but if he\n> doesn't see anything worth supporting here, and no one else has shown up\n> with interest in the last three months, I'm not particularly interested\n> in trying to sell the idea myself.\n\ni am interested. to me, JSON home alone would be a good motivation to do \nit because by definition, the resources described by JSON home might be \ngood candidates to simply reuse the link hints. or you could see it the \nother way around: any API using link hints could very well and easily \ndescribed via JSON home if the link hint design would be shared across \nJSON home and those APIs described by it.\n\nJSON hyperschema is another good candidate, i think. i'd be interested \nto pursue this. we could look at hyperschema and home as two use cases. \nwe could use home's model as inspiration. whether or not home actually \n\"switched\" then is something we'd see. we could even go as far as \nreferring to home's hints as (some of) the hints defined in a separate \nlink hints spec.\n\n> I would find it ideal to base anything in JSON Hyper-Schema off of a\n> more generic approach to link hinting, but we certainly don't need such\n> an approach to move forward and one project is not enough to motivate an\n> independent spec. Link hints aren't even the only possible approach to\n> solving Hyper-Schema's needs here.\n\nagreed. but i think we have at least two already (hyperschema and home). \nand for the APIs exposed through home, maybe it would be convenient to \nhave the hints being readily reusable through a link hints spec.\n\nin summary: i think we have some momentum and some use cases. if we \ndrive it by using hyperschema and home as scenarios, we might have \nenough input to get a first version started.\n\ni don't know yet, but i could imagine link hints adopting a registry \nmodel, with initial hints being defined by the spec, but with an \nextension model that is based on a registry. in that case, this should \nbe usable for both basic users, and those with more advanced link \nhinting needs.\n\n\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mnot/I-D/issues/211#issuecomment-302888401>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/ABw1JPowfvzOv9uD0fLccVgjwK0y_oTuks5r7ygKgaJpZM4MK2kP>.\n>\n\n-- \nerik wilde | mailto:erik.wilde@dret.net |\n            | http://dret.net/netdret    |\n            | http://twitter.com/dret    |\n",
          "createdAt": "2017-05-22T09:38:24Z",
          "updatedAt": "2017-05-22T09:38:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm not sure about a common registry. As per 5988bis, link attributes are defined by link relation types and/or link serialisations. \r\n\r\nPresumably we'd define a registry for hints (attributes) that a link relation and/or serialisation could opt into -- but they'd be opting into *all* of the registered values, no matter what the context.\r\n\r\nFor example, if such a registry were defined, I suspect it'd quickly be populated by COAP folks for IoT-specific use cases.\r\n\r\nWhat utility would that provide?\r\n\r\nOTOH, I *can* see some value in having a common set of \"HTTP Link Hints\" for reuse by different relations / serialisations, so they don't have to be constantly re-invented. My inclination would be just to define the set in the spec, updating the spec as necessary to expand it, rather than using a registry (unless the scope of the registry was very tightly defined).",
          "createdAt": "2017-06-20T00:48:45Z",
          "updatedAt": "2017-06-20T00:48:45Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-06-20 02:48, Mark Nottingham wrote:\n> OTOH, I /can/ see some value in having a common set of \"HTTP Link Hints\" \n> for reuse by different relations / serialisations, so they don't have to \n> be constantly re-invented. My inclination would be just to define the \n> set in the spec, updating the spec as necessary to expand it, rather \n> than using a registry (unless the scope of the registry was very tightly \n> defined).\n\nhttps://tools.ietf.org/html/draft-wilde-registries is my personal \nattempt to think about registries a bit more principled. it's a design \nspectrum. wikis may be on the one end, specs with hard-coded value sets \non the other. so to some extent, if the spec at least makes it clear \nthat the set of values is expected to evolve and defines a processing \nmodel covering this, then it would be a registry of sorts to say that \nnew values are added by spec revision. that's how w3c seems to approach \nthis currently since they don't have a registry system.\n\nmy main concern is to see many APIs where people reinvent the link hint \nwheel over and over again. i am glad to see them adding links to their \nAPIs, which means they are thinking about hypermedia. it would be great \nif we could help them avoiding designing snowflakes and instead using \n\"link patterns\" they can build their APIs around. my thought always was \nthat JSON home could be a perfect design example for how to design a \nhypermedia media type. that's my main goal. if that example for now has \na fixed set of link hints that may evolve with future revisions, then i \ncan live with that as well. as long as the model itself is open and \nextensible and thus can be used as a foundation for webby designs.\n",
          "createdAt": "2017-06-20T08:23:21Z",
          "updatedAt": "2017-06-20T08:23:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I've re-started work on link-hints; see \r\n  https://mnot.github.io/I-D/link-hint/\r\nand\r\n  https://github.com/mnot/I-D/issues?q=is%3Aissue+is%3Aopen+label%3Alink-hint",
          "createdAt": "2018-03-27T02:49:21Z",
          "updatedAt": "2018-03-27T02:49:21Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2018-03-27 04:49, Mark Nottingham wrote:\n> I've re-started work on link-hints; see\n> https://mnot.github.io/I-D/link-hint/\n> and\n> https://github.com/mnot/I-D/issues?q=is%3Aissue+is%3Aopen+label%3Alink-hint\n\ngreat news! and it's quite a coincidence, because in the context of \nlooking at hypermedia annotations, just last week i went back to \nhttps://tools.ietf.org/html/draft-wilde-link-desc-01, thinking that \nsomething like that would (still) be nice to have. there's quite a bit \nof overlap, and as we discussed when we talked about these two drafts in \nthe past, it would be useful to have a standalone way for these \ndescriptions outside of the scope of home documents.\n",
          "createdAt": "2018-03-27T06:03:35Z",
          "updatedAt": "2018-03-27T06:03:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Talking to folks at IETF101 last week convinced me that it's worth a try.",
          "createdAt": "2018-03-27T06:07:38Z",
          "updatedAt": "2018-03-27T06:07:38Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2018-03-27 08:07, Mark Nottingham wrote:\n> Talking to folks at IETF101 last week convinced me that it's worth a try.\n\nthat's great to hear! i'd be interested to hear what changed your mind. \ni think last time (when i suggested to possibly join forces for the \nhints and descriptions drafts) you thought that maybe it was too early \nto take on as a separate thing, and that you'd rather see it in the home \ndraft.\n",
          "createdAt": "2018-03-27T06:41:02Z",
          "updatedAt": "2018-03-27T06:41:02Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWUyMTEwMTAxNDI=",
      "title": "Well-known URI for \"home\"",
      "url": "https://github.com/mnot/I-D/issues/212",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "as brought up in the discussion of #41, another helpful piece in the \"home\" puzzle could be to register a `home` well-known URI, so that developers liking this pattern for discovery can use an existing value.",
      "createdAt": "2017-03-01T08:23:33Z",
      "updatedAt": "2018-01-29T08:27:32Z",
      "closedAt": "2018-01-29T07:00:26Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I like this idea. Would you say it's okay for a `well-known` URI to do an HTTP `301` to i.e. `/` for applications where that make sense?",
          "createdAt": "2017-03-02T10:08:59Z",
          "updatedAt": "2017-03-02T10:08:59Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-03-02 11:09, Asbj\u00f8rn Ulsberg wrote:\n> I like this idea. Would you say it's okay for a |well-known| URI to do\n> an HTTP |301| to i.e. |/| for applications where that make sense?\n\nwithout looking at that specific topic, i would think that as long as \n/well-known resources are properly behaving HTTP resources, they can do \nwhatever their owner wants them to do.\n\nif you want to publish a /well-known/home resource because some services \nmay use this for discovery, but you also firmly believe that your \nservice's \"root\" resource *is* the service's home resource, then this \nmight very well be the way to go.\n",
          "createdAt": "2017-03-02T10:27:38Z",
          "updatedAt": "2017-03-02T10:27:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "What's the use case here?\r\n\r\nWe mint a well-known URI when it's not realistic to use a URL, because we just have a hostname and port to work with. \r\n\r\nIs there a use case for home documents where you can't just give the user a URL?",
          "createdAt": "2017-03-06T05:43:12Z",
          "updatedAt": "2017-03-06T05:43:12Z"
        },
        {
          "author": "algermissen",
          "authorAssociation": "NONE",
          "body": "I have been using it in situations where the clients know/discover a bunch of other systems as just host and port information and then use the general well known location to proceed.\r\n\r\nIn combination with DNS SRV or DNS-SD based discovery I thing this would be useful.\r\n\r\nHaving said that, I see your point (and e.g. with DNS-SD there is also 'path' in the TXT record to communicate a path). ",
          "createdAt": "2017-03-06T06:40:43Z",
          "updatedAt": "2017-03-06T06:40:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Current interpretation of the well-known URI spec by IETF folks is that it's only intended for places where a) the client *can't* get a full URL, or b) the well-known location has metadata about the whole origin.\r\n\r\nThis doesn't seem to fit into either. I can see that DNS-SD/SRV *could* use them, but the bar is being raised to require an actual, concrete use case. \r\n\r\nI think that it'd make more sense for a particular API to register a well-known location if it meets the requirements above.",
          "createdAt": "2018-01-29T07:00:26Z",
          "updatedAt": "2018-01-29T07:00:26Z"
        },
        {
          "author": "algermissen",
          "authorAssociation": "NONE",
          "body": "As a note for future readers: I recently saw @dret has worked on a link-rel that serves the discovery purpose well https://tools.ietf.org/html/draft-wilde-service-link-rel",
          "createdAt": "2018-01-29T08:07:38Z",
          "updatedAt": "2018-01-29T08:07:38Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2018-01-29 09:07, Jan Algermissen wrote:\n> As a note for future readers: I recently saw @dret \n> <https://github.com/dret> has worked on a link-rel that serves the \n> discovery purpose well \n> https://tools.ietf.org/html/draft-wilde-service-link-rel\n\n- https://github.com/mnot/I-D/issues/191 addresses how those link \nrelations might work with JSON home.\n\n- https://github.com/mnot/I-D/issues/213 questions whether `describedBy` \nis the best approach for linking related API-level resources from home \ndocuments.\n",
          "createdAt": "2018-01-29T08:27:32Z",
          "updatedAt": "2018-01-29T08:27:32Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "MDU6SXNzdWUyMTExMDM3MjA=",
      "title": "\"describedBy\" link in API links section",
      "url": "https://github.com/mnot/I-D/issues/213",
      "state": "OPEN",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "the current text provides an example for API-level information that is probably intended to link to API documentation, and uses the `describedby` link relation type. the idea to be able to link to API-level documentation is very useful, and it's good to have an example for it.\r\nHowever, `describedby` is probably not the appropriate choice here. typically, `describedby` is used to link to metadata describing the source resource, which in this case would be information such as the author of the home document, and maybe time stamps such as creation and last modification dates.\r\nhttps://tools.ietf.org/html/draft-wilde-service-link-rel provides link relations for the scenario used here: API level information. it defines `service-doc`, `service-desc` and `status` link relation types, which can be used to human-readable documentation (e.g., HTML), machine-readable description (e.g., OpenAPI), and a status resource. maybe these are a better fit for the home document scenario?",
      "createdAt": "2017-03-01T14:52:16Z",
      "updatedAt": "2020-02-25T06:09:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i guess the point i was raising here is related to #191 (the question whether the `service-*` link relations might fit into JSON home).",
          "createdAt": "2017-10-10T09:18:09Z",
          "updatedAt": "2018-01-22T09:31:58Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "specifically, the example given currently looks like this:\r\n\r\n```\r\n    \"api\": {\r\n      \"title\": \"Example API\",\r\n      \"links\": {\r\n        \"author\": \"mailto:api-admin@example.com\",\r\n        \"describedBy\": \"https://example.com/api-docs/\"\r\n      }\r\n```\r\n\r\nby using more specific link relations, the example could be changed to specifically link to human- and machine readable descriptions, for example one in PDF and the other one in OpenAPI.\r\n\r\n```\r\n    \"api\": {\r\n      \"title\": \"Example API\",\r\n      \"links\": {\r\n        \"author\": \"mailto:api-admin@example.com\",\r\n        \"service-doc\": \"https://example.com/api-docs/api.pdf\"\r\n        \"service-desc\": \"https://example.com/api-docs/api.oai\"\r\n      }\r\n```",
          "createdAt": "2017-11-07T12:04:29Z",
          "updatedAt": "2017-11-07T12:04:29Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "would it help if i submit a PR replacing the more generic `describedBy` approach with the more specific `service-*` one?",
          "createdAt": "2018-01-22T09:32:53Z",
          "updatedAt": "2018-01-22T09:32:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Sure.",
          "createdAt": "2020-02-25T06:09:01Z",
          "updatedAt": "2020-02-25T06:09:01Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWUyMTc5ODU0Mzc=",
      "title": "Nit for Section 4",
      "url": "https://github.com/mnot/I-D/issues/221",
      "state": "CLOSED",
      "author": "mamund",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "_(for 5988bis)_\r\n\r\nI found myself internally translating the example sentences for \"copyright\" and \"service\" link relation types found in Section 4 into the template language supplied in Section 3.  It might be a good idea to provide the examples in the same template language to make this a bit easier to grok.\r\n\r\nso..\r\n\r\n> For example, a link with the relation type \u201ccopyright\u201d indicates that the resource identified by the link target is a statement of the copyright terms applying to the current link context.\r\n\r\nwould be:\r\n\r\n> For example, a link with the relation type \u201ccopyright\u201d indicates that the current link context has a copyright resource at the link target.  \r\n\r\nThis is just a nit.",
      "createdAt": "2017-03-29T19:35:01Z",
      "updatedAt": "2017-04-11T04:27:19Z",
      "closedAt": "2017-04-11T04:27:19Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I find the rewritten paragraph to be easier to read and understand, so \ud83d\udc4d  from me.",
          "createdAt": "2017-04-03T23:31:03Z",
          "updatedAt": "2017-04-03T23:31:03Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWUyMTgwMDQyODk=",
      "title": "Nit for 5988bis Section 6.2",
      "url": "https://github.com/mnot/I-D/issues/222",
      "state": "CLOSED",
      "author": "mamund",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I had to re-read the details of `anchor` attribute a few times to take it all in.\r\n\r\nAn example showing the anchor attribute would help readability of this section. Or maybe add a pointer to Section 6.5 and place it there.\r\n\r\n",
      "createdAt": "2017-03-29T20:47:23Z",
      "updatedAt": "2017-04-11T04:23:13Z",
      "closedAt": "2017-04-11T04:23:13Z",
      "comments": []
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWUyMTgwMDUxMTM=",
      "title": "Clarify Character Encoding Attributes for 5988bis Section 6.4",
      "url": "https://github.com/mnot/I-D/issues/223",
      "state": "CLOSED",
      "author": "mamund",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "This section covers use of the \"title\" and \"title*\" attributes. However, Section 5 says:\r\n\r\n> The names of target attributes SHOULD conform to the token rule, but SHOULD NOT include any of the characters \u201c%\u201d, \u201c\u2019\u201d or \u201c*\u201d, for portability across serializations\r\n\r\nAnd Section 6.4.2 goes on to help parsers deal with the difference between \"example\" and \"example*\".  It's not clear to me when reading this whether it is also giving instructions on how to properly _create_ new 5987-style attributes or if this section (6.4.2) is only discussing the parsing of existing 5987-style attributes.\r\n\r\nIf we don't want authors creating new 5987-style attributes, it might be helpful to repeat that here or to point back to Section 5's admonition.\r\n",
      "createdAt": "2017-03-29T20:50:31Z",
      "updatedAt": "2017-06-20T00:25:16Z",
      "closedAt": "2017-06-20T00:25:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "To be clear -- `title` and `title*`, when serialised in a Link header, are *parameters* -- the spec should use that terminology consistently.\r\n\r\n*Attributes* are in the abstract model (defined in Section 3); *parameters* are specific to the header serialisation, as defined in Section 6. If you find anywhere where these terms are used in a way that's inconsistent with this explanation, I'd love to hear about it.\r\n\r\nThat aside, 6.4.2 is pretty explicit about allowing the use of 5987-style parameters, when attributes want it; can you suggest a clarification?",
          "createdAt": "2017-04-11T04:15:37Z",
          "updatedAt": "2017-04-11T04:15:37Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "MDU6SXNzdWUyMTgwMDY1MDk=",
      "title": "Build bug for handling asterisk in 5988 Section 6.4.2",
      "url": "https://github.com/mnot/I-D/issues/224",
      "state": "CLOSED",
      "author": "mamund",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The build of the `draft.md` is not properly handling the asterisk in Section 6.4.2. It is appearing as a control character (emph) instead of a simple asterisk.\r\n\r\nThe XML build is:\r\n`\u201cexample\u201d and \u201cexample<spanx style=\"emph\">\u201d). When both forms are present, they SHOULD be considered to be the same target attribute; processors SHOULD use the value of the name ending in \u201c</spanx>\u201d`\r\n\r\nThe TXT build is:\r\n`(e.g., \"example\" and \"example_\").  When both forms are present, they SHOULD be considered to be the same target attribute; processors SHOULD use the value of the name ending in \"_\"`\r\n\r\nThe HTML build is simply missing the asterisk entirely.\r\n\r\n",
      "createdAt": "2017-03-29T20:55:58Z",
      "updatedAt": "2017-04-03T18:06:20Z",
      "closedAt": "2017-04-03T18:06:20Z",
      "comments": []
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWUyMjIyMjQyMDM=",
      "title": "Disjoint resources with same relation in json-home documents",
      "url": "https://github.com/mnot/I-D/issues/225",
      "state": "OPEN",
      "author": "jackfirth",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "Say I have three completely different resources A, B, and C that are all described by some relation X (possibly a very general relation such as \"hosts\"). In a JSON Home document, there seems to be two ways to link to these resources:\r\n\r\n- With a URI template as a Resource Template. This can easily be inappropriate, as the resources may have very different URI structures, supported formats, authentication hints, etc. etc.\r\n- With multiple entries in the \"resources\" object that all have the same relation, e.g. `{X: A, X: B, X:C`. While this is technically acceptable in the JSON spec, many client implementations don't handle it well and the JSON Home spec implies that non-templated entries in the \"resources\" object are the only entries with a particular relation:\r\n\r\n> A Resource Object links to resources of the type indicated in their name using one of two mechanisms; either a direct link (in which case there is exactly one resource of that relation type associated with the API), or a templated link, in which case there are zero to many such resources.\r\n\r\nThis makes it difficult for me to build tools consuming JSON Home documents, as I was planning on using more standard relations and tool-specific relations that describe a variety of resources rather than primarily API-specific relations, to make tools that work across multiple APIs. I was expecting an array of resources and resource templates for each relation rather than a single resource or template.",
      "createdAt": "2017-04-17T20:34:48Z",
      "updatedAt": "2017-10-11T07:29:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Can you give me some more detail about your use case? I'm trying to understand how you want to use the spec.",
          "createdAt": "2017-04-19T09:39:23Z",
          "updatedAt": "2017-04-19T09:39:23Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "it seems that this is a valid point, and one issue that tends to surface in certain ways of representing links in JSON. some designs then go the route of changing the JSON structure so that they can accommodate multiple links of the same relation.\r\ni am not saying that JSON home has to do this. but it might be useful to add some informative text that makes this limitation of the format explicit, so that people are not left wondering.\r\none use case i could easily think about would be to say that there is more than one associated documentation resource available. `service-doc` then would repeat as a link relation, and these links could be further qualified by media type hints, one linking to HTML documentation and the other to a PDF version (this example probably applies best to the API object, which has the same limitation).",
          "createdAt": "2017-10-10T13:45:46Z",
          "updatedAt": "2017-10-10T13:47:55Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "We're struggling a bit with this in JSON Hyper-Schema as well.  Currently, our `links` is an array of objects (which may use URI Templates), so multiple objects in the array can have the same `rel`.  However, some prefer `rel` as an object key, which would probably result in the values being a list of objects, which doesn't simplify things all that much IMHO.  \r\n\r\nAs for use cases, you may want to link to resources in multiple other systems.  For instance, links from a person to \"publications\" of various sorts that are not all hosted by the same other service.  Some may not be online and may be better identified by URNs than URLs.\r\n\r\nOff the top of my head I can't come up with a use case within a single API where the same entity designs all of the URIs, but I just woke up and the caffeine hasn't really kicked in yet :-P",
          "createdAt": "2017-10-10T16:04:39Z",
          "updatedAt": "2017-10-10T16:04:39Z"
        },
        {
          "author": "jackfirth",
          "authorAssociation": "NONE",
          "body": "I lost track of this issue, whoops.\r\n\r\nA specific tool I had in mind when I wrote this was a hypothetical command line tool that could do some generic CRUD operations on any REST API with a home document that linked to collections that should support CRUD operations. There'd be some link relation defined by the tool, maybe an http url to the tool's docs or something, and each link with that relation would equal one collection. Forcing a server to ensure the collections all fit a particular URI template just to get this tool integration working seems restrictive.\r\n\r\nTo deal with this specific problem, I'd probably just have the home document link to a single resource that represents a list of links to use as collections. So it's more of an inconvenience of the format for me than a blocking issue.",
          "createdAt": "2017-10-11T04:05:54Z",
          "updatedAt": "2017-10-11T04:06:03Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-10-10 18:04, Henry Andrews wrote:\n> We're struggling a bit with this in JSON Hyper-Schema as well. \n> Currently, our |links| is an array of objects (which may use URI \n> Templates), so multiple objects in the array can have the same |rel|. \n> However, some prefer |rel| as an object key, which would probably result \n> in the values being a list of objects, which doesn't simplify things all \n> that much IMHO.\n\nthis pattern just seems to be something that \"reads well\" to the human \neye. as long as you're not trying to have more than one link with one \nrelation type, it works well.\n",
          "createdAt": "2017-10-11T07:29:59Z",
          "updatedAt": "2017-10-11T07:29:59Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWUyMjg2NDgyNzM=",
      "title": "Fix references",
      "url": "https://github.com/mnot/I-D/issues/226",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2017-05-15T08:58:40Z",
      "updatedAt": "2017-05-16T01:10:11Z",
      "closedAt": "2017-05-16T01:10:11Z",
      "comments": []
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWUyMjg2NDg5OTc=",
      "title": "CardDAV doesn't define new methods (but CalDAV does)",
      "url": "https://github.com/mnot/I-D/issues/227",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2017-05-15T09:01:25Z",
      "updatedAt": "2017-05-16T01:11:55Z",
      "closedAt": "2017-05-16T01:11:55Z",
      "comments": []
    },
    {
      "number": 228,
      "id": "MDU6SXNzdWUyMzcxMjM3NTk=",
      "title": "Explain \"title\" I18N in \"Internationalization\" section",
      "url": "https://github.com/mnot/I-D/issues/228",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "maybe it would be helpful to explain how non-ASCII characters are supposed to be handled (in particular in text strings such as the `title`/`title*` parameters). currently https://tools.ietf.org/html/draft-nottingham-rfc5988bis#section-6 only talks about IRIs and URIs. maybe some text about general character encoding considerations would be helpful.",
      "createdAt": "2017-06-20T07:59:51Z",
      "updatedAt": "2017-12-14T01:50:27Z",
      "closedAt": "2017-12-14T01:50:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See <https://mnot.github.io/I-D/rfc5988bis/#extension-attributes>.",
          "createdAt": "2017-06-21T01:58:46Z",
          "updatedAt": "2017-06-21T01:58:46Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for the pointer. concretely, what about linking to this section (or 5987bis directly) with a brief statement about how internationalization of parameter values is working?\r\n\r\n> For any non-ASCII values in attribute values, this specification uses (for title/title*) or suggests to use (for extension attributes) the encoding defined in RFC 5987bis, which uses a naming convention combined with mandatory character encoding and optional language information, followed by escaped attribute values.",
          "createdAt": "2017-06-21T07:27:42Z",
          "updatedAt": "2017-06-21T07:27:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Ah, missed this, sorry.",
          "createdAt": "2017-12-14T01:50:27Z",
          "updatedAt": "2017-12-14T01:50:27Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWUyMzc0MTU4MTI=",
      "title": "Alternate approach",
      "url": "https://github.com/mnot/I-D/issues/229",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "_Considered earlier and rejected_\r\n\r\nBy definition, the Internet is a \"network of networks.\" From an architectural standpoint, the Internet has the most utility when it has the greatest network effect, by involving the greatest number of networks, nodes and perhaps most critically, people.\r\n\r\nThis is shown by the increasing impact of the Internet as adoption rates have risen in many societies. In many places, the Internet is now critical to physical infrastructure, the economy, education, culture, and civil society.\r\n\r\nTo safeguard this utility, those developing Internet protocols need to consider impact on the breadth of adoption.\r\n\r\nMost decisions we make are well-aligned with this; we do not want to deploy protocols that do not get used. However, from time to time, there is a proposal made to the IETF that meets an immediate need, but endangers the longer-term utility of the protocol in question, or even the Internet itself.\r\n\r\nIn particular, when a protocol (or protocol extension) can be perceived to prioritise the needs of a third party over the end users of the Internet, this can erode trust in the Internet overall -- thereby reducing the utility of the Internet.\r\n\r\nFor example, network operators often express a desire to be able to man-in-the-middle encrypted protocols such as HTTPS for operational reasons, or to introduce new services. Doing so would erode end-user trust in the protocol, since HTTPS is explicitly end-to-end encrypted.\r\n\r\nThis is a \"tragedy of the commons\" -- satisfying the immediate needs of some parties at the expense of the overall value of the community is not a sustainable model, and must be guarded against.\r\n\r\nTherefore, Internet Protocols MUST prioritise the needs of end users of the Internet over all other parties.\r\n\r\n\r\n## Application\r\n\r\nBy \"end users\", we mean non-technical users whose activities our protocols are designed to support. Thus, the end user of a protocol to manage routers is not a router administrator; it is the people using the network that the router operates within.\r\n\r\nThis does not mean that the IETF community has any specific insight into what is \"good for end users\"; as always, we will need to interact with the greater Internet community and apply our process to help us make decisions, deploy our protocols, and ultimately determine their success or failure.\r\n\r\nIt does mean that when a proposed solution to a problem has a benefit to some other party at the identified expense of end users, we will find a different solution or find another way to frame the problem.\r\n\r\nIn particular, some choices we make might unavoidably reduce the availability of the Internet to a set of users. For example, requiring encryption in a protocol might prevent its use in some legal contexts. Likewise, refusing to define performance enhancing proxies for a protocol might preclude the use of that protocol by...",
      "createdAt": "2017-06-21T05:04:30Z",
      "updatedAt": "2017-06-24T16:58:24Z",
      "closedAt": "2017-06-21T05:04:33Z",
      "comments": [
        {
          "author": "akuckartz",
          "authorAssociation": "NONE",
          "body": ":+1:",
          "createdAt": "2017-06-24T16:58:24Z",
          "updatedAt": "2017-06-24T16:58:24Z"
        }
      ]
    },
    {
      "number": 230,
      "id": "MDU6SXNzdWUyMzk3NTIzMTg=",
      "title": "Problem Details in HTTP Link Header",
      "url": "https://github.com/mnot/I-D/issues/230",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "http-problem"
      ],
      "body": "Just a random thought I had now while setting up status code logging for a few APIs: It would be awesome if the problem detail properties from RFC 7807 could be expressed in a `Link` header with an appropriate `rel` value. Something like:\r\n\r\n```http\r\nLink: <https://example.com/probs/out-of-credit>; rel=\"problem-type\"; title=\"You do not have enough credit.\"; detail=\"Your current balance is 30, but that costs 50.\"; instance=\"/account/12345/msgs/abc\"\r\n```\r\n\r\nPerhaps it's a bit of a stretch to include all properties from RFC 7807, but `title` and the `problem-type` link relation would be very useful. Is an RFC 7807bis planned?\r\n\r\n/cc @dret ",
      "createdAt": "2017-06-30T11:27:31Z",
      "updatedAt": "2017-12-14T01:50:45Z",
      "closedAt": "2017-12-14T01:50:45Z",
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-06-30 04:27, Asbj\u00f8rn Ulsberg wrote:\n> Just a random thought I had now while setting up status code logging for\n> a few APIs: It would be awesome if the problem detail properties from\n> RFC 7807 could be expressed in a |Link| header with an appropriate |rel|\n> value. Something like:\n>\n> Link: <https://example.com/probs/out-of-credit>; rel=\"problem-type\";\n> title=\"You do not have enough credit.\"; detail=\"Your current balance is\n> 30, but that costs 50.\"; instance=\"/account/12345/msgs/abc\"\n>\n> Perhaps it's a bit of a stretch to include all properties from RFC 7807,\n> but |title| and the |problem-type| link relation would be very useful.\n\nmaybe there's a bit of an imbalance here between a RDFish world view, \nand link relations a la RFC 5988. exposing every property of some data \nmodel as link relations is something that looks more like a published \nRDF vocabulary, and not so much link relations where the goal is to \nprovide relations that make sense as navigable hypermedia controls.\n\nthere was some effort to define an RDF version of HTTP problem a little \nwhile ago, but after an initial \"that would be nice to have\" phase the \neffort stalled, and i have moved it to my abandoned efforts space:\n\nhttps://github.com/dret/I-D/tree/master/Abandoned/http-problem-rdf\n\n> Is an RFC 7807bis planned?\n\ni don't think so. but of course if here is enough momentum to work on an \nupdated version, that i always a possibility.\n",
          "createdAt": "2017-07-01T17:01:17Z",
          "updatedAt": "2017-07-01T17:01:17Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "While a JSON-LD `@context` for `application/problem+json` would be neat, it does not solve the specific use case of having the `type` URI available in an HTTP header so it can be logged alongside the HTTP status code.\r\n\r\nI did state that exposing all of the properties would be a stretch. That's not something I need either; I just thought that since `title` already exist as a `Link` target attribute, we might as well use it to convey RFC 7807's `title`.\r\n\r\nI don't think the link relation `problem-type` warrants a revision to RFC 7807, so perhaps it can be put up as a standalone I-D?",
          "createdAt": "2017-07-01T23:22:20Z",
          "updatedAt": "2017-07-01T23:23:09Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-07-01 16:22, Asbj\u00f8rn Ulsberg wrote:\n> I don't think the link relation |problem-type| warrants a revision to \n> RFC 7807, so perhaps it can be put up as a separate I-D?\n\nthat's something you can easily do yourself, if you think it will be \nuseful and would like to get such a link relation registered. if you're \nlooking for a starting point, \nhttps://github.com/dret/I-D/tree/master/service-link-rel might be \nuseful. feel free to reuse/adapt in any shape or form that's helpful.\n",
          "createdAt": "2017-07-02T01:51:43Z",
          "updatedAt": "2017-07-02T01:51:43Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "MDU6SXNzdWUyNDIyNDkxMTk=",
      "title": "Pervasive monitoring is not the only reason",
      "url": "https://github.com/mnot/I-D/issues/231",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "The bcp56bis draft currently says:\r\n\r\n> \u201chttps\u201d is preferred to mitigate pervasive monitoring attacks [RFC7258].\r\n\r\nThis implies that this is the only reason.  The best reasons are not even mentioned: authentication, confidentiality, and integrity.",
      "createdAt": "2017-07-12T03:47:01Z",
      "updatedAt": "2017-12-14T01:41:20Z",
      "closedAt": "2017-12-14T01:41:20Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "in httpwg repo",
          "createdAt": "2017-12-14T01:41:20Z",
          "updatedAt": "2017-12-14T01:41:20Z"
        }
      ]
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWUyNDIyNDk5NjE=",
      "title": "Advice on transport ports",
      "url": "https://github.com/mnot/I-D/issues/232",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "> Applications that use HTTP SHOULD use the default port for the URL scheme in use. \r\n\r\nThis isn't really necessary.  I would instead say that the port number is in the URL and cite [Initial URL Discovery](https://mnot.github.io/I-D/bcp56bis/#initial-url-discovery) for details.\r\n\r\nThen explain that if you are bootstrapping from a bare hostname with `.well-known`, then this should assume the use of the default port for the scheme unless there are very good reasons.  In particular, when it comes to using port numbers other than the default, you can note that there are privacy implications (it makes your protocol distinguishable) and deployment implications (some middleboxes might interfere with the operation of your protocol).",
      "createdAt": "2017-07-12T03:53:40Z",
      "updatedAt": "2017-12-14T01:42:27Z",
      "closedAt": "2017-12-14T01:42:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "in httpwg repo",
          "createdAt": "2017-12-14T01:42:27Z",
          "updatedAt": "2017-12-14T01:42:27Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "MDU6SXNzdWUyNDIyNTAzODc=",
      "title": "Any room for 6648",
      "url": "https://github.com/mnot/I-D/issues/233",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "bcp56bis says\r\n\r\n> In particular, if a header field is specific to an application, an identifier for that application SHOULD form a prefix to the header field name, separated by a \u201c-\u201c.\r\n\r\nThis might tempered by a reference to RFC 6648 so that people don't get the mistaken impression that prefixing is a universal good.  The important qualification here is that the header field is specific to that application, which probably needs emphasis.",
      "createdAt": "2017-07-12T03:57:18Z",
      "updatedAt": "2017-12-14T01:43:14Z",
      "closedAt": "2017-12-14T01:43:14Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "in httpwg repo now",
          "createdAt": "2017-12-14T01:43:14Z",
          "updatedAt": "2017-12-14T01:43:14Z"
        }
      ]
    },
    {
      "number": 234,
      "id": "MDU6SXNzdWUyNDIyNTA1Njc=",
      "title": "Forbid 'digest' with HTTP as well",
      "url": "https://github.com/mnot/I-D/issues/234",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Digest authentication is laughably weak; anything that uses it over HTTP is asking for trouble.",
      "createdAt": "2017-07-12T03:58:48Z",
      "updatedAt": "2017-12-14T01:44:05Z",
      "closedAt": "2017-12-14T01:44:05Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Which spec was this for?\r\n\r\nAlso, do you have a ref for vulnerabilities? Its problems signing headers is well-understood; what else?",
          "createdAt": "2017-08-12T01:33:37Z",
          "updatedAt": "2017-08-12T01:33:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "bcp56bis\r\n\r\nThere should be plenty.  Dictionary attacks on low-entropy secrets are trivial when the hash is as cheap as MD5.  I found RFC 7616, which explains the limitations in some detail.",
          "createdAt": "2017-08-13T10:16:26Z",
          "updatedAt": "2017-08-13T10:16:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "ah, that's right -- we talked about moving past md5 on that, but never did it.",
          "createdAt": "2017-08-13T18:16:24Z",
          "updatedAt": "2017-08-13T18:16:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "in httpwg repo now",
          "createdAt": "2017-12-14T01:44:05Z",
          "updatedAt": "2017-12-14T01:44:05Z"
        }
      ]
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWUyNDI2NTQ0MDM=",
      "title": "JSON Home media type",
      "url": "https://github.com/mnot/I-D/issues/237",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I see that the draft uses `application/json-home` as its media type. Shouldn't it be `application/home+json`? Afaik, `application/home` is still an unregistered media type?\r\n\r\nAlso, what's the status on the draft? Any ideas of if and when it will become an RFC?",
      "createdAt": "2017-07-13T10:21:57Z",
      "updatedAt": "2017-07-17T06:23:33Z",
      "closedAt": "2017-07-16T08:26:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See https://github.com/mnot/I-D/issues/172",
          "createdAt": "2017-07-16T08:26:28Z",
          "updatedAt": "2017-07-16T08:26:28Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Ah. My memory is really not my strongest asset. \ud83d\ude15 ",
          "createdAt": "2017-07-16T16:31:01Z",
          "updatedAt": "2017-07-16T16:31:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I know that feeling :)",
          "createdAt": "2017-07-17T06:23:33Z",
          "updatedAt": "2017-07-17T06:23:33Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWUyNDY2ODYxNTQ=",
      "title": "end-user values",
      "url": "https://github.com/mnot/I-D/issues/238",
      "state": "CLOSED",
      "author": "nllz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "Thanks for the new version of the draft. Upon re-reading it I thought of a threat vector that this draft possible brings in which might actually impact its usefulness. If we prioritize the need of the end-user, we're prioritizing end-user values. \r\n\r\nThe problem with end-user values is that everyone can claim anything is an end-user value. The end-user is not a standard with explicit guidelines or standards. It might even lead to a deterioration of consensus as documented in [RFC7754] [RFC7258] [RFC7624] [RFC7288] or [RFC6973] because people might argue that these go against end-user values such as 'harmony', 'public safety' and 'public decency'.\r\n\r\nSo where I see the use of this for instance in the TLS1.3 discussion, I also see how it could potentially be used on the other side of the discussion. \r\n",
      "createdAt": "2017-07-31T08:49:49Z",
      "updatedAt": "2017-08-12T01:33:00Z",
      "closedAt": "2017-08-12T01:33:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "My on-list reply:\r\n\r\nI don't think there's any magic bullet that guarantees that the right thing will always happen -- we rely upon the community to bring up and represent users' needs. What this draft tries to do is give user-focused participants, chairs, ADs and other leadership a tool to use to help, along with a stated goal.\r\n\r\nI was just looking at BCP95 in this light; I've always found that an excellent RFC, but the stated goal of the IETF -- \"The goal of the IETF is to make the Internet work better\" -- is so frustrating because it begs the question \"for whom?\"\r\n\r\nThis draft tries to give some guidance along those lines; it's a very small step, but one worth taking, I think. ",
          "createdAt": "2017-07-31T12:07:32Z",
          "updatedAt": "2017-07-31T12:07:32Z"
        }
      ]
    },
    {
      "number": 239,
      "id": "MDU6SXNzdWUyNDc1MzA0Mzg=",
      "title": "serialization rules for repeated link parameters",
      "url": "https://github.com/mnot/I-D/issues/239",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "the current RFC 5988bis draft has the following example:\r\n\r\n```\r\n<http://example.org/>; rel=\"start http://example.net/relation/other\"\r\n```\r\n\r\nis it correct to assume that this is equivalent to the following:\r\n\r\n```\r\n<http://example.org/>; rel=\"start\", <http://example.org/>; rel=\"http://example.net/relation/other\"\r\n```\r\n\r\nas well as the following:\r\n\r\n```\r\n<http://example.org/>; rel=\"start\"; rel=\"http://example.net/relation/other\"\r\n```\r\n\r\nthe reason is to figure out if there is a general model of how multiple occurrences of the same link parameter are to be processed. the reason for the question is that @hvdsomp and i are working on a JSON version (as discussed elsewhere previously). our current approach uses\r\n\r\n```json\r\n[ { \"href\" : \"http://example.org/\" , \"rel\" : \"start\" } ]\r\n```\r\n\r\nbut that won't work if we need to support repeating link attributes (it would be valid JSON but very badly designed JSON). the question we therefore have is how exactly repeated link parameters are defined. and can we leverage this definition to support our goal of having a simple JSON representation as shown above?",
      "createdAt": "2017-08-02T21:38:22Z",
      "updatedAt": "2017-08-11T19:03:07Z",
      "closedAt": "2017-08-11T19:03:07Z",
      "comments": [
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "Good observation. Can we address this by stating that an approach must be taken whereby parameters are not repeated, e.g.:\r\n\r\n[ { \"href\" : \"http://example.org/\" , \"rel\" : \"start http://example.net/relation/other\" } ]\r\n\r\nor:\r\n\r\n[ { \"href\" : \"http://example.org/\" , \"rel\" : \"start\" } ,\r\n  { \"href\" : \"http://example.org/\" , \"rel\" : \"http://example.net/relation/other\" } ]\r\n\r\n\r\n",
          "createdAt": "2017-08-03T08:59:20Z",
          "updatedAt": "2017-08-03T08:59:20Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-08-03 01:59, Herbert Van de Sompel wrote:\n> Good observation. Can we address this by stating that an approach must \n> be taken whereby parameters are not repeated, e.g.:\n\nmy guess is since this hasn't been disallowed by RFC 5988, it might be \nhard to add such a constraint now. i have no idea how often repeated \nlink parameters occur in link headers in the wild.\n\nmy main issue here is to understand the exact abstract model of the \ncurrent draft, so that we can try to represent it as well as possible in \nthe JSON representation, and that we can clearly state how the native \nand the JSON representation relate.\n",
          "createdAt": "2017-08-03T18:16:49Z",
          "updatedAt": "2017-08-03T18:16:49Z"
        },
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "I would like to note that these:\r\n\r\n`<http://example.org/>; rel=\"start\", <http://example.org/>; rel=\"http://example.net/relation/other\"`\r\n\r\n`<http://example.org/>; rel=\"start\"; rel=\"http://example.net/relation/other\"`\r\n\r\n`<http://example.org/>; rel=\"start http://example.net/relation/other\"`\r\n\r\nexpress two links as per the abstract model of RFC5988bis: a link has link context, link relation type, link target, optional target attributes. \r\n\r\nAll examples above use a shortcut allowed by the syntax defined in RFC5988bis, in that they don't express the anchor. I agree that this is a shortcut that most likely must also be supported in JSON; and can be supported because the link context can be derived from the interaction anyhow. \r\n\r\nThe second and third example show additional shortcuts allowed by the serialization defined in RFC5988bis. The first example does not use those shortcuts.\r\n* The shortcut used in the second example would cause problems in JSON because the \"rel\" member would have to be repeated to support it. Which is a no go. \r\n* The shortcut in the third example could be supported in JSON, as far as I can tell. But I am uncomfortable with it because it creates a situation in which a space for one value (the value of rel) must be interpreted in another way then a space for other values (say the value of title). I can't say I find that aestethicgally pleasing.\r\n\r\nIn essence, what I am trying to suggest is that I do not think that, because RFC5988bis defines a serialization that supports certain shortcuts, the JSON serialization must support them too. The JSON serialization is a serialization of the abstract link model of RFC5899bis. It is not a transformation of the syntax of RFC5988bis into JSON. I do agree, however that moving back/forth between these serializations should be possible.\r\n\r\nAnd also a question: Are there examples where target attributes (eg title, type, ...) are repeated on links expressed as RFC5988bis? ",
          "createdAt": "2017-08-04T09:33:58Z",
          "updatedAt": "2017-08-04T09:33:58Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-08-04 02:33, Herbert Van de Sompel wrote:\n> The second and third example show additional shortcuts allowed by the \n> serialization defined in RFC5988bis. The first example does not use \n> those shortcuts.\n> \n>   * The shortcut used in the second example would cause problems in JSON\n>     because the \"rel\" member would have to be repeated to support it.\n>     Which is a no go.\n\nafaict, RFC 5988bis explicitly allows repeated target attributes. if a \nserialization of the abstract model disallows this feature, then at \nleast it should say so, and specify how instances of the abstract model \nare supposed to be serialized. there probably are three major options:\n\n- specify that the first occurrence is used and that subsequent \noccurrences must be ignored. for the example used in this issue, this \nwould actually drop a link.\n\n- specify that multiple occurrences must be stringified into one value. \nthis is what the example presented here is using. the downside is that \nthere probably is not universal model how this works (for \"rel\" values \nare space-separated, but other target attributes could define other \nmethods such as comma or semicolon separation).\n\n- specify that multiple target attributes must be folded into one JSON \nmember with multiple values, possibly an array. this is the best \nstructural option but awkward because not target attributes can be \neither strings or arrays or strings.\n\n>   * The shortcut in the third example could be supported in JSON, as far\n>     as I can tell. But I am uncomfortable with it because it creates a\n>     situation in which a space for one value (the value of rel) must be\n>     interpreted in another way then a space for other values (say the\n>     value of title). I can't say I find that aestethicgally pleasing.\n\nsame here. but note that this variant is explicitly allowed in the \ndraft. that's because pretty much all representations of types links \nallow this method of whitespace-separated multiple relation types.\n\n> In essence, what I am trying to suggest is that I do not think that, \n> because RFC5988bis defines a serialization that supports certain \n> shortcuts, the JSON serialization must support them too. The JSON \n> serialization is a serialization of the abstract link model of \n> RFC5899bis. It is not a transformation of the syntax of RFC5988bis into \n> JSON. I do agree, however that moving back/forth between these \n> serializations should be possible.\n\ni think my main question to @mnot is: is the second option (multiple \n\"rel\" on the same link) allowed or disallowed by the draft? but actually \nnow that i am reading through all of it (rtfd!), i see that it is \nexplicitly disallowed. which is good because that takes the second \nexample off the table. but there still are cases where repeated target \nattributes are allowed (see below).\n\n> And also a question: Are there examples where target attributes (eg \n> title, type, ...) are repeated on links expressed as RFC5988bis?\n\nafaict, \"hreflang\" explicitly allows repetition. repetitions are not \nexplicitly disallowed for \"anchor\", but that's probably just an \noversight as it does not make a lot of sense, semantically.\n\nfor \"hreflang\", there actually is the interesting case that we cannot \n\"fold\" multiple occurrences into one stringified value, because \n\"hreflang\" does not allow multiple language tags in one target attribite \nvalue. which gives us an example where we have to decide if/how we want \nto support representing multiple hreflang values on one link value in \nthe JSON representation. @mnot, any opinion on that one?\n",
          "createdAt": "2017-08-04T16:58:28Z",
          "updatedAt": "2017-08-04T16:58:28Z"
        },
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "After another reading of 5899bis, I think I can summarize the \"repeatable\" issue as follows:\r\n- of all the target attributes defined by RFC5988bis, hreflang is the only one that is repeatable\r\n- extensions attributes might be repeatable; it's up to those who define them to specify whether they are or not. the thing is they can be.\r\n\r\nSo, whichever way, we do need a solution for repeatable target attributes.\r\n\r\nNote, however, that relation type (serialized as \"rel\" is not a target attribute). The model for Links clearly separates link relation type from target attributes:\r\n\r\n`In this specification, a link is a typed connection between two\r\n   resources, and is comprised of: a _link context_, a _link relation type_ (Section 2.1), a _link target_, and optionally, _target attributes_ (Section 2.2). A link can be viewed as a statement of the form \"_link context_ has a _link relation type_ resource at _link target_, which has _target  attributes_\".`\r\n\r\nThe confusing thing is that the link-value ABNF construction rules do merge link relation type and target attributes. As a result of that, the spec does not really make it crispy clear that \"rel\" is mandatory. It does state:\r\n\r\n`The \"rel\" parameter MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.`\r\n\r\nwhich does not say there MUST be one \"rel\". But the model above is clear with that regard.",
          "createdAt": "2017-08-07T08:48:06Z",
          "updatedAt": "2017-08-07T08:48:06Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-08-07 01:48, Herbert Van de Sompel wrote:\n> The confusing thing is that the link-value ABNF construction rules do \n> merge link relation type and target attributes. As a result of that, the \n> spec does not really make it crispy clear that \"rel\" is mandatory. It \n> does state:\n> \n> |The \"rel\" parameter MUST NOT appear more than once in a given \n> link-value; occurrences after the first MUST be ignored by parsers.|\n> \n> which does not say there MUST be one \"rel\". But the model above is clear \n> with that regard.\n\nthis sounds reasonable. since the statement about \"rel\" does include \nlanguage about cardinality, it seems as if also stating that there MUST \nbe at least one \"rel\" value would improve the spec language.\n",
          "createdAt": "2017-08-07T17:47:58Z",
          "updatedAt": "2017-08-07T17:47:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think I can do that.",
          "createdAt": "2017-08-09T05:16:15Z",
          "updatedAt": "2017-08-09T05:16:15Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks. https://github.com/mnot/I-D/pull/244 might do the trick.",
          "createdAt": "2017-08-09T21:47:05Z",
          "updatedAt": "2017-08-09T21:47:05Z"
        }
      ]
    },
    {
      "number": 240,
      "id": "MDU6SXNzdWUyNDc1MzMyOTM=",
      "title": "clarify relationship between \"Target Attribute\" and link-param",
      "url": "https://github.com/mnot/I-D/issues/240",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "the current RFC 5988bis draft defines \"Target Attribute\" and uses this term in the spec language, but the syntax definition then uses `link-params` and the current draft says 'This specification defines the link-params \"rel\", \"anchor\", \"rev\", \"hreflang\", \"media\", \"title\", \"title*\", and \"type\"; see Section 3.2, Section 3.3 and Section 3.4.'\r\nwhat is the relationship between \"Target Attribute\" and \"Link Parameter\"? again, the context for this nitpicking is @hvdsomp's and my attempt to come up with a good JSON representation of the RFC 5988bis link model.",
      "createdAt": "2017-08-02T21:51:16Z",
      "updatedAt": "2017-08-11T21:16:03Z",
      "closedAt": "2017-08-11T21:16:03Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "I touched on the same issue in #185. ",
          "createdAt": "2017-08-03T11:03:51Z",
          "updatedAt": "2017-08-03T11:03:51Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-08-03 04:03, Asbj\u00f8rn Ulsberg wrote:\n> I touched on the same issue in #185 \n\ninteresting. i had the same problem understanding the terminology, and \nit seems to me that there still are confusing usages of the terms. for \nexample, the current draft says:\n\n'This specification defines the link-params \"rel\", \"anchor\", \"rev\", \n\"hreflang\", \"media\", \"title\", \"title*\", and \"type\";'\n\nbut that really talks about target attributes i suppose, because what's \ndefined are the abstract concepts (which then of course get serialized, \nbut that's a different issue).\n\nasked differently: what is the benefit of introducing and using these \ndifferent terms?\n",
          "createdAt": "2017-08-03T17:34:39Z",
          "updatedAt": "2017-08-03T17:34:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Target attributes are in the abstract model, link parameters are in the http header serialisation.",
          "createdAt": "2017-08-06T09:30:42Z",
          "updatedAt": "2017-08-06T09:30:42Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for the clarification. but: wouldn't it then be the case that the spec *\"defines target attributes\"* (which then get serialized as link parameters) instead of the spec *\"defining link parameters\"*?",
          "createdAt": "2017-08-06T18:07:51Z",
          "updatedAt": "2017-08-06T18:07:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It says:\r\n\r\n> Target attributes are serialised in the Link header field as parameters (see {{RFC7231}}, Section 3.1.1.1 for the definition of their syntax).\r\n\r\nCan you suggest clarifications?\r\n",
          "createdAt": "2017-08-11T18:55:32Z",
          "updatedAt": "2017-08-11T18:55:32Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "that part reads fine to me. as mentioned above, it's the 'This specification defines the link-params \"rel\", \"anchor\", \"rev\", \"hreflang\", \"media\", \"title\", \"title*\", and \"type\";' part that could be tweaked. afaict, link parameters are an serialization issue and are used to serialize target attributes as well as \"rel\", \"anchor\", \"rev\". so maybe:\r\n\r\n> This specification establishes the link-params \"rel\", \"anchor\", and \"rev\" (which are part of the general link model), as well as \"hreflang\", \"media\", \"title\", \"title*\", and \"type\" (which are the target attributes defined by this specification)\r\n\r\nbut then again on closer reading the spec says that there is no such thing as abstract target attributes defined by it, and that \"hreflang\", \"media\", \"title\", \"title*\", and \"type\" are instead defined for the header serialization only. but that probably doesn't change the fact that \"hreflang\", \"media\", \"title\", \"title*\", and \"type\" indeed are defined as target attributes, and simply are serialized as link parameters.",
          "createdAt": "2017-08-11T19:08:14Z",
          "updatedAt": "2017-08-11T19:08:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "How about:\r\n\r\n> This specification establishes the link-params \"rel\", \"anchor\", and \"rev\" (which are part of the general link model), as well as \"hreflang\", \"media\", \"title\", \"title*\", and \"type\" (which map to target attributes)\r\n\r\n?",
          "createdAt": "2017-08-11T19:28:53Z",
          "updatedAt": "2017-08-11T19:28:53Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On 2017-08-11 12:28, Mark Nottingham wrote:\n>     This specification establishes the link-params \"rel\", \"anchor\", and\n>     \"rev\" (which are part of the general link model), as well as\n>     \"hreflang\", \"media\", \"title\", \"title*\", and \"type\" (which map to\n>     target attributes)\n\nThis specification establishes the link-params \"rel\", \"anchor\", and \n\"rev\" (which are part of the general link model), as well as \"hreflang\", \n\"media\", \"title\", \"title*\", and \"type\" (which are target attributes \ndefined by the Link header serialization).\n",
          "createdAt": "2017-08-11T21:13:38Z",
          "updatedAt": "2017-08-11T21:13:38Z"
        }
      ]
    },
    {
      "number": 241,
      "id": "MDU6SXNzdWUyNDc1NTg0MDM=",
      "title": "check/align JSON representation of RFC 5988bis link sets",
      "url": "https://github.com/mnot/I-D/issues/241",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-wilde-linkset is a new draft @hvdsomp and i have published today. as discussed previously, it defines a JSON-based representation of RFC 5988bis link sets. it would be great to get some feedback about the proposed JSON representation, so that we can make sure that it is as faithful to the RFC 5988bis model as possible, but still is a JSON format that people might use because it easy to understand and use.",
      "createdAt": "2017-08-03T00:16:30Z",
      "updatedAt": "2017-08-06T09:29:11Z",
      "closedAt": "2017-08-06T09:29:11Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, but this isn't an issue on this spec.",
          "createdAt": "2017-08-06T09:29:11Z",
          "updatedAt": "2017-08-06T09:29:11Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "MDU6SXNzdWUyNDgxMzUyNzk=",
      "title": "mention JSON representation in RFC 5988bis draft",
      "url": "https://github.com/mnot/I-D/issues/242",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "it would be great if @hvdsomp's and my draft https://tools.ietf.org/html/draft-wilde-linkset could be mentioned in the sections about target attributes and link parameters. as discussed in #240, these concepts are about the abstract data model and the native serialization.\r\nit would be great if people defining new target attributes would be made aware of the fact that there are alternative serializations, so that they could take into account how their target attributes are working for these. for example, in the current draft (-00), target parameters can not be repeated (because of JSON limitations), meaning that any target attribute that is defined to be repeatable cannot be always serialized in the JSON representation.",
      "createdAt": "2017-08-04T22:55:38Z",
      "updatedAt": "2017-08-04T23:12:06Z",
      "closedAt": "2017-08-04T23:12:06Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Too late for this, it's already at the IESG.",
          "createdAt": "2017-08-04T23:12:06Z",
          "updatedAt": "2017-08-04T23:12:06Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWUyNDgyMzYwNDg=",
      "title": "HTTP OPTIONS for JSON HOME ?",
      "url": "https://github.com/mnot/I-D/issues/243",
      "state": "CLOSED",
      "author": "vasilakisfil",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Just curious: Wouldn't be a good idea to use HTTP OPTIONS to figure out the capabilities of the API through JSON Home?\r\n\r\n> The OPTIONS method requests information about the communication\r\n> options available for the target resource, at either the origin\r\n> server or an intervening intermediary.  This method allows a client\r\n> to determine the options and/or requirements associated with a\r\n> resource, or the capabilities of a server, without implying a\r\n> resource action.\r\n>\r\n> --- [RFC 7231](https://tools.ietf.org/html/rfc7231)\r\n>",
      "createdAt": "2017-08-06T09:25:06Z",
      "updatedAt": "2017-08-06T09:31:41Z",
      "closedAt": "2017-08-06T09:31:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "https://www.mnot.net/blog/2012/10/29/NO_OPTIONS",
          "createdAt": "2017-08-06T09:26:17Z",
          "updatedAt": "2017-08-06T09:26:17Z"
        },
        {
          "author": "vasilakisfil",
          "authorAssociation": "NONE",
          "body": "Thanks for pointing out. I think the only valid argument in this blog post is the requirement set by the same RFC that options should not be cachable (hadn't seen that). I think clients should have already fixed the HTTP OPTIONS implementation, and browser inability to send OPTIONS is true but we don't care for JSON Home.\r\n\r\nI don't see any reason why options should not be cached, do you know this restriction was added in HTTP spec ?",
          "createdAt": "2017-08-06T09:31:41Z",
          "updatedAt": "2017-08-06T09:31:41Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWUyNDk0MTg5NTQ=",
      "title": "can links have multiple link relation types?",
      "url": "https://github.com/mnot/I-D/issues/245",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "over in https://github.com/dret/I-D/issues/73, we're trying to better understand what exactly the abstract link model of RFC5988bis is:\r\n\r\n* is it possible for links to have more than one link relation type?\r\n* or do links always have exactly one type and a `rel=\"x y\"` link serialization is a shortcut that actually represents two distinct links?\r\n\r\nhttps://tools.ietf.org/html/draft-nottingham-rfc5988bis-07#section-2 could be read to mean there is only one relation type. but if that's the case, then maybe https://tools.ietf.org/html/draft-nottingham-rfc5988bis-07#section-3.3 should be more clear about the fact that if the `rel=\"x y\"` syntax is used, this effectively establishes two links?",
      "createdAt": "2017-08-10T17:23:37Z",
      "updatedAt": "2017-08-11T18:51:09Z",
      "closedAt": "2017-08-11T18:51:09Z",
      "comments": []
    },
    {
      "number": 246,
      "id": "MDU6SXNzdWUyNTAxMDc3MDA=",
      "title": "Privacy considerations",
      "url": "https://github.com/mnot/I-D/issues/246",
      "state": "CLOSED",
      "author": "lknik",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The otherwise well-designed document \"Reserving the 418 HTTP Status Code\" could benefit from a modern shakeup, such us the inclusion of privacy considerations - which is becoming the standard in itself. \r\n\r\nNot much can be said about this particularly short spec. But one point could be to consider whether additional status code isn't potentially (1) increasing the fingerprinting surface; and/or (2) placing some HTCPCP devices at the risk of profiling (disclosure of preferences, maybe even system settings) - although this particular point may be more related to the RFC2324 itself. Though protocol design in '90s looked perhaps a bit differently than today. It might be a worthy opportunity to move forward. Yes, I realize it's not 1st, nor the 4th.",
      "createdAt": "2017-08-14T18:04:38Z",
      "updatedAt": "2017-12-14T01:50:09Z",
      "closedAt": "2017-12-14T01:50:09Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Don't think that's in scope for this, but thanks for thinking about privacy!",
          "createdAt": "2017-12-14T01:50:09Z",
          "updatedAt": "2017-12-14T01:50:09Z"
        }
      ]
    },
    {
      "number": 247,
      "id": "MDU6SXNzdWUyNTAxMTAxMzA=",
      "title": "License",
      "url": "https://github.com/mnot/I-D/issues/247",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Would like to copy parts of your Makefiles",
      "createdAt": "2017-08-14T18:14:17Z",
      "updatedAt": "2017-08-14T18:17:46Z",
      "closedAt": "2017-08-14T18:17:46Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Let's say the Makefiles are public domain.",
          "createdAt": "2017-08-14T18:17:46Z",
          "updatedAt": "2017-08-14T18:17:46Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWUyNTcwMDAxODU=",
      "title": "JSON Home support for .well-known/host-meta",
      "url": "https://github.com/mnot/I-D/issues/248",
      "state": "OPEN",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "[RFC 6415](https://tools.ietf.org/html/rfc6415) defines the URI `.well-known/host-meta` which, when dereferenced, is required to respond with an [XRD](http://docs.oasis-open.org/xri/xrd/v1.0/xrd-1.0.html) document.\r\n\r\nSince the purpose of this XRD document and JSON Home is much the same and the semantics of `.well-known/host-meta` seem to fit JSON Home well, would it be wise to add JSON Home support to `.well-known/host-meta` somehow?",
      "createdAt": "2017-09-12T10:51:35Z",
      "updatedAt": "2018-01-29T07:02:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "possibly related to #212",
          "createdAt": "2017-10-10T13:49:12Z",
          "updatedAt": "2017-10-10T13:49:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think an application using host-meta would specify if and how json-home is linked from it, no?",
          "createdAt": "2018-01-29T07:02:44Z",
          "updatedAt": "2018-01-29T07:02:44Z"
        }
      ]
    },
    {
      "number": 250,
      "id": "MDU6SXNzdWUyNjEwNTIwOTI=",
      "title": "RFC5988bis - Need clarification on `parameter_value` decode failure",
      "url": "https://github.com/mnot/I-D/issues/250",
      "state": "CLOSED",
      "author": "uhhhh2",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "rfc5988bis"
      ],
      "body": "In Appendix B.3 \"Parsing Parameters\", if `parameter_name` ends in `*`, the `parameter_value` is to be decoded according to [RFC 5987bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc5987bis-05) (now [RFC 8187](https://tools.ietf.org/html/rfc8187)). If this decode operation fails, should the `parameter_value` be set to:\r\n\r\n1.  The `parameter_value` before the RFC 5987bis/RFC 8187 decoding attempt\r\n2.  The empty string\r\n3.  Something else",
      "createdAt": "2017-09-27T17:13:11Z",
      "updatedAt": "2017-10-02T21:50:11Z",
      "closedAt": "2017-10-02T21:50:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Good question.\r\n\r\nMy instinct would be to remove the star-parameter, and allow it to fall back to the ASCII version of the parameter.\r\n\r\n@reschke is there any best practice here? ",
          "createdAt": "2017-09-28T03:05:10Z",
          "updatedAt": "2017-09-28T03:05:10Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds like a good choice.",
          "createdAt": "2017-09-28T04:20:26Z",
          "updatedAt": "2017-09-28T04:20:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@uhhhh2 the current text is:\r\n\r\n~~~\r\n            5.  If the last character of parameter_name is an asterisk\r\n                (\"*\"), decode parameter_value according to [RFC8187].\r\n                Continue processing input if an unrecoverable error is\r\n                encountered.\r\n~~~\r\n\r\nWhat's ambiguous about that?",
          "createdAt": "2017-10-01T16:16:54Z",
          "updatedAt": "2017-10-01T16:16:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Closing; please comment (ASAP, as it's about to be published) if you think this is still an issue.",
          "createdAt": "2017-10-02T21:50:10Z",
          "updatedAt": "2017-10-02T21:50:10Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWUyNjQwNTQyNDc=",
      "title": "Connections",
      "url": "https://github.com/mnot/I-D/issues/253",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Don't depend on state in connection\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/ietf/SF3k5e76DmMjwtPz9Zt342Q0GSc",
      "createdAt": "2017-10-09T23:24:39Z",
      "updatedAt": "2017-12-14T01:44:43Z",
      "closedAt": "2017-12-14T01:44:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "in httpwg repo now",
          "createdAt": "2017-12-14T01:44:43Z",
          "updatedAt": "2017-12-14T01:44:43Z"
        }
      ]
    },
    {
      "number": 254,
      "id": "MDU6SXNzdWUyNjQxODk1MDU=",
      "title": "relation to servmeta and wether \"API metadata\" should be embedded or outsourced",
      "url": "https://github.com/mnot/I-D/issues/254",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "as mentioned in https://github.com/dret/servmeta/issues/5, the servmeta format (https://github.com/dret/servmeta/blob/master/format.md) does something very similar to the proposed \"API object\". it might be interesting to look at overlaps (and the current format definition lists a number of additional possible link relation to be used).\r\none goal of servmeta was to have a general format for service metadata. this metadata could then link to a variety of resources, such as `home` (https://github.com/mnot/I-D/issues/41) and others. `service-meta` (https://tools.ietf.org/html/draft-wilde-service-link-rel-04#section-4.3) then can be used to discover the initial metadata, with more resources being linked from there.",
      "createdAt": "2017-10-10T11:15:46Z",
      "updatedAt": "2020-02-25T16:56:36Z",
      "closedAt": "2020-02-25T16:56:36Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Seems reasonable...",
          "createdAt": "2020-02-25T06:17:11Z",
          "updatedAt": "2020-02-25T06:17:11Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i'd say that `servmeta` is probably abandoned by now. if you think otherwise, @mamund, please reopen, but otherwise we can safely close this one.",
          "createdAt": "2020-02-25T16:56:36Z",
          "updatedAt": "2020-02-25T16:56:36Z"
        }
      ]
    },
    {
      "number": 257,
      "id": "MDU6SXNzdWUyNjQ3MjY3Nzc=",
      "title": "bcp56bis: URL schemes",
      "url": "https://github.com/mnot/I-D/issues/257",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> The resources identified by the new scheme will still be available with \"http\" and/or \"https\" URLs to clients. While it is possible to define the relationship between these resources in the new scheme's specification, existing HTTP software (such as clients, caches, intermediaries and servers) will not be available, so there is a danger of confusion when the \"wrong\" URL is used.\r\n\r\nI don't understand this statement, particularly \"existing HTTP software will not be available\". I think it's just a word or two missing but I don't know what's appropriate.",
      "createdAt": "2017-10-11T20:34:35Z",
      "updatedAt": "2017-12-14T01:49:09Z",
      "closedAt": "2017-12-14T01:49:09Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "now in httpwg repo",
          "createdAt": "2017-12-14T01:49:09Z",
          "updatedAt": "2017-12-14T01:49:09Z"
        }
      ]
    },
    {
      "number": 259,
      "id": "MDU6SXNzdWUyNjc5Mjk5NTY=",
      "title": "Can we require it for all new headers",
      "url": "https://github.com/mnot/I-D/issues/259",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "structured-headers"
      ],
      "body": "Context: https://mnot.github.io/I-D/structured-headers/\r\n\r\nMy hope was that we could evolve header value parsing by having a fixed \"legacy list\" of HTTP headers whose values need to be parsed using a set of legacy algorithms, specific to those headers and that all new headers could be parsed using the same parser. That would also enable generic typed APIs, rather than APIs that have to know the intricacies of each header name.\r\n\r\nI think that was also @mikewest's goal with JSON header values.\r\n\r\n(The other hope I had was that we could first get implementations fully aligned on existing header value parsers, including error handling, and maybe draw inspiration from that for the new syntax. Code reuse seems preferable over new bugs.)",
      "createdAt": "2017-10-24T07:47:02Z",
      "updatedAt": "2017-12-15T13:22:57Z",
      "closedAt": "2017-12-14T01:48:03Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Individual standards bodies can, of course, whether that's IETF, W3C or WHATWG.\r\n\r\nDoing it for *all* headers is harder, but it might be possible to \"tilt the table\" a bit to encourage this.",
          "createdAt": "2017-10-24T07:51:09Z",
          "updatedAt": "2017-10-24T07:51:09Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "NONE",
          "body": "I would like for us to have some agreement about how we should do headers going forward, so I'm very much on @annevk's page with regard to new things. We should agree on something. Maybe it's this thing! Maybe it's JSON! Maybe it's a binary format! I have opinions, but at the end of the day, I'll live with whatever we can get sufficient consensus on.\r\n\r\nFor old headers, I'm on board with minor compatibility tweaks where implementations currently diverge, but I don't think it would be worth anyone's time to try to move them wholesale to a new format. *shrug* To that end, a legacy list of legacy algorithms makes sense to me.",
          "createdAt": "2017-10-24T08:06:57Z",
          "updatedAt": "2017-10-24T08:06:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "FWIW I think your statement about legacy headers is the consensus position, roughly; we don't want to reinvent the world wholesale, although we *might* go and backport things selectively where there's a (tremendous amount of) will.",
          "createdAt": "2017-10-24T08:30:18Z",
          "updatedAt": "2017-10-24T08:30:18Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I feel like you closed this without some kind of conclusion @mnot. I never meant to suggest we rewrite legacy headers. Just that we make sure we don't introduce more of them by simply not allowing new headers that parse differently (and maybe try to enforce that in header parsing code somehow too). And maybe that we clean legacy headers up based on investigating implementations and figuring out how to deal with spec-impl mismatches.",
          "createdAt": "2017-12-14T19:51:54Z",
          "updatedAt": "2017-12-14T19:51:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Ah, sorry.\r\n\r\nI think the goal for structured headers is to capture *most* new headers, especially ones created by IETF, W3C and WHATWG. Raising that bar to *all* new headers would require it to be more expressive (and therefore more complex). Right now we're trying to figure out what the right level is.\r\n\r\nFrom a process standpoint, I think we'd have a hard time requiring new headers to use it; aside from the issue above, plently of people mint new headers every day, and they can (and will) ignore that requirement.\r\n\r\nI suppose we could say that it is RECOMMENDED that new standards-track headers use it, etc. Would that do it?\r\n\r\n(BTW, the WG has adopted this draft, so discussion should really to go httpwg/http-extensions; feel free to create an issue there if you feel that something in the current draft needs to change).",
          "createdAt": "2017-12-14T23:27:32Z",
          "updatedAt": "2017-12-14T23:27:32Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Thanks, that's not quite what I'm looking for, but I also realized that we forever need byte accessors for header values due to APIs so folks can already do whatever they want.\r\n\r\nThough there is still room for HTTP itself and APIs I suppose to expose a \"get parsed header value\" primitive that always uses this, except for legacy header code paths. But that might require nailing down all the legacy header code paths too.",
          "createdAt": "2017-12-15T13:22:57Z",
          "updatedAt": "2017-12-15T13:22:57Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWUyNjk0NzYwNjA=",
      "title": "Size checks",
      "url": "https://github.com/mnot/I-D/issues/260",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Many of the algorithms in structured-headers are defined as taking input_string and returning a parsed X after modifying input_string to remove the X.  This is a pretty common way of building an inline parser.\r\n\r\nTake label, which describes an initial step of:\r\n\r\n> If input_string contains more than 256 characters, throw an error.\r\n\r\nBut a label can be followed by other things that will cause the overall string to exceed this length.  So this check is invalid.\r\n\r\nI'd recommend moving the size checks into the algorithm body.  If X exceeds length maxlen(X), then throw as you are scrubbing through.",
      "createdAt": "2017-10-30T04:04:19Z",
      "updatedAt": "2017-12-14T01:47:43Z",
      "closedAt": "2017-12-14T01:47:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "now in httpwg repo",
          "createdAt": "2017-12-14T01:47:43Z",
          "updatedAt": "2017-12-14T01:47:43Z"
        }
      ]
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWUyNzI0MTc1Mzk=",
      "title": "AE bias",
      "url": "https://github.com/mnot/I-D/issues/262",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "[ from drwilco ]\r\n\r\nAlmost all browsers don't use q-values in Accept-Encoding, so their ordering might bias what's selected; all browers except Safari put `br` at the end of the list. ",
      "createdAt": "2017-11-09T02:16:01Z",
      "updatedAt": "2018-02-08T05:34:44Z",
      "closedAt": "2018-02-08T05:34:44Z",
      "comments": []
    },
    {
      "number": 263,
      "id": "MDU6SXNzdWUyOTIzMDE3OTc=",
      "title": "difficult to configure",
      "url": "https://github.com/mnot/I-D/issues/263",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "From [thread in capport](https://mailarchive.ietf.org/arch/msg/captive-portals/s9yEY7pt_wINmzXBKscA7-UOUhM), MT says:\r\n\r\n    Generally speaking, there's a trend toward avoiding use of .well-known except when either:\r\n\r\n    * it is difficult to configure or provide a full URL, or\r\n    * the .well-known provides information about the origin as a whole.\r\n\r\nThis seems useful to expand upon.\r\n",
      "createdAt": "2018-01-29T06:56:43Z",
      "updatedAt": "2018-02-02T06:36:39Z",
      "closedAt": "2018-02-02T06:36:39Z",
      "comments": []
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWUyOTIzMDYxNzA=",
      "title": "Accept",
      "url": "https://github.com/mnot/I-D/issues/264",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Need to specify the `Accept` header in Appendix A.",
      "createdAt": "2018-01-29T07:20:21Z",
      "updatedAt": "2018-02-08T05:37:14Z",
      "closedAt": "2018-02-08T05:37:14Z",
      "comments": []
    },
    {
      "number": 265,
      "id": "MDU6SXNzdWUyOTIzMDY3OTc=",
      "title": "mismatch in number of fields",
      "url": "https://github.com/mnot/I-D/issues/265",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Make sure an error happens if `Variants` and `Variant-Key` have a different number of members.",
      "createdAt": "2018-01-29T07:23:18Z",
      "updatedAt": "2018-02-08T05:37:21Z",
      "closedAt": "2018-02-08T05:37:20Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Right now, if Variant-Key has a ",
          "createdAt": "2018-02-08T05:37:20Z",
          "updatedAt": "2018-02-08T05:37:20Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWUyOTI1OTMzMDI=",
      "title": "misuse of well-known",
      "url": "https://github.com/mnot/I-D/issues/266",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "https://news.netcraft.com/archives/2018/01/29/the-hidden-well-known-phishing-sites.html\r\n\r\n",
      "createdAt": "2018-01-29T23:03:38Z",
      "updatedAt": "2018-02-02T06:36:39Z",
      "closedAt": "2018-02-02T06:36:39Z",
      "comments": []
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWUyOTQ5NzYxMDY=",
      "title": "Clarify the introduction",
      "url": "https://github.com/mnot/I-D/issues/267",
      "state": "CLOSED",
      "author": "paulehoffman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "Section 1 starts with \"Some applications on the Web require the discovery of policy or other information about an origin...\". It finishes with \"this memo defines a path prefix in HTTP(S) URIs for these 'well-known locations'\". The beginning of Section 1.1 makes it clear that \"or other information\" is not allowed in the author's eyes, but then the third paragraph goes on to use \"and other metadata\". \r\n\r\nGiven that you have made it clear that you only intend .well-known/ to be used for what you consider site-wide metadata, this draft should be scrubbed of anything other than that.",
      "createdAt": "2018-02-07T01:38:10Z",
      "updatedAt": "2018-02-22T06:21:34Z",
      "closedAt": "2018-02-22T06:21:34Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It's not saying \"policy\" or \"other information\" is inappropriate, provided it's _about_ the origin. Will try to clarify.\r\n",
          "createdAt": "2018-02-07T02:53:10Z",
          "updatedAt": "2018-02-07T02:53:10Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWUyOTQ5NzY3MDc=",
      "title": "Unsupported assertion about applications and URIs",
      "url": "https://github.com/mnot/I-D/issues/268",
      "state": "CLOSED",
      "author": "paulehoffman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "```\r\n   In particular, well-known URIs are not a \"protocol registry\" for\r\n   applications and protocols that wish to use HTTP as a substrate.\r\n   Even if a particular origin is dedicated to the protocol in question,\r\n   it is inappropriate to devote a URL on all origins to a specialist\r\n   protocol that has little or no potential benefit for them.\r\n   Instead, such applications and protocols are encouraged to used a URI\r\n   to bootstrap their operation, rather than using a hostname and a\r\n   well-known URI.\r\n```\r\nThere is no explanation why this is \"inappropriate\" and why forcing every implementation to form its own per-site URI would be more appropriate.",
      "createdAt": "2018-02-07T01:41:30Z",
      "updatedAt": "2018-02-22T06:21:52Z",
      "closedAt": "2018-02-22T06:21:52Z",
      "comments": []
    },
    {
      "number": 269,
      "id": "MDU6SXNzdWUyOTYyODEyNTQ=",
      "title": "Cookies?",
      "url": "https://github.com/mnot/I-D/issues/269",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Would an algorithm to key the cache on a cookie by name work?",
      "createdAt": "2018-02-12T06:57:33Z",
      "updatedAt": "2018-04-02T02:07:04Z",
      "closedAt": "2018-04-02T02:07:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moved to httpwg/http-extensions.",
          "createdAt": "2018-04-02T02:07:04Z",
          "updatedAt": "2018-04-02T02:07:04Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWUyOTYyODEzMjA=",
      "title": "Server Behaviour",
      "url": "https://github.com/mnot/I-D/issues/270",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Probably need to pull out the requirements on servers into a separate section.\r\n\r\nMake sure to give an example with `Variant-Key: identity`",
      "createdAt": "2018-02-12T06:58:06Z",
      "updatedAt": "2018-02-13T02:36:40Z",
      "closedAt": "2018-02-13T02:36:40Z",
      "comments": []
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWUyOTkyMjM3NTk=",
      "title": "non-default ports",
      "url": "https://github.com/mnot/I-D/issues/271",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "In https://github.com/httpwg/http-extensions/issues/455, @martinthomson puts forth that using .well-known on a non-default port in your application is bad practice.\r\n\r\nis it?",
      "createdAt": "2018-02-22T05:09:30Z",
      "updatedAt": "2018-08-01T06:38:38Z",
      "closedAt": "2018-08-01T06:38:38Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That was in the context of discovery using `.well-known`, which is already bad practice. A protocol is probably OK with bootstrapping on a well-defined port it a name is all it has, but allowing arbitrary ports to speak with authority seems risky (noting of course that we don't authenticate ports usually, so it can't be so bad). ",
          "createdAt": "2018-02-22T09:08:05Z",
          "updatedAt": "2018-02-22T09:08:05Z"
        }
      ]
    },
    {
      "number": 272,
      "id": "MDU6SXNzdWUzMDQwMTI3NDg=",
      "title": "Clarifty \"/foo/.well-known/example\"",
      "url": "https://github.com/mnot/I-D/issues/272",
      "state": "CLOSED",
      "author": "fluffy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "\r\nAre you saying that URI MUST NOT have something like \"/foo/.well-known/example\" or are you saying that if they do then it can't be treated as a well known and it is just a name like any other. \r\n\r\nIf you saying the first, that's nuts, people already have too much code that allows any name. If the later, then sure, but that seem to already come from where we say the .well-known has to be at the start of the path. ",
      "createdAt": "2018-03-09T23:29:39Z",
      "updatedAt": "2018-08-01T06:38:28Z",
      "closedAt": "2018-08-01T06:38:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Do you mean a URI being created by a standard, or any URI?",
          "createdAt": "2018-03-10T00:34:28Z",
          "updatedAt": "2018-03-10T00:34:28Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "NONE",
          "body": "Is this like British or American sparrow ? Heck, I have no idea. Lets say an example URI in a standards that is not a well know one. ",
          "createdAt": "2018-03-10T00:55:20Z",
          "updatedAt": "2018-03-10T00:55:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Putting it in an example would be just plain confusing, so that's not something a standard should do.\r\n\r\nA standard specifying .well-known elsewhere in the path is specifically violating both this spec and BCP190.\r\n\r\nA random Web server that decides to use such a path can of course do so -- but if they think it means something, they might be disappointed.",
          "createdAt": "2018-03-10T00:56:55Z",
          "updatedAt": "2018-03-10T00:56:55Z"
        },
        {
          "author": "fluffy",
          "authorAssociation": "NONE",
          "body": "Make sense ... so I did not get that reading this so might need a bit of a tweak. ",
          "createdAt": "2018-03-10T00:58:23Z",
          "updatedAt": "2018-03-10T00:58:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Will see what I can do.",
          "createdAt": "2018-03-10T00:58:56Z",
          "updatedAt": "2018-03-10T00:58:56Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWUzMDUxMzYzMjg=",
      "title": "Multiple Variant-Keys",
      "url": "https://github.com/mnot/I-D/issues/273",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Allow a response to associate itself with more than one variant.",
      "createdAt": "2018-03-14T12:22:26Z",
      "updatedAt": "2018-04-02T02:06:27Z",
      "closedAt": "2018-04-02T02:06:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Moved to httpwg/http-extensions.",
          "createdAt": "2018-04-02T02:06:27Z",
          "updatedAt": "2018-04-02T02:06:27Z"
        }
      ]
    },
    {
      "number": 274,
      "id": "MDU6SXNzdWUzMDg4MDIxMTc=",
      "title": "Underlying data type",
      "url": "https://github.com/mnot/I-D/issues/274",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "Is it still appropriate to use JSON as the underlying data model, or should something like the [Item type   from Structured Headers](http://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#item) be used instead?",
      "createdAt": "2018-03-27T02:43:06Z",
      "updatedAt": "2024-07-02T03:56:11Z",
      "closedAt": "2024-07-02T03:56:11Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Could you please provide an example of how that item type looks like?",
          "createdAt": "2018-03-27T20:19:36Z",
          "updatedAt": "2018-03-27T20:19:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Sorry, not an item. I'm thinking (vaguely, for now) that rather than using JSON, something based upon the data model in structured headers makes more sense; would need to include something like-like, I suspect. ",
          "createdAt": "2018-03-30T02:03:09Z",
          "updatedAt": "2018-03-30T02:03:09Z"
        }
      ]
    },
    {
      "number": 275,
      "id": "MDU6SXNzdWUzMDg4MDIxNzM=",
      "title": "indicate a POST to 201 Created pattern",
      "url": "https://github.com/mnot/I-D/issues/275",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "",
      "createdAt": "2018-03-27T02:43:25Z",
      "updatedAt": "2018-03-30T02:05:06Z",
      "closedAt": "2018-03-30T02:05:06Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See also #207",
          "createdAt": "2018-03-27T02:51:06Z",
          "updatedAt": "2018-03-27T02:51:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm inclined to think this should be defined by the link relation's semantics, not generically.",
          "createdAt": "2018-03-30T02:05:06Z",
          "updatedAt": "2018-03-30T02:05:06Z"
        }
      ]
    },
    {
      "number": 276,
      "id": "MDU6SXNzdWUzMDg4MDMzMDU=",
      "title": "Link Hint Registry",
      "url": "https://github.com/mnot/I-D/issues/276",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "Some thought needs to go into the registry, since registered values are effectively used for ALL link hints in all serialisations that opt into it.",
      "createdAt": "2018-03-27T02:50:29Z",
      "updatedAt": "2024-07-02T03:56:01Z",
      "closedAt": "2024-07-02T03:56:01Z",
      "comments": []
    },
    {
      "number": 277,
      "id": "MDU6SXNzdWUzMTE0NzExMjA=",
      "title": "Applicable schemes in registry",
      "url": "https://github.com/mnot/I-D/issues/277",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "It might be good to capture this.",
      "createdAt": "2018-04-05T04:45:27Z",
      "updatedAt": "2018-08-01T06:33:13Z",
      "closedAt": "2018-08-01T06:33:12Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Enough of the current registrations are wishy-washy about this that it would be difficult to do definitively. ",
          "createdAt": "2018-08-01T06:33:12Z",
          "updatedAt": "2018-08-01T06:33:12Z"
        }
      ]
    },
    {
      "number": 278,
      "id": "MDU6SXNzdWUzMTE0NzEzMjY=",
      "title": "ws wss",
      "url": "https://github.com/mnot/I-D/issues/278",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "Incorporate these?",
      "createdAt": "2018-04-05T04:47:06Z",
      "updatedAt": "2018-08-01T06:36:25Z",
      "closedAt": "2018-08-01T06:36:25Z",
      "comments": []
    },
    {
      "number": 279,
      "id": "MDU6SXNzdWUzMTM1OTY5NDE=",
      "title": "Tweaks",
      "url": "https://github.com/mnot/I-D/issues/279",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "From @britram:\r\n\r\n(1) The document currently treats \"end users\" as a homogeneous group, but of course that's not the case, and in some cases there will be conflicts of interest among end users: say, buyers and sellers of products, or publishers and consumers of content, that from the point of view of the network and platforms they're using are both just users. This document implicitly treats such conflicts as out of scope, but it should explicitly do so to avoid confusion.\r\n\r\n(2) On that point, the example given to define end user (\"a person using a Web browser, mail client, or other agent that connects to the Internet\") does not avoid what I find to be a common implicit assumption in both engineering and civil society discussion about users, that \"using\" the Internet is associated with consumption as opposed to production. There's nothing in the scope of the document that limits it, as such, but having additional examples (\"a person hosting some information on a web server or via a publishing platform\" for instance) might\r\n\r\n(3) In general, since the document (correctly IMO) tries to avoid defining its operable terms (\"end user\", \"harm\", \"benefit\") too tightly, more (and diverse) examples would help the document a bit. I can try to spend some time coming up with useful ones and send a PR in my Copious Free Time if it'd help.",
      "createdAt": "2018-04-12T06:47:46Z",
      "updatedAt": "2019-11-01T06:55:46Z",
      "closedAt": "2019-11-01T06:55:46Z",
      "comments": [
        {
          "author": "britram",
          "authorAssociation": "NONE",
          "body": "amending point two, where I was apparently interrupted:\r\n\r\n>  but having additional examples (\"a person hosting some information on a web server or via a publishing platform\" for instance) might...\r\n\r\n...illustrate that we're concerned about the Internet as a medium for conversation, not a replacement for television.",
          "createdAt": "2019-02-07T08:50:54Z",
          "updatedAt": "2019-02-07T08:50:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "1. Agreed. IIRC it used to be explicit, but that was lost somewhere along the way.\r\n\r\n2. Agreed, and I think easy to fix. \r\n\r\n3. That would be VERY helpful.",
          "createdAt": "2019-02-08T05:05:04Z",
          "updatedAt": "2019-02-08T05:05:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think this is addressed in [draft-iab-for-the-users](https://intarchboard.github.io/for-the-users/draft-iab-for-the-users.html); if not, please open an issue [here](https://github.com/intarchboard/for-the-users/issues). Thanks.",
          "createdAt": "2019-11-01T06:55:46Z",
          "updatedAt": "2019-11-01T06:55:46Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWUzNTIwMTY4MDk=",
      "title": "The json:api:home specification",
      "url": "https://github.com/mnot/I-D/issues/280",
      "state": "CLOSED",
      "author": "krainboltgreene",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "Alright, so I've been working on a sister specification to jsonhome (which has been released for a while) with the first implementation being a ruby gem called jsonapi-home. However, since then I've used it in production and found some weak points that I'm looking to improve upon in a second version. Before committing to that version I was hoping to get insight into my design and maybe contribute to the discourse around jsonhome.\r\n\r\n## type signature\r\n\r\nBelow is the flowtype signature for a payload.\r\n\r\n``` javascript\r\n{\r\n  data: {\r\n    id: string,\r\n    type: string,\r\n    attributes: {\r\n      tags: string | Array<string>,\r\n      resource: string,\r\n      intent: string,\r\n      verb: string,\r\n      details: null | string,\r\n      uri-template: string,\r\n      availability: null | \"healthy\" | \"unhealthy\" | \"down\" | \"unknown\",\r\n      status: \"usable\" | \"deprecated\" | \"gone\",\r\n      supported: boolean,\r\n      allowed-path-parameters: Array<{\r\n        ref: string,\r\n        required: boolean,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n      allowed-query-parameters: Array<{\r\n        ref: string,\r\n        required: boolean,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n      allowed-headers: Array<{\r\n        ref: string,\r\n        required: boolean,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n      returnable-headers: Array<{\r\n        ref: string,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n      allowed-body-parameters: Array<{\r\n        ref: string,\r\n        required: boolean,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n      returnable-body-parameters: Array<{\r\n        ref: string,\r\n        rel: \"plain\" | \"jsonpointer\" | \"jsonpath\",\r\n        href: null | string | Array<string>\r\n      }>,\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nWith an example:\r\n\r\n``` http\r\nGET https://discovery.poutineer.com/v1/jsonapi-home-resources/v1-accounts-show\r\nAccept: application/vnd.api+json\r\n```\r\n\r\n``` json\r\n{\r\n  \"data\": {\r\n    \"id\": \"v1-accounts-show\",\r\n    \"type\": \"jsonapi-home-resources\",\r\n    \"attributes\": {\r\n      \"tags\": [\"v1\"],\r\n      \"resource\": \"accounts\",\r\n      \"intent\": \"show\",\r\n      \"verb\": \"GET\",\r\n      \"details\": \"Returns an account's data\",\r\n      \"uri-template\": \"https://origin.poutineer.com/v1/accounts/{id}\",\r\n      \"availability\": \"healthy\",\r\n      \"status\": \"usable\",\r\n      \"supported\": true,\r\n      \"allowed-path-parameters\": [\r\n        {\r\n          \"ref\": \"{id}\",\r\n          \"rel\": \"plain\"\r\n        }\r\n      ],\r\n      \"allowed-query-parameters\": [\r\n        {\r\n          \"ref\": \"/fields\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"/include\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"/sort\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"/filter\",\r\n          \"rel\": \"jsonpath\"\r\n        }\r\n      ],\r\n      \"allowed-headers\": [\r\n        {\r\n          \"ref\": \"Content-Type\",\r\n          \"required\": true,\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type\"\r\n        },\r\n        {\r\n          \"ref\": \"Authorization\",\r\n          \"required\": true,\r\n          \"rel\": \"plain\",\r\n          \"href\": [\r\n            \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization\",\r\n            \"https://tools.ietf.org/html/rfc6750\",\r\n            \"https://mnot.github.io/I-D/how-did-that-get-into-the-repo/\"\r\n          ]\r\n        },\r\n        {\r\n          \"ref\": \"If-Modified-Since\",\r\n          \"required\": false,\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\"\r\n        },\r\n        {\r\n          \"ref\": \"If-Match\",\r\n          \"required\": false,\r\n          \"rel\": \"plain\",\r\n          \"href\": [\r\n            \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match\"\r\n          ]\r\n        }\r\n      ],\r\n      \"returnable-headers\": [\r\n        {\r\n          \"ref\": \"Date\",\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date\"\r\n        },\r\n        {\r\n          \"ref\": \"Set-Cookie\",\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\"\r\n        },\r\n        {\r\n          \"ref\": \"If-Modified-Since\",\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\"\r\n        },\r\n        {\r\n          \"ref\": \"Etag\",\r\n          \"rel\": \"plain\",\r\n          \"href\": \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Etag\"\r\n        }\r\n      ],\r\n      \"returnable-body-parameters\": [\r\n        {\r\n          \"ref\": \"/data/id\",\r\n          \"rel\": \"jsonpointer\"\r\n        },\r\n        {\r\n          \"ref\": \"/data/type\",\r\n          \"rel\": \"jsonpointer\"\r\n        },\r\n        {\r\n          \"ref\": \"/data/attributes/email\",\r\n          \"rel\": \"jsonpointer\"\r\n        },\r\n        {\r\n          \"ref\": \"$.data.relationships.posts[].data.id\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.data.relationships.posts[].data.type\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.data.relationships.posts[].links.self\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"/data/links\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.included[?(@.type=posts)].id\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.included[?(@.type=posts)].type\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.included[?(@.type=posts)].attributes.title\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.included[?(@.type=posts)].attributes.body\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"$.included[?(@.type=posts)].relationships\",\r\n          \"rel\": \"jsonpath\"\r\n        },\r\n        {\r\n          \"ref\": \"/jsonapi/version\",\r\n          \"rel\": \"jsonpointer\"\r\n        },\r\n        {\r\n          \"ref\": \"/meta/api/version\",\r\n          \"rel\": \"jsonpointer\"\r\n        },\r\n        {\r\n          \"ref\": \"/links/discovery/href\",\r\n          \"rel\": \"jsonpointer\"\r\n        }\r\n      ],\r\n      \"created-at\": \"2018-08-14T20:25:00-07:00Z\",\r\n      \"updated-at\": \"2018-08-15T10:23:30-07:00Z\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## comparing json:api:home to jsonhome\r\n\r\n\r\nDifferences:\r\n\r\n  0. Instead of `preconditionRequired`, `authSchemes`, `acceptRanges`, and `acceptPrefer` we have `allowed-headers`\r\n  0. Instead of `hrefVars` we have `allowed-path-parameters`\r\n  0. Instead of `status` we have `availability`, `status`, and `supported`\r\n  0. Instead of `docs` we have `details`, `intent`, json:api links, and also each parameter has an `href`\r\n  0. Instead of `acceptPatch`, `acceptPost`, and `acceptPut` have `verb`\r\n\r\nExtras:\r\n\r\n  0. json:api compliant: filters, sparse fields, sorting\r\n  0. self-described\r\n  0. has `allowed-headers` and `returnable-headers` which hint at header usage\r\n  0. has payload hinting with `allowed-path-parameters`, `allowed-query-parameters`, `allowed-body-parameters`, and `returnable-body-parameters`\r\n  0. updated-at timestamp so a client can determine how old a defined is\r\n  0. grouping mechanisms (tags, resource)\r\n  0. details, which human descriptions\r\n",
      "createdAt": "2018-08-20T07:32:51Z",
      "updatedAt": "2020-02-25T06:16:21Z",
      "closedAt": "2020-02-25T06:16:21Z",
      "comments": [
        {
          "author": "krainboltgreene",
          "authorAssociation": "NONE",
          "body": "The more I think about it, the more I want to offload \"parameter\" hinting to a single point (for example a link to a json-schema document), but I'm not sure which of these approaches:\r\n\r\n  - A single schema document for body, query, and headers\r\n  - A single schema document for body\r\n  - 3 individual schema documents for body, query, and headers.",
          "createdAt": "2018-09-04T01:22:01Z",
          "updatedAt": "2018-09-04T01:22:01Z"
        },
        {
          "author": "handrews",
          "authorAssociation": "NONE",
          "body": "@krainboltgreene JSON Hyper-Schema has separate schemas for the body (although it is more in terms of target representation vs data for processing), URI Template variables (including but not limited to the query string), and headers.  This works well as they have different usage and re-use patterns.",
          "createdAt": "2018-09-04T15:14:12Z",
          "updatedAt": "2018-09-04T15:14:12Z"
        },
        {
          "author": "krainboltgreene",
          "authorAssociation": "NONE",
          "body": "@handrews This is fantastic to learn! Thanks so much!",
          "createdAt": "2018-09-04T20:22:03Z",
          "updatedAt": "2018-09-04T20:22:03Z"
        },
        {
          "author": "krainboltgreene",
          "authorAssociation": "NONE",
          "body": "I'm going to be releasing a ruby gem that takes rails' internal routing API and generates these endpoints dynamically (cached, of course) and then another library that will take these http resources and turn them into documentation.",
          "createdAt": "2018-12-29T05:49:16Z",
          "updatedAt": "2018-12-29T05:49:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hey, \r\n\r\nThanks for the input, but this is really difficult to reason about, since it's basically a complete (and competing) proposal. If you have specific feedback or suggestions for json home, please do file those as discrete issues. ",
          "createdAt": "2020-02-25T06:16:21Z",
          "updatedAt": "2020-02-25T06:16:21Z"
        }
      ]
    },
    {
      "number": 281,
      "id": "MDU6SXNzdWUzNTI3OTMyNjE=",
      "title": "RFC 5785bis doesn't overtly update RFC 5785",
      "url": "https://github.com/mnot/I-D/issues/281",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "The usual practice is to include a short description of what changes exist over the predecessor.  In this case, the primary change is to broaden the applicability to include web sockets and to remove some restrictions on use.",
      "createdAt": "2018-08-22T03:47:09Z",
      "updatedAt": "2018-08-28T00:16:13Z",
      "closedAt": "2018-08-28T00:16:13Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The nits show 8307 in this as well:\r\n\r\n```\r\n  -- The draft header indicates that this document obsoletes RFC8307, but the\r\n     abstract doesn't seem to mention this, which it should.\r\n\r\n  -- The draft header indicates that this document obsoletes RFC5785, but the\r\n     abstract doesn't seem to directly say this.  It does mention RFC5785\r\n     though, so this could be OK.\r\n```",
          "createdAt": "2018-08-22T03:52:15Z",
          "updatedAt": "2018-08-22T03:52:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I think that the requirement to include updates language in the abstract is stupid, but you will get many complaints about this if you don't.",
          "createdAt": "2018-08-22T03:53:05Z",
          "updatedAt": "2018-08-22T03:53:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm willing to fight it.",
          "createdAt": "2018-08-28T00:16:13Z",
          "updatedAt": "2018-08-28T00:16:13Z"
        }
      ]
    },
    {
      "number": 283,
      "id": "MDU6SXNzdWUzNTI4MDQyMTk=",
      "title": "Normative references for HTTP and thewebsocketprotocol",
      "url": "https://github.com/mnot/I-D/issues/283",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "RFC5785bis defines a refinement of the rules for HTTP and thewebsocketprotocol.  Shouldn't the documents defining those URLs be normative references?",
      "createdAt": "2018-08-22T05:03:25Z",
      "updatedAt": "2018-08-28T00:27:42Z",
      "closedAt": "2018-08-28T00:27:42Z",
      "comments": []
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWUzNTI4MDQ2NjI=",
      "title": "Use a URI for the well-known registry",
      "url": "https://github.com/mnot/I-D/issues/284",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "Julian always does this.  It's https://www.iana.org/assignments/well-known-uris/\r\n\r\nThe name is clear enough for me, but maybe consider it.",
      "createdAt": "2018-08-22T05:06:12Z",
      "updatedAt": "2018-08-28T03:53:41Z",
      "closedAt": "2018-08-28T03:53:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "What do you mean? The spec already has the URL...",
          "createdAt": "2018-08-28T00:23:57Z",
          "updatedAt": "2018-08-28T00:23:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, it's in the \"#procedure\" section rather than in the IANA considerations.",
          "createdAt": "2018-08-28T03:53:41Z",
          "updatedAt": "2018-08-28T03:53:41Z"
        }
      ]
    },
    {
      "number": 285,
      "id": "MDU6SXNzdWUzNTI4NDMxMjI=",
      "title": "Widening the scope of secret-token to encompass all secrets",
      "url": "https://github.com/mnot/I-D/issues/285",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "secret-token"
      ],
      "body": "Is it necessary to scope the `secret-token` scheme to only tokens, or would naming the scheme just `secret` be possible so any secret can be used with it?",
      "createdAt": "2018-08-22T07:59:35Z",
      "updatedAt": "2018-08-28T00:24:35Z",
      "closedAt": "2018-08-28T00:24:35Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I used `secret-token` mostly to make it a slightly more unique name, so as to avoid false positives. I'm happy to clarify the docs to make sure this is understood, or use a different-but-still-unique name (although every time we switch names, there's a certain amount of risk...).",
          "createdAt": "2018-08-22T08:09:02Z",
          "updatedAt": "2018-08-22T08:09:02Z"
        }
      ]
    },
    {
      "number": 286,
      "id": "MDU6SXNzdWUzNjc1ODg1MjY=",
      "title": "replace docs hint with service-doc link relation",
      "url": "https://github.com/mnot/I-D/issues/286",
      "state": "OPEN",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "json-home"
      ],
      "body": "the docs hint proposed in https://mnot.github.io/I-D/json-home/#docs could be substituted by recommending the service-doc link relation instead. generally speaking, maybe it would be helpful to collect a few link relations to use with this format so that users would be more likely to reuse existing link relations.",
      "createdAt": "2018-10-07T20:03:54Z",
      "updatedAt": "2021-11-25T05:31:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 292,
      "id": "MDU6SXNzdWU0MTE0MDEyMDA=",
      "title": "For the users: Just looking forward or also looking back?",
      "url": "https://github.com/mnot/I-D/issues/292",
      "state": "CLOSED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/mnot/I-D/tree/gh-pages/for-the-users says:\r\n\r\n\"... the IETF tends to protect their interests over those of parties such as network operators or equipement (sic) vendors\"\r\n\r\nI'm not sure how historically true that is. I guess we could take that \"we do this already\" approach, or we could take the line that \"this is what we should be doing\" without claiming it as the historic norm. I'm not sure which tactic is likely more effective, but perhaps the latter one is more easily defended.\r\n\r\nResolution of this issue might affect how the later examples section is written.",
      "createdAt": "2019-02-18T10:19:30Z",
      "updatedAt": "2019-11-01T06:54:47Z",
      "closedAt": "2019-11-01T06:54:47Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think this is addressed in [draft-iab-for-the-users](https://intarchboard.github.io/for-the-users/draft-iab-for-the-users.html); if not, please open an issue [here](https://github.com/intarchboard/for-the-users/issues). Thanks.",
          "createdAt": "2019-11-01T06:54:47Z",
          "updatedAt": "2019-11-01T06:54:47Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWU0MjQ2MTg4NDM=",
      "title": "For the Users: \"greatest good for the greatest number\" ",
      "url": "https://github.com/mnot/I-D/issues/297",
      "state": "CLOSED",
      "author": "wseltzer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The focus on end-user benefit is very helpful.  \r\n\r\nAt risk of getting into the weeds, I'm not sure its decision principles are (or need to be) fully worked out. In particular, utilitarian considerations of harm minimization aren't the only way to consider and balance end-user interests. Democratic principles of due process, protection of minority rights, and provision for individuals' collective action also aim to benefit the end-user. \r\n\r\n> When the needs of different end users conflict; for example, between governments and individuals, we again try to minimise harm - this time, to the greatest number and most specific of end users.\r\n\r\nA different argument governments often make is that they *are* the means by which end-users (their citizens) express and protect their interests. Articulation of the principle can help to get through the stakeholder conflict about who speaks for the end-users. \r\n",
      "createdAt": "2019-03-24T14:25:30Z",
      "updatedAt": "2019-11-01T06:55:12Z",
      "closedAt": "2019-11-01T06:55:12Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "That specific text has been removed; the doc has evolved a fair amount. Keeping this open because the 2nd paragraph is useful to keep in mind (thanks!).",
          "createdAt": "2019-07-01T05:24:13Z",
          "updatedAt": "2019-07-01T05:24:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think this is addressed in [draft-iab-for-the-users](https://intarchboard.github.io/for-the-users/draft-iab-for-the-users.html); if not, please open an issue [here](https://github.com/intarchboard/for-the-users/issues). Thanks.",
          "createdAt": "2019-11-01T06:55:12Z",
          "updatedAt": "2019-11-01T06:55:12Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "MDU6SXNzdWU0MjY5NzIyNDI=",
      "title": "Looping redirects",
      "url": "https://github.com/mnot/I-D/issues/298",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "",
      "createdAt": "2019-03-29T12:53:55Z",
      "updatedAt": "2019-07-01T05:18:24Z",
      "closedAt": "2019-07-01T05:18:24Z",
      "comments": []
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWU0NDM5NjgyOTI=",
      "title": "RFC 4941",
      "url": "https://github.com/mnot/I-D/issues/302",
      "state": "CLOSED",
      "author": "coopdanger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "for-the-users"
      ],
      "body": "RFC 4941 doesn't mitigate the potential issues associated with the uniqueness of an IPv6 prefix. RFC 4941 (and 7217 and 8064) mitigate the potential for uniqueness and stability of the interface identifier to be abused, but none of them are effective against abuse of the prefix's uniqueness if a prefix only gets used by a single host.",
      "createdAt": "2019-05-14T15:03:17Z",
      "updatedAt": "2019-07-01T05:19:22Z",
      "closedAt": "2019-07-01T05:19:22Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Could you suggest some text?",
          "createdAt": "2019-05-16T10:38:05Z",
          "updatedAt": "2019-05-16T10:38:05Z"
        },
        {
          "author": "coopdanger",
          "authorAssociation": "NONE",
          "body": "I think I would need to understand better what point you're trying to make with the example. Is this an exception to the guideline of prioritizing users? Or are the mitigation documents meant to exemplify how to prioritize users?",
          "createdAt": "2019-05-16T11:02:30Z",
          "updatedAt": "2019-05-16T11:02:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@britram was it you that supplied this text?",
          "createdAt": "2019-05-16T11:04:32Z",
          "updatedAt": "2019-05-16T11:04:32Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "MDU6SXNzdWU1MTU4ODI4NTc=",
      "title": "Varints?",
      "url": "https://github.com/mnot/I-D/issues/304",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "Integers and floats could be more efficiently represented using something like [this](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#rfc.section.16).\r\n\r\nShould we use it?",
      "createdAt": "2019-11-01T03:02:52Z",
      "updatedAt": "2019-11-01T06:34:51Z",
      "closedAt": "2019-11-01T06:34:51Z",
      "comments": []
    },
    {
      "number": 305,
      "id": "MDU6SXNzdWU1MTU4ODMyMTU=",
      "title": "Huffman codings",
      "url": "https://github.com/mnot/I-D/issues/305",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "Right now, BSH doesn't use Huffman at all. Strings, tokens, keys and TFVs are obvious places to consider. ",
      "createdAt": "2019-11-01T03:04:16Z",
      "updatedAt": "2019-11-01T03:04:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 306,
      "id": "MDU6SXNzdWU1MTU4ODM1NDA=",
      "title": "Byte alignment",
      "url": "https://github.com/mnot/I-D/issues/306",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "Right now, BSH aligns every type. Should it only be the last type in a field-value?",
      "createdAt": "2019-11-01T03:05:40Z",
      "updatedAt": "2019-11-01T06:34:51Z",
      "closedAt": "2019-11-01T06:34:51Z",
      "comments": []
    },
    {
      "number": 307,
      "id": "MDU6SXNzdWU1MTU4ODM3NzI=",
      "title": "Field names for aliased fields",
      "url": "https://github.com/mnot/I-D/issues/307",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "retrofit"
      ],
      "body": "Using separate field-names assures that the different syntax doesn't \"leak\" into normal headers, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this.",
      "createdAt": "2019-11-01T03:06:37Z",
      "updatedAt": "2022-04-29T00:05:42Z",
      "closedAt": "2022-04-29T00:05:42Z",
      "comments": []
    },
    {
      "number": 308,
      "id": "MDU6SXNzdWU1MTU4ODM5MjI=",
      "title": "How deep to go with Cookie aliasing",
      "url": "https://github.com/mnot/I-D/issues/308",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "retrofit"
      ],
      "body": "E.g., should Expires be converted into an integer type?",
      "createdAt": "2019-11-01T03:07:17Z",
      "updatedAt": "2022-04-29T00:05:16Z",
      "closedAt": "2022-04-29T00:05:16Z",
      "comments": []
    },
    {
      "number": 309,
      "id": "MDU6SXNzdWU1MTYxNDY3MTU=",
      "title": "Inventing a new binary format instead of using standards",
      "url": "https://github.com/mnot/I-D/issues/309",
      "state": "CLOSED",
      "author": "paulehoffman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Why does this document invent a new binary format instead of using one that has already been standardized, such as CBOR?\r\n\r\nRequiring client and server implementations to create new parser code introduces a lot of new security threats.\r\n\r\nCBOR's structure looks like it would create smaller headers than the current proposal.",
      "createdAt": "2019-11-01T14:28:17Z",
      "updatedAt": "2021-11-25T05:31:29Z",
      "closedAt": "2021-11-25T05:31:29Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "There is a very real hazard that people will think that *any* CBOR is acceptable there. Besides, this wasn't a problem when creating similar formats -- such as HPACK, QPACK, etc.",
          "createdAt": "2021-11-25T05:31:29Z",
          "updatedAt": "2021-11-25T05:31:29Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWU1MTY0NDQ4Mjk=",
      "title": "Floats and Integers",
      "url": "https://github.com/mnot/I-D/issues/310",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "These need some consideration. We don't want to enable signficantly larger values than allowed by SH, and yet we have more efficient / common ways to do them.",
      "createdAt": "2019-11-02T02:40:30Z",
      "updatedAt": "2022-10-12T05:12:08Z",
      "closedAt": "2022-10-12T05:12:08Z",
      "comments": []
    },
    {
      "number": 312,
      "id": "MDU6SXNzdWU1NDY2ODM1NTA=",
      "title": "Cookie casing",
      "url": "https://github.com/mnot/I-D/issues/312",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "retrofit"
      ],
      "body": "Cookie names and several set-cookie attributes use uppercase, but SH only allows lc in dictionary and parameter keys.\r\n\r\nThe solution is probably to map everything to lowercase explicitly, and to change cookies to use name=\"...\", value=\"...\".",
      "createdAt": "2020-01-08T07:08:30Z",
      "updatedAt": "2022-04-28T23:56:00Z",
      "closedAt": "2022-04-28T23:56:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Cookie parameters are case-insensitive, so this shouldn't be an issue.",
          "createdAt": "2022-04-28T23:56:00Z",
          "updatedAt": "2022-04-28T23:56:00Z"
        }
      ]
    },
    {
      "number": 313,
      "id": "MDU6SXNzdWU1NDcyODU0NTM=",
      "title": "Cookie non-string values",
      "url": "https://github.com/mnot/I-D/issues/313",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "retrofit"
      ],
      "body": "Should it be possible for cookies to recognise (e.g.) binary content?",
      "createdAt": "2020-01-09T06:51:02Z",
      "updatedAt": "2022-04-29T00:05:21Z",
      "closedAt": "2022-04-29T00:05:21Z",
      "comments": []
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWU1ODQwNzgwMDA=",
      "title": "bikeshed-length header: \"decimal\" number of octets?",
      "url": "https://github.com/mnot/I-D/issues/314",
      "state": "CLOSED",
      "author": "ePaul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In [section 2 of today's draft](https://tools.ietf.org/html/draft-nottingham-bikeshed-length-00#section-2):\r\n\r\n> Its value MUST be an Integer (Section x.x of\r\n   [I-D.ietf-httpbis-header-structure]), indicating a decimal number of\r\n   octets for a potential payload body.\r\n\r\n\"Decimal\" is not a kind of number, but a way of representing it (as an alternative to e.g. binary, hexadecimal or octal). You can say it's an integer written in decimal form (but that is already part of the structured header's integer definition, and might be different in other serializations).\r\nBut the number of octets in a payload body is just an (integer) number, nothing decimal about it.\r\n\r\nThis also creates confusion because \"decimal\" is a separate type of structured-header item.\r\n\r\nI would suggest to just remove the \"decimal\" here.",
      "createdAt": "2020-03-19T00:12:55Z",
      "updatedAt": "2022-10-12T23:11:18Z",
      "closedAt": "2022-10-12T23:11:18Z",
      "comments": []
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWU2MTA0OTk3Mjg=",
      "title": "Add examples, move Appendix A contents to section 3 -- .well-known is being used below /",
      "url": "https://github.com/mnot/I-D/issues/315",
      "state": "CLOSED",
      "author": "nicowilliams",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "well-known"
      ],
      "body": "See [today's thread on gen-art about this](https://mailarchive.ietf.org/arch/msg/gen-art/sOfvzujW7MW62LEr3AtWt2uM1kY/).\r\n\r\nThe answer to:\r\n\r\n>    Why aren't per-directory well-known locations defined?\r\n\r\nGiven in Appendix A could be moved into Section 3.\r\n\r\n>       Allowing every URI path segment to have a well-known location\r\n>       (e.g., \"/images/.well-known/\") would increase the risks of\r\n>       colliding with a preexisting URI on a site, and generally these\r\n>       solutions are found not to scale well because they're too\r\n>       \"chatty\".\r\n\r\nAn example like `https://foo.example/.well-known/fooapp/baz.example/stuff`, making it extra clear that well-known names are namespaces, and showing how to use them for multi-tenancy, would help.",
      "createdAt": "2020-05-01T01:31:31Z",
      "updatedAt": "2022-10-12T23:10:29Z",
      "closedAt": "2022-10-12T23:10:29Z",
      "comments": [
        {
          "author": "nicowilliams",
          "authorAssociation": "NONE",
          "body": "This is not urgent.  Perhaps instructions to Expert Reviewers will suffice until there is more reason to update RFC 8615.",
          "createdAt": "2020-05-01T01:32:58Z",
          "updatedAt": "2020-05-01T01:32:58Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWU2MTE2OTEwNDY=",
      "title": "Link Hint to indicate resource class",
      "url": "https://github.com/mnot/I-D/issues/316",
      "state": "CLOSED",
      "author": "hvdsomp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "[https://tools.ietf.org/html/rfc6903#section-6](https://tools.ietf.org/html/rfc6903#section-6) defines the \"type\" link relation type to indicate that a resource is an instance of a certain class of resources.\r\n\r\nHaving a link hint with the same semantics would be helpful e.g. for crawlers that are in search of certain types of resources. It would be very helpful for landing page resources that typically contain links to a range of resources with different content types. For example, in scholarship, such pages link to a scientific paper, a dataset, software, auxiliary materials, etc. The proposed link hint could meaningfully distinguish between these. Currently, only MIME type is available as a distinguishing factor.\r\n\r\n[schema.org](schema.org) has meanwhile minted widely used URIs to indicate many types of creative works. These could be used with a link hint to express resource class to yield powerful interoperability.\r\n\r\n ",
      "createdAt": "2020-05-04T08:24:07Z",
      "updatedAt": "2024-07-02T03:54:39Z",
      "closedAt": "2024-07-02T03:54:39Z",
      "comments": []
    },
    {
      "number": 317,
      "id": "MDU6SXNzdWU2MjcyNDEzMjE=",
      "title": "Correct usage of profiles within Link Hints",
      "url": "https://github.com/mnot/I-D/issues/317",
      "state": "CLOSED",
      "author": "RubenVerborgh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "While reading https://tools.ietf.org/html/draft-nottingham-link-hint-02, I stumbled upon:\r\n\r\n>    The object MAY have a \"links\" member, whose value is an object\r\n   representing links (in the sense of [RFC8288]) whose context is any\r\n   document that uses that format.  Generally, this will be schema or\r\n   profile ([RFC6906]) information. \r\n\r\nHowever, I am not sure how to exactly do that, given the current phrasing of the text.\r\n\r\nCould you confirm whether the following is correct?\r\nI am trying to express that `/orders/523` is available in JSON with two different profiles `http://microformats.org/profile/hcard` and `http://example.org/other`.\r\n\r\n```json\r\n{\r\n  \"_links\": {\r\n    \"self\": {\r\n      \"href\": \"/orders/523\",\r\n      \"hints\": {\r\n        \"formats\": {\r\n          \"application/json\": {\r\n            \"links\": {\r\n              \"self\": {\r\n                \"hints\": {\r\n                  \"profile\": {\r\n                    \"http://microformats.org/profile/hcard\": {},\r\n                    \"http://example.org/other\": {}\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNote that I had to invent the `profile` key; is there a better way?",
      "createdAt": "2020-05-29T12:42:53Z",
      "updatedAt": "2024-07-02T03:54:57Z",
      "closedAt": "2024-07-02T03:54:57Z",
      "comments": []
    },
    {
      "number": 319,
      "id": "MDU6SXNzdWU2MjcyNDQxMTE=",
      "title": "Concerns regarding large Link headers with Link Hints",
      "url": "https://github.com/mnot/I-D/issues/319",
      "state": "OPEN",
      "author": "RubenVerborgh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "Following Appendix A of https://tools.ietf.org/html/draft-nottingham-link-hint-02, the Link Hint JSON structure can be serialized in a `Link` header.\r\n\r\nHowever, this seems to result in rather large `Link` headers, and it seems a strange precedent to stuff JSON in headers.\r\n\r\nWhat is the design rationale behind this?\r\nAren't we better off just _linking_ to a Link Hints document (which could be cached and, with HTTP/2, be pushed)?",
      "createdAt": "2020-05-29T12:47:33Z",
      "updatedAt": "2021-10-06T23:08:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "Actually, the approach to provide a set of links in a dedicated document, as described in the \"linkset\" I-D, could be used for that purpose, see [https://tools.ietf.org/html/draft-wilde-linkset-06](https://tools.ietf.org/html/draft-wilde-linkset-06). ",
          "createdAt": "2020-06-29T06:49:17Z",
          "updatedAt": "2020-06-29T06:49:17Z"
        }
      ]
    },
    {
      "number": 320,
      "id": "MDU6SXNzdWU2NDYxNTI3ODQ=",
      "title": "Timing concerns for Link Hints",
      "url": "https://github.com/mnot/I-D/issues/320",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "over at https://github.com/dret/I-D/issues/141 we're wondering whether we should support link hints or not. the linkset draft is relatively close to completion, so we want to avoid creating dependencies that will slow us down. @mnot, what do you think about timing for that draft?",
      "createdAt": "2020-06-26T10:01:25Z",
      "updatedAt": "2021-11-25T05:33:03Z",
      "closedAt": "2021-11-25T05:33:03Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think this is overcome by events, but if you want to try to get it in, we can talk about adoption. I'd think, however, that hopefully there shouldn't be a hard dependency...",
          "createdAt": "2021-11-25T05:33:03Z",
          "updatedAt": "2021-11-25T05:33:03Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWU3MjE1NDg4MTk=",
      "title": "How to serialize multiple \"item\" links?",
      "url": "https://github.com/mnot/I-D/issues/322",
      "state": "CLOSED",
      "author": "gabesullice",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "Assume that my HTTP API provides a `collection` link, like so:\r\n\r\n```json\r\n\"_links\": {\r\n  \"collection\": {\r\n    \"href\": \"/posts\",\r\n    \"links\": {\r\n      \"item\": {\r\n        \"href\": \"/posts/1\r\n      }\r\n    }\r\n}\r\n```\r\n\r\nSince the `links` hint described in [section 3.3](https://mnot.github.io/I-D/link-hint/#rfc.section.3.3) must be an object, it seems impossible to serialize multiple links with the same link relation type. I.e. if my HTTP API wanted to hint that there is more than one `item` link on the `collection` resource, it wouldn't be able to do so.\r\n\r\nShould the `links` hint value be an array of objects instead?\r\n\r\nIf so, should the draft's examples move away from using object keys to serialize link relation types and instead place them inside the link object itself under a `rel` object key?\r\n\r\nThis would match the serialization proposed here: https://tools.ietf.org/html/draft-pot-json-link-01",
      "createdAt": "2020-10-14T15:13:35Z",
      "updatedAt": "2024-07-02T03:55:34Z",
      "closedAt": "2024-07-02T03:55:34Z",
      "comments": []
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU4NTUyNTMxMTA=",
      "title": "link-hint: broken link in boilerplate",
      "url": "https://github.com/mnot/I-D/issues/324",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "link-hint"
      ],
      "body": "https://github.com/mnot/I-D/commits/gh-pages/link-hint 404s.",
      "createdAt": "2021-04-11T08:44:00Z",
      "updatedAt": "2021-11-25T05:29:52Z",
      "closedAt": "2021-11-25T05:29:52Z",
      "comments": []
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU4OTAwNDk2Nzg=",
      "title": "Wrong HTTP RFC ref'd",
      "url": "https://github.com/mnot/I-D/issues/325",
      "state": "CLOSED",
      "author": "gsnedders",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://mnot.github.io/I-D/binary-structured-headers/#dates should points at https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1, not RFC7230.",
      "createdAt": "2021-05-12T12:45:29Z",
      "updatedAt": "2021-05-13T01:29:30Z",
      "closedAt": "2021-05-13T01:29:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2021-05-13T01:29:29Z",
          "updatedAt": "2021-05-13T01:29:29Z"
        }
      ]
    },
    {
      "number": 330,
      "id": "I_kwDOAAx9P85DJAaR",
      "title": "Representations of time based fields",
      "url": "https://github.com/mnot/I-D/issues/330",
      "state": "CLOSED",
      "author": "fiestajetsam",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "<sub>(this is specifically about retrofit, as [I mentioned on the mailing list](https://lists.w3.org/Archives/Public/ietf-http-wg/2022JanMar/0130.html))</sub>\r\n\r\nSection 3.2 describes several headers where dates are present to use UNIX epoch seconds, and whilst this appears to be a good simplification and optimisation, using UNIX epoch seconds has a few issues such as no longer being human parseable, as well as either server or user-agent having to be able to compute UNIX epoch when sending it _and_ deal with applying leap-seconds to get to UTC when parsing. Whilst this is unlikely to be an issue for the billions of UNIX based systems around the world, it's a new, subtle requirement all the same that someone (embedded systems in particular) may get caught out on.\r\n\r\nSo why not [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)? It is both parseable by (trained) humans and machines, represents civilian time like that it replaces, and is a middle ground of gain in bytes reduced:\r\n\r\n```\r\n'Mon, 07 Feb 2022 19:11:07 GMT' = 29\r\n'2022-02-07T19:11:07Z' = 20\r\n'1644261067' = 10\r\n```\r\n\r\nThis would likely require a bit more text to set some boundaries - maybe things such as week numbers and non-Zulu timezones should be discouraged? This also provides very optional millisecond resolution which some implementations already put into other custom headers.",
      "createdAt": "2022-02-07T19:58:59Z",
      "updatedAt": "2022-05-27T01:04:44Z",
      "closedAt": "2022-05-27T01:04:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "So that would be a `sf-string`, which isn't very efficient to parse/serialise as compared to an integer -- keeping in mind that the longer term goal is [a binary encoding of structured fields](https://mnot.github.io/I-D/draft-nottingham-binary-structured-headers.html). Forcing a parse of data that's carried in a structured format also seems suboptimal.\r\n\r\nThat leaves two options:\r\n\r\n1. Encoding as an integer\r\n2. Defining a new structured type specific to dates\r\n\r\nMy thinking so far has been developer convenience alone isn't enough of a reason to mint a new structured type. Internet developers are broadly familiar with working with Unix epoch dates, and the learning curve is low (especially related to textual date formats).",
          "createdAt": "2022-02-08T00:03:07Z",
          "updatedAt": "2022-02-08T00:03:07Z"
        },
        {
          "author": "fiestajetsam",
          "authorAssociation": "NONE",
          "body": "If the priority is to focus on having both cross-version representation that is significantly more optimised than the incumbent (which I still disagree with), those two options do remain on the cards. \r\n\r\nGoing with the first option of encoding as an integer using UNIX epoch, then all the quirks* of leap seconds and the decrease in accuracy during positive leap seconds have to also be accepted - to be specific it means you cannot represent a value that occurs on a positive leap second and it's unclear what implementations may do differently serving a request in during one. Alternately not using this timescale and instead using UTC seconds tied to a known epoch may negate this, at the complexity of having to do some integer maths.\r\n\r\nI would like to give some more thought to your second option , but are you referring to defining a type based on an existing primitive in RFC 8941 (e.g. using a `sf-list` or something), or defining a new type as extension? \r\nIf it's the former, this may be optimal for binary encoding in HTTP/2, but significantly more bytes on wire and complex to generate/parse for HTTP/1.\r\nIf it's the latter, what's to stop using RFC 3339 with markers to indicate a date format to parse it accordingly instead of first treating it like `sf-string`, or did you have another idea?\r\n\r\n<sub>\\* if the differences are a bit unclear, the table in [RFC 7164 \u00a73.4](https://datatracker.ietf.org/doc/html/rfc7164#section-3.4) does a good job describing what happens during one</sub>",
          "createdAt": "2022-02-08T15:10:51Z",
          "updatedAt": "2022-02-08T15:10:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I was more thinking of the latter - and indeed the textual representation could be 3339.",
          "createdAt": "2022-02-09T04:50:45Z",
          "updatedAt": "2022-02-09T04:50:45Z"
        },
        {
          "author": "fiestajetsam",
          "authorAssociation": "NONE",
          "body": "Well in that case, that works for me and I'd be happy to work on a PR for it - would it make sense to wait until after adoption call is closed and the Github and -00 formalities are done or do you have another idea?",
          "createdAt": "2022-02-09T22:46:09Z",
          "updatedAt": "2022-02-09T22:46:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Introducing a new type to SF would require writing an Internet-Draft and convincing the HTTP WG to adopt it. \r\n\r\nAs I said: personally, I'm not persuaded that the wire presentation of a field is important enough to justify a new type on its own -- especially when you consider that tools (e.g., DevTools) can show a more human-friendly representation when needed.",
          "createdAt": "2022-02-27T03:45:18Z",
          "updatedAt": "2022-02-27T03:45:18Z"
        }
      ]
    },
    {
      "number": 334,
      "id": "I_kwDOAAx9P85Gs7OY",
      "title": "Renaming draft-nottingham-binary-structured-headers to draft-nottingham-binary-structured-fields",
      "url": "https://github.com/mnot/I-D/issues/334",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just to align to the RFC and to make the draft easier to find. Thanks.",
      "createdAt": "2022-03-30T09:45:58Z",
      "updatedAt": "2022-03-30T22:33:42Z",
      "closedAt": "2022-03-30T22:33:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Generally, renaming drafts is counterproductive; they have to go back to 00, etc. Given that the draft name is a temporary artefact (i.e., it won't be part of the published RFC), it's rarely worth it.",
          "createdAt": "2022-03-30T22:33:42Z",
          "updatedAt": "2022-03-30T22:33:42Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "I_kwDOAAx9P85SxKqu",
      "title": "Any chance of link-hints and linked-cache invalidation to become an RFC?",
      "url": "https://github.com/mnot/I-D/issues/336",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi Mark!\r\n\r\nBig fan of your work. We heavily make use of link hints and linked cache invalidation. I was curious if these are drafts that you're still interested in. They're excellent ideas and just wanted to let you know there's people out there that care.\r\n\r\nIf there's anything I can do to further these specs I would be happy to!",
      "createdAt": "2022-09-28T02:19:29Z",
      "updatedAt": "2024-07-02T03:56:36Z",
      "closedAt": "2024-07-02T03:56:36Z",
      "comments": [
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "Since the specs are used in the API sphere, perhaps we could adopt them into the [HTTP API WG](https://datatracker.ietf.org/wg/httpapi/about/)?",
          "createdAt": "2022-09-28T07:41:30Z",
          "updatedAt": "2022-09-28T07:41:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Link Hints is in HTTPAPI. LCI, not sure.",
          "createdAt": "2024-07-02T03:56:36Z",
          "updatedAt": "2024-07-02T03:56:36Z"
        }
      ]
    },
    {
      "number": 337,
      "id": "I_kwDOAAx9P85Tx2eL",
      "title": "Token / key dictionary",
      "url": "https://github.com/mnot/I-D/issues/337",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "It may be worth defining a static dictionary of common values for tokens and keys.",
      "createdAt": "2022-10-12T05:12:52Z",
      "updatedAt": "2022-10-12T05:13:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 338,
      "id": "I_kwDOAAx9P85Tx2mC",
      "title": "h3 negotiation",
      "url": "https://github.com/mnot/I-D/issues/338",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "",
      "createdAt": "2022-10-12T05:13:31Z",
      "updatedAt": "2022-10-12T05:13:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 339,
      "id": "I_kwDOAAx9P85XkMoY",
      "title": "IP reputation links",
      "url": "https://github.com/mnot/I-D/issues/339",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://labs.ripe.net/author/olafur_gudmundsson/what-do-we-know-about-an-ip-address/",
      "createdAt": "2022-11-30T06:17:35Z",
      "updatedAt": "2022-11-30T06:17:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 340,
      "id": "I_kwDOAAx9P85jFglz",
      "title": "Typo: BINARY_STRUCTRED -> BINARY_STRUCTURED",
      "url": "https://github.com/mnot/I-D/issues/340",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "binary-structured-headers"
      ],
      "body": "A typo I noticed in the section header for {{flag}} in draft-nottingham-binary-structured-headers: `BINARY_STRUCTRED` should say `BINARY_STRUCTURED`",
      "createdAt": "2023-04-11T12:37:52Z",
      "updatedAt": "2023-04-12T06:36:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 346,
      "id": "I_kwDOAAx9P86CwaT5",
      "title": "Cookie-Indices should specify how unexpected values are handled",
      "url": "https://github.com/mnot/I-D/issues/346",
      "state": "OPEN",
      "author": "jeremyroman",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "availability-hints"
      ],
      "body": "(re. draft-nottingham-http-availability-hints)\r\n\r\n@mnot's suggestion via email was:\r\n* ignore unrecognized parameters\r\n* treat other unexpected data structures like a syntax error and ignore the field (i.e., falling back to vary)\r\n\r\nI think this makes sense; it fails safe for most cases and if we ever added a parameter where it would be incorrect for existing implementations to ignore it, we could add a `must-support-whizbang` or similar token which older implementations would reject.\r\n\r\nFiled this as an issue both because it's slightly less trivial to actually make this change as I sit here, and because it's nuanced enough that someone might have second thoughts before someone sits down to address this.",
      "createdAt": "2024-03-19T00:13:40Z",
      "updatedAt": "2024-07-02T03:53:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jeremyroman",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One remaining case -- strings which are not valid cookie names in RFC 6265, such as strings containing one of the `separators` characters. Some of these are also accepted as cookies by browsers (well, at least Chromium browsers -- I haven't dug into Mozilla and WebKit), and some are not.\r\n\r\nOne possibility is to say that strings that don't match the `cookie-name` production are ignored (or stricter, constitute a syntax error in the entire header). Alternatively, we could accept all strings (that consist of printable ASCII characters) and simply rely on the fact that they will never compare equal to a cookie that the HTTP implementation never stored (whatever limitations it applies to cookie names).",
          "createdAt": "2024-03-19T14:26:50Z",
          "updatedAt": "2024-03-19T14:26:50Z"
        }
      ]
    },
    {
      "number": 347,
      "id": "I_kwDOAAx9P86K_kKJ",
      "title": "Cookie-Indices should specify how duplicate cookies are treated",
      "url": "https://github.com/mnot/I-D/issues/347",
      "state": "CLOSED",
      "author": "jeremyroman",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is possible for two cookies with the same name to be presented in a request (for example, because they have different paths, both of which match the request URI). However, the algorithm refers to \"the value of the cookie with the name\", which is not well-defined if there are multiple such cookies.\r\n\r\nFor example, `Cookie: foo=baz; foo=bar` is a valid request header field that implementations (Chromium, at least) can and do send.\r\n\r\nI think what these values should be treated as an unordered list (i.e., they are equivalent if the values present for each cookie are the same, and the number of times each is present is also the same). This is analogous to how the order of cookies of with distinct names can be reordered at present.",
      "createdAt": "2024-06-03T19:51:13Z",
      "updatedAt": "2024-06-12T04:16:17Z",
      "closedAt": "2024-06-12T04:16:17Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5NjM4NA==",
      "title": "first try, added the draft XSDs to http-problem and home-documents",
      "url": "https://github.com/mnot/I-D/pull/4",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2012-08-19T02:44:47Z",
      "updatedAt": "2012-10-13T19:09:15Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "2697ba2729544037bf38f32e8e6b8cf6a2a356a9",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "32c843acb3a6b55995fa9d0073d9b06f2a929e4a",
      "closedAt": "2012-10-13T19:09:15Z",
      "mergedAt": "2012-10-13T19:09:15Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "054333ae57d034d9ffd155b893998eed439adbda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMwMjgzNQ==",
      "title": "minor tweaks and indented suggestions",
      "url": "https://github.com/mnot/I-D/pull/5",
      "state": "MERGED",
      "author": "royfielding",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is probably an easier way to send comments, but what the heck ...\n",
      "createdAt": "2012-09-11T08:12:22Z",
      "updatedAt": "2012-09-13T05:15:43Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "65603db26f864b6f99c608242197f5d4627a1624",
      "headRepository": "royfielding/I-D",
      "headRefName": "master",
      "headRefOid": "fb91ed693e1725d61086251faa7c7cb4afec8098",
      "closedAt": "2012-09-11T09:52:34Z",
      "mergedAt": "2012-09-11T09:52:34Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "4ffc4f20f43abe00f3b8ddf87a4af8fdf522da55"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "You ask \"Are the modifiers case-insensitive?\" -- do you mean their names (e.g., \"STR\" vs \"str\")?\n\nI have no problem making them case insensitive by default (tho interaction with RFC5987 would be interesting... probably need to say something about that anyway, maybe in -01).\n\nWill respond to others in a bit.\n",
          "createdAt": "2012-09-11T08:25:43Z",
          "updatedAt": "2012-09-11T08:25:43Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, I suppose it is defined as insensitive by the ABNF.\n",
          "createdAt": "2012-09-11T09:29:49Z",
          "updatedAt": "2012-09-11T09:29:49Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That'll teach me to click a button when I can only see the left half.\n",
          "createdAt": "2012-09-11T09:30:44Z",
          "updatedAt": "2012-09-11T09:30:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Context:\n\nIn particular, a cache that implements the Key header field MUST NOT use a\nstored response unless all of the selecting header fields nominated by the \nKey header field match in both the original request (i.e., that associated\nwith the stored response) and the presented request.\n\nYou asked:\n\n```\nDoes this mean the cache doesn't respond to the original request?\nOr just doesn't cache the response? Is it necessary?\n```\n\nIt means that the stored response isn't used if there isn't a complete match (as defined by Key) between the request headers and response headers.\n",
          "createdAt": "2012-09-11T09:56:30Z",
          "updatedAt": "2012-09-11T09:56:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "You asked:\n\n```\nWhat happened to tok? How about word? I prefer those to str.\n```\n\ns/str/word/g? Sure, will do.\n\n```\nAre the modifiers case-insensitive?\n```\n\nThink this is answered above. Need prose to remind people?\n\n```\nDo we have a use case for \"end\"? (it is harder to check).\n```\n\nAm fine with axing it.\n\n```\nIt seems odd that we use 3 letters for everything except the\nflags (e.g., not).  We could make them all 1 (t,s,b,e,i,n).\n```\n\nWas thinking along similar lines. Is making flags uppercase a reasonable convention?\n",
          "createdAt": "2012-09-11T09:59:49Z",
          "updatedAt": "2012-09-11T09:59:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, I think that's all incorporated; please have a look. I'm not 100% happy with the text around case sensitivity, but it's workable for now, I think.\n",
          "createdAt": "2012-09-11T11:24:59Z",
          "updatedAt": "2012-09-11T11:24:59Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Sep 11, 2012, at 2:56 AM, Mark Nottingham wrote:\n\n> Context:\n> \n> In particular, a cache that implements the Key header field MUST NOT use a\n> stored response unless all of the selecting header fields nominated by the \n> Key header field match in both the original request (i.e., that associated\n> with the stored response) and the presented request.\n> \n> You asked:\n> \n> Does this mean the cache doesn't respond to the original request?\n> Or just doesn't cache the response? Is it necessary?\n> It means that the stored response isn't used if there isn't a complete match (as defined by Key) between the request headers and response headers.\n\nOkay.  I was thinking it might not match the original if the\ncached response contains a Set-Cookie and the key checks\nfor that cookie, but now I can't think of any reason why we\nwould need to allow that -- it would be unreliable, regardless.\n\nThe current state is fine with me --- you can delete this\nindented question before shipping.\n\n....Roy\n",
          "createdAt": "2012-09-12T03:00:55Z",
          "updatedAt": "2012-09-12T03:00:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, will submit when I get up in the AM unless I hear differently.\n",
          "createdAt": "2012-09-12T11:39:11Z",
          "updatedAt": "2012-09-12T11:39:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "One thing to discuss -- you removed the OWS from around the semicolon. That's not how we do it elsewhere; e.g., https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/latest/p1-messaging.html#transfer.codings\n\nI'd like to avoid creating lots of slightly different syntaxes, if we can...\n",
          "createdAt": "2012-09-12T12:52:02Z",
          "updatedAt": "2012-09-12T12:52:02Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Sep 12, 2012, at 5:52 AM, Mark Nottingham wrote:\n\n> One thing to discuss -- you removed the OWS from around the semicolon. That's not how we do it elsewhere; e.g., https://svn.tools.ietf.org/svn/wg/httpbis/draft-ietf-httpbis/latest/p1-messaging.html#transfer.codings\n\nI know, but that's because of legacy ...\n\n> I'd like to avoid creating lots of slightly different syntaxes, if we can...\n\nI guess it doesn't matter -- i just hate to waste bytes by allowing\npeople to send spaces where they don't serve a useful purpose.\nWe can change it back on the next draft, if you like.\n\n....Roy\n",
          "createdAt": "2012-09-13T05:15:43Z",
          "updatedAt": "2012-09-13T05:15:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY5MDkwOQ==",
      "title": "some work on incorporating XML and the instance link",
      "url": "https://github.com/mnot/I-D/pull/7",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i have made some small changes to the text to reflect the XML and the instance link changes. let me know what you think. if you like the general direction, i can spend a little more time trying to get the next version ready.\n",
      "createdAt": "2012-10-18T08:04:56Z",
      "updatedAt": "2012-10-22T03:49:31Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "5b45b4cc44b21e5af85fe505b11bb0cc0a61e94e",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "be8b804833137a5dffeabacc608df05744db1d70",
      "closedAt": "2012-10-22T03:48:59Z",
      "mergedAt": "2012-10-22T03:48:59Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "86251ede5b306bfc4a20070f6c943a23cd79fe37"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i am not quite sure this is the way things are supposed to happen... did you see my changes and were you able to get the updated version?\n",
          "createdAt": "2012-10-21T19:57:16Z",
          "updatedAt": "2012-10-21T19:57:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "looks good; will do a bit more cleanup (e.g., you shouldn't use the word \"should\" as that gets confused with the RFC2119 language; \"ought\" is better).\n",
          "createdAt": "2012-10-22T03:49:31Z",
          "updatedAt": "2012-10-22T03:49:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0NjYzMw==",
      "title": "next set of (minor) changes",
      "url": "https://github.com/mnot/I-D/pull/8",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "added some (also minor) modifications for json-home\n",
      "createdAt": "2012-10-23T19:00:55Z",
      "updatedAt": "2014-06-18T12:05:54Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "1b8682b5a8b0b3df14e14c3cd6dd4075602b1967",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "2383ce7aec8195ebc4c0091a261826d52f58604f",
      "closedAt": "2012-12-06T23:09:28Z",
      "mergedAt": "2012-12-06T23:09:28Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e8477ba21e27b34f95c2b3e4b1f6d29023f4b9b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwMjU1MQ==",
      "title": "fixed XSD xs:any issue",
      "url": "https://github.com/mnot/I-D/pull/9",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2012-12-17T23:17:12Z",
      "updatedAt": "2012-12-18T00:37:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "5342d2fe3b044a8f432e5f7b724531a40824bfe0",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "cb41da3b26842c4dae948f822379a49318ea2f1d",
      "closedAt": "2012-12-18T00:37:53Z",
      "mergedAt": "2012-12-18T00:37:53Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e5de57e6f143ef67f44a445596c168437b3b6473"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcwMTQyNg==",
      "title": "created -03",
      "url": "https://github.com/mnot/I-D/pull/10",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "testing the setup, and adding me as an author.\n",
      "createdAt": "2013-01-16T14:42:07Z",
      "updatedAt": "2014-07-20T19:43:35Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "6e3476654f8f812e8c638bcdd68befe0fcd0f8fe",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "54f291216090ed5ad8e62912f1bfaf4924457e28",
      "closedAt": "2013-02-08T04:26:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Stuff relevant to problem is incorporate separately.\n",
          "createdAt": "2013-02-08T04:26:39Z",
          "updatedAt": "2013-02-08T04:26:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1MjcyNg==",
      "title": "fixing the pull/merge problem, some text edits",
      "url": "https://github.com/mnot/I-D/pull/11",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-02-08T09:28:14Z",
      "updatedAt": "2014-06-14T11:33:49Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "ce6019fcc2384cf205cd0f552b859c5ca58b5372",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "04632e8252e65d61cd9d0e889e15ee36a3a3e3e1",
      "closedAt": "2013-02-11T04:13:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I'm not going to merge this, because there's just too much going on; please limit your pull requests to logically related changes, and don't change conventions (e.g., the date line, creating HTML).\n\nI'll go through and apply the ones that make sense manually, then close. I'd suggest you use that as the starting point for any future changes.\n",
          "createdAt": "2013-02-11T04:03:08Z",
          "updatedAt": "2013-02-11T04:03:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Incorporated with ff992d05. You also had:\n\n```\nIs it always necessary to specify a problem media type in an Accept header, or would it also be permissible to serve them even if the client did not list them?\n```\n\nIt's not the job of this spec to clarify (or worse, override) HTTP; we can't change how conneg works.\n",
          "createdAt": "2013-02-11T04:13:39Z",
          "updatedAt": "2013-02-11T04:13:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "hello mark.\n\n> I'm not going to merge this, because there's just too much going on;\n> please limit your pull requests to logically related changes, and don't\n> change conventions (e.g., the date line, creating HTML).\n\nso you'd prefer if i created branches and then created pull requests for \nthese? and if i make changes about different things, then each of those \nshould be in their own branch with their own pull requests? i still have \nto figure out some of the git mechanics, i have tried to google things \nto make sure i am a good git citizen, but it seems to me that different \npeople promote different styles of how to best handle collaborative \nchanges. if you just tell me the sequence of steps you'd prefer, i'll \nstick to that.\n\n> I'll go through and apply the ones that make sense manually, then close.\n> I'd suggest you use that as the starting point for any future changes.\n\nsure. from now on i should probably start using branches, so that \nchanges are logically related.\n\nthanks and cheers,\n\ndret.\n",
          "createdAt": "2013-02-12T09:06:26Z",
          "updatedAt": "2013-02-12T09:06:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExOTgzNw==",
      "title": "editorial changes",
      "url": "https://github.com/mnot/I-D/pull/12",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-02-13T09:10:41Z",
      "updatedAt": "2014-06-13T01:13:27Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "e8a3911e0f3caac5fb82f722fa0d4a9fefbfb80f",
      "headRepository": null,
      "headRefName": "editorial",
      "headRefOid": "9ea283980594b7f8df55947a968871e25beca249",
      "closedAt": "2013-02-14T00:53:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Cant' be merged; see e-mail.\n",
          "createdAt": "2013-02-14T00:53:31Z",
          "updatedAt": "2013-02-14T00:53:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNTE0Ng==",
      "title": "XSD -> RNG",
      "url": "https://github.com/mnot/I-D/pull/13",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i have switched from XSD to RNG, but the question still is whether the XML should require the standard fields before any extensions.\n",
      "createdAt": "2013-02-13T15:18:27Z",
      "updatedAt": "2013-02-14T00:54:24Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "e8a3911e0f3caac5fb82f722fa0d4a9fefbfb80f",
      "headRepository": null,
      "headRefName": "schema",
      "headRefOid": "5d1f7e2818cb2b8eefc20ecc52a28247c9a08c98",
      "closedAt": "2013-02-14T00:54:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Can't be automatically merged; see e-mail\n",
          "createdAt": "2013-02-14T00:54:24Z",
          "updatedAt": "2013-02-14T00:54:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMTQ2NA==",
      "title": "moving from XSD to RNG",
      "url": "https://github.com/mnot/I-D/pull/14",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i have no idea why now that i look at the pull request, it shows that again there are TXT/HTML and other stuff in it. it seems i am unable to create the workflow you'd like to see. as much guidance as possible would be very much appreciated, while i am trying to cancel this pull request. i see this as part of a git/github learning experience, but a little higher ratio of experience and results would make things a little more fun.\n",
      "createdAt": "2013-02-19T15:50:48Z",
      "updatedAt": "2013-02-19T16:21:03Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "246128d78790550ae3d3c97bc32d1971dd06c7d4",
      "headRepository": null,
      "headRefName": "schema",
      "headRefOid": "5d1f7e2818cb2b8eefc20ecc52a28247c9a08c98",
      "closedAt": "2013-02-19T16:21:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe i can close the pull request myself? giving it a try...\n",
          "createdAt": "2013-02-19T16:21:03Z",
          "updatedAt": "2013-02-19T16:21:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI3OTcyMA==",
      "title": "numerous changes that piled up locally",
      "url": "https://github.com/mnot/I-D/pull/15",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i finally gave up after many frustrating tries with the old fork, and now trying to save my changes from the old fork over to a new one. maybe some changes are missing here, but at least here are some of the changes i committed in the last couple of weeks. i guess i have a better workflow now (and will write a blog entry about it, so if you like you can validate it), and will try to always properly rebase and submit pull requests in topic branches.\n",
      "createdAt": "2013-02-22T18:15:39Z",
      "updatedAt": "2014-07-09T16:59:56Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "ce04ba950d5e913d5743cf2977ecc03645f08682",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/home-schema",
      "headRefOid": "7ac87e967329ace6c9fac43b297d95b3fa4e651f",
      "closedAt": "2013-03-01T09:32:38Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "still open, but now messed up by pulling from upstream. please see my email.\n",
          "createdAt": "2013-02-28T16:44:39Z",
          "updatedAt": "2013-02-28T16:44:39Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "seems like this one cannot be saved (at least not by me). giving up and creating another pull request with the same changes.\n",
          "createdAt": "2013-03-01T09:31:52Z",
          "updatedAt": "2013-03-01T09:31:52Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i guess this one now can simply be ignored, and i'll be deleting the branch in a little while.\n",
          "createdAt": "2013-03-01T09:32:38Z",
          "updatedAt": "2013-03-01T09:32:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MjExNg==",
      "title": "XSD -> RNG ; fixing apostrophes",
      "url": "https://github.com/mnot/I-D/pull/16",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "this is the other set of files i sent you (the changes for http-problem). again, more than just one change, due to a number of lost commits. but at least this time it should just be all changes, and not a lot of noise.\n",
      "createdAt": "2013-02-22T20:20:11Z",
      "updatedAt": "2013-02-26T07:54:24Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "ce04ba950d5e913d5743cf2977ecc03645f08682",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/problem-changes",
      "headRefOid": "453386f4fe23be3a1e936af53931a572e125a48a",
      "closedAt": "2013-02-24T23:28:28Z",
      "mergedAt": "2013-02-24T23:28:28Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "20dc1791949e43b56168a4256397ac87ca80d607"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "i see this pull request as being both merged and closed. i find that to be a bit confusing, do you know what happened? and is your typing into comment boxes as ridiculously slow as mine?\n",
          "createdAt": "2013-02-25T14:07:04Z",
          "updatedAt": "2013-02-25T14:07:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I merged it, and that closed the associated issue - what's confusing?\n\nTyping is fine for me...\n",
          "createdAt": "2013-02-25T21:37:59Z",
          "updatedAt": "2013-02-25T21:37:59Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "it was just that \"closing\" in the earlier cases meant basically rejecting the pull request. anyway, i was just wondering about the terminology.\n\nand i am really wondering what's going on with my typing, it's always crazy slow.\n",
          "createdAt": "2013-02-26T07:54:24Z",
          "updatedAt": "2013-02-26T07:54:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODA3MQ==",
      "title": "once again trying to recreate the set of old changes",
      "url": "https://github.com/mnot/I-D/pull/17",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "maybe i am getting lucky this time!\n",
      "createdAt": "2013-03-06T19:30:36Z",
      "updatedAt": "2013-04-01T23:23:21Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "5c19ee342447a92587204fb84741c6673fb8bb3f",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/home-schema2",
      "headRefOid": "38473d5e4642fb08b019fe8796ba88eebc6ceab6",
      "closedAt": "2013-03-29T05:41:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so how would you prefer the XML side to move forward? separate draft that is going to be merged?\n",
          "createdAt": "2013-03-31T15:14:26Z",
          "updatedAt": "2013-03-31T15:14:26Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "just checking: you did see that i made a couple of changes to the draft's text itself, and not just about the XML syntax, right?\n",
          "createdAt": "2013-04-01T23:23:21Z",
          "updatedAt": "2013-04-01T23:23:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4MjYwMg==",
      "title": "added -04, just added my //author/address/uri",
      "url": "https://github.com/mnot/I-D/pull/18",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-03-06T22:49:10Z",
      "updatedAt": "2013-03-29T01:47:56Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "5c19ee342447a92587204fb84741c6673fb8bb3f",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/problem-edits",
      "headRefOid": "41eb944f02e302373cd43afe561174df9474193d",
      "closedAt": "2013-03-28T10:59:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I've manually copied and committed. It's easier if you just ask me to create a new version, rather than doing it yourself, as that make it possible to track changes...\n",
          "createdAt": "2013-03-28T10:59:05Z",
          "updatedAt": "2013-03-28T10:59:05Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks. i'll delete my branch, then.\n",
          "createdAt": "2013-03-29T01:47:56Z",
          "updatedAt": "2013-03-29T01:47:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2NzU5MA==",
      "title": "updating media types to \"+json\" convention",
      "url": "https://github.com/mnot/I-D/pull/19",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "i am getting comments on the name difference between the XML media type and the JSON media type. the idea is to adopt the +json convention, right? also, i fixed the JSON Patch media type name in the example.\n",
      "createdAt": "2013-05-28T16:17:36Z",
      "updatedAt": "2013-06-26T16:49:38Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "a3df0bc2f56aeaefb1c9764fce5385a65dad6e91",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/homemediatype",
      "headRefOid": "4a58bfdadb2433e7f4c1d81a4bcf7cb983b70844",
      "closedAt": "2013-06-26T07:35:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "The changes have to be done in draft.md, not the XML. I'm probably going to do this, but want to wait until the format settles down, so that we have a clean transition.\n",
          "createdAt": "2013-06-26T07:35:05Z",
          "updatedAt": "2013-06-26T07:35:05Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "regardless of the final media type name, it would be good for the JSON and XML media types to follow the same convention. currently, the XML draft uses the +xml convention.\n",
          "createdAt": "2013-06-26T16:49:22Z",
          "updatedAt": "2013-06-26T16:49:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2NTkwOQ==",
      "title": "adding -04 files for the XML syntax",
      "url": "https://github.com/mnot/I-D/pull/20",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-06-02T16:48:05Z",
      "updatedAt": "2013-06-03T00:19:16Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "2d1c3b34514d1eeb30ef2522e7e8135ed2b9beb3",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/problem-04",
      "headRefOid": "8c42686593ea18647829d28feecd578d96a1cd53",
      "closedAt": "2013-06-03T00:09:37Z",
      "mergedAt": "2013-06-03T00:09:37Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e48e7bac6ae9cf84d45488b6152f25e2dcedf347"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIzNDk0Ng==",
      "title": "minor typo",
      "url": "https://github.com/mnot/I-D/pull/22",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-06-11T00:26:15Z",
      "updatedAt": "2013-06-25T03:52:20Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "c1cc1d5dc2749332b9ca2d63e71c28bd9390b4b8",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/hint-typos",
      "headRefOid": "973557139df0be83844dc8b87d3bdbb6a0538fd9",
      "closedAt": "2013-06-25T03:34:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Fixed in fcb7d51f (needs to be done in the markdown copy, not the XML).\n",
          "createdAt": "2013-06-25T03:34:40Z",
          "updatedAt": "2013-06-25T03:34:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NjU2NjU5Mw==",
      "title": "use registered JSON Patch media type",
      "url": "https://github.com/mnot/I-D/pull/26",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "update patch media type to the one that has been registered by RFC 6902 (adding the +json suffix)\n",
      "createdAt": "2013-06-26T16:57:15Z",
      "updatedAt": "2013-06-27T05:44:41Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "fcb7d51f9b6f0d1314e952190640ecd296903c6e",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/home-patch-media-type",
      "headRefOid": "5f499ce15c1404244f26473325911dd20b43b933",
      "closedAt": "2013-06-27T05:02:48Z",
      "mergedAt": "2013-06-27T05:02:48Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "84ba4ee0cdfa928b0b149c8240a0eec9f93a6c3e"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!\n",
          "createdAt": "2013-06-27T05:02:52Z",
          "updatedAt": "2013-06-27T05:02:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMzMDI3Mg==",
      "title": "some typos",
      "url": "https://github.com/mnot/I-D/pull/27",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "more feedback via email. generally speaking, i like the idea and should be doing this for internal use anyway. let me know if you could need some help.\n",
      "createdAt": "2013-08-01T18:02:47Z",
      "updatedAt": "2013-09-05T18:06:20Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "94be0b73821646cf1d3c42855e617adc9dd68ff5",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/uri-structure-typos",
      "headRefOid": "13791738152c79534fd4dc1598af98555cb8682c",
      "closedAt": "2013-08-29T02:17:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Fixed manually. Thanks!\n",
          "createdAt": "2013-08-29T02:17:46Z",
          "updatedAt": "2013-08-29T02:17:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0ODY2Nzc2Mw==",
      "title": "adding -05 files for XML syntax",
      "url": "https://github.com/mnot/I-D/pull/29",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-09-27T16:36:53Z",
      "updatedAt": "2014-06-13T15:06:29Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "8a1517bd5f9e46853dbe64b34cb928a405f21dde",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/add-05",
      "headRefOid": "18bce8a55aebc9cbc5281f42b8147b58ae817792",
      "closedAt": "2013-09-30T04:18:39Z",
      "mergedAt": "2013-09-30T04:18:39Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "b3325666ed77119e9906ec2d14d23a7dfd671cb6"
      },
      "comments": [
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "of course i'd need to change these if we change the names for the compound terms...\n",
          "createdAt": "2013-09-30T16:46:33Z",
          "updatedAt": "2013-09-30T16:46:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0ODY5NjMxNQ==",
      "title": "Friday's edits for your thoughts",
      "url": "https://github.com/mnot/I-D/pull/30",
      "state": "CLOSED",
      "author": "elear",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See commit list.\n",
      "createdAt": "2013-09-30T06:54:08Z",
      "updatedAt": "2013-10-01T12:54:37Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "1c58c4aa775abb2b22a7d0c75f717aa90cb558a7",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "5c888659ba138c45572b10b4d9b3ac32d150d232",
      "closedAt": "2013-10-01T12:06:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "LGTM, but I can't merge with github; rebase?\n",
          "createdAt": "2013-10-01T00:06:28Z",
          "updatedAt": "2013-10-01T00:06:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0ODc0MjA2NQ==",
      "title": "Same changes from earlier from the gitless wonder",
      "url": "https://github.com/mnot/I-D/pull/31",
      "state": "MERGED",
      "author": "elear",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Details:\n\nRequest Routing -> Application Layer Gateway\nRemove discussion of \"Rights\"\nAdd discussion about issues relating to DHCP options.\nAdd discussion about who owns the proxy.pac file.\nAdd discussion about MPTCP.\nRemove what might now end well for proxies (who knows?)\nRestate what users require\nAdd environment diversity discussion\nAdd Scale\nAdd Improving Interception\n",
      "createdAt": "2013-10-01T15:07:08Z",
      "updatedAt": "2013-10-03T07:34:47Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "e654bd3bae6c4c80932c8301613b1a50177f2cbd",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "ca371164036d448c6d50f9407b43e83c39dba450",
      "closedAt": "2013-10-03T07:34:47Z",
      "mergedAt": "2013-10-03T07:34:47Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c57566db51d1758cfaeb055aa104397b8042b1c8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAyNjk2MTU=",
      "title": "adding XSD and minor changes",
      "url": "https://github.com/mnot/I-D/pull/38",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2013-11-25T18:09:09Z",
      "updatedAt": "2013-11-26T00:38:44Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "ab3376ee66560045764f41aee66c26730d09242c",
      "headRepository": "dret/I-D-1",
      "headRefName": "05-xml-changes",
      "headRefOid": "73f01a0ca129e9f381dfaccb50fd2e6ffb7b0104",
      "closedAt": "2013-11-25T23:08:44Z",
      "mergedAt": "2013-11-25T23:08:44Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e8566d115d0627bb8b667c8eadb6ae34aea86e3d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE0MjU5MTU=",
      "title": "changing address",
      "url": "https://github.com/mnot/I-D/pull/43",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "creating -06 with the only change being a new author address for me, and the publication year.\n",
      "createdAt": "2014-01-11T08:42:22Z",
      "updatedAt": "2014-01-31T08:23:06Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "b1ef6d507488d0b866abc1d5af55680ece7f71cb",
      "headRepository": "dret/I-D-1",
      "headRefName": "addresschange",
      "headRefOid": "15e328f82d3c837d2c46fe62abb32ca181b065b2",
      "closedAt": "2014-01-30T04:22:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Incorporated manually.\n",
          "createdAt": "2014-01-30T04:22:00Z",
          "updatedAt": "2014-01-30T04:22:00Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks. it seems like source you're using (draft.md, i suppose) is not actually in the repo, so any change i make is something you cannot simply merge. is that correct?\n",
          "createdAt": "2014-01-31T08:23:06Z",
          "updatedAt": "2014-01-31T08:23:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIwNzA3NDc=",
      "title": "some rather minor changes",
      "url": "https://github.com/mnot/I-D/pull/44",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-01-31T08:55:06Z",
      "updatedAt": "2014-07-09T17:10:20Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "44c6b37fb11e630ab2c5d4c5c623bdb959d1cb4d",
      "headRepository": "dret/I-D-1",
      "headRefName": "minorcomments",
      "headRefOid": "c675e9618239636c0e5e8737309c48b6f6f11d18",
      "closedAt": "2014-02-01T04:42:22Z",
      "mergedAt": "2014-02-01T04:42:22Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "3bfe59b28d21159800b6b56618cee01fe409197a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5NDQ2NzU=",
      "title": "HTTP-TLS",
      "url": "https://github.com/mnot/I-D/pull/56",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This basically just merges my HTTP-TLS draft in.  The changes are fairly extensive.  I'd read the output rather than the diff.\n",
      "createdAt": "2014-05-15T16:43:34Z",
      "updatedAt": "2014-06-22T00:57:39Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "d63d030ba8576ca17134439f37928b31663db764",
      "headRepository": "martinthomson/I-D",
      "headRefName": "http-tls",
      "headRefOid": "1747f79cf51911070e22cbc7340522e2f4b70634",
      "closedAt": "2014-05-19T04:32:04Z",
      "mergedAt": "2014-05-19T04:32:04Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e8cbb0fc6af6cb1d3e8896b203ec858789bbc2ae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYyMjcwMjg=",
      "title": "Removing suggested maximum, in line with HSTS",
      "url": "https://github.com/mnot/I-D/pull/57",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Will asked why the suggestion for a month.  HPKP uses 60 days and this seems like an inherently safer mechanism than that.  ekr suggests the order from most to least dangerous is: HPKP, HSTS, this; at least in terms of the risk of screwing something up.\n\nSo this removes the suggested maximum.\n",
      "createdAt": "2014-05-22T15:42:22Z",
      "updatedAt": "2014-06-22T14:59:03Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "0d5dc49d8c08dc8b1c528cda9256a800f0ab7822",
      "headRepository": "martinthomson/I-D",
      "headRefName": "nospecificlimit",
      "headRefOid": "f695ca9ef0287eb2c2dd41a391f38aad7d4568a7",
      "closedAt": "2014-05-23T03:13:11Z",
      "mergedAt": "2014-05-23T03:13:11Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "163c0cdaf83cc78d9f3db91387428b2a3cd06f4f"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Makes sense, although I think the risk here is about equal to that of HSTS, not lower...\n",
          "createdAt": "2014-05-23T03:13:07Z",
          "updatedAt": "2014-05-23T03:13:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyOTk2MDI=",
      "title": "update references",
      "url": "https://github.com/mnot/I-D/pull/58",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-06-18T15:18:27Z",
      "updatedAt": "2014-06-19T06:56:44Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "1dc579d693fc8c6baade87e87db473314f080a44",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "8cd8874089c39ebf4042b5cc26398009d532f169",
      "closedAt": "2014-06-19T06:56:44Z",
      "mergedAt": "2014-06-19T06:56:44Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks.\n",
          "createdAt": "2014-06-19T06:56:42Z",
          "updatedAt": "2014-06-19T06:56:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MDM3NDA=",
      "title": "typos, references, RFC2119 terms",
      "url": "https://github.com/mnot/I-D/pull/59",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-06-20T12:55:28Z",
      "updatedAt": "2014-06-23T04:52:10Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "c176fb9ccfdfad60d6ede27c140525422030cf35",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "ac7aaddd9ed9853605eab9cbab49895caa4b07e1",
      "closedAt": "2014-06-23T04:52:10Z",
      "mergedAt": "2014-06-23T04:52:10Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c39ce9bca57c72835ec4bf377afe749b44a65d98"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg4ODQ3NTY=",
      "title": "adding files for -07",
      "url": "https://github.com/mnot/I-D/pull/60",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "in case you want to re-publish the current draft, i have created all necessary -07 files. the -07 draft XML itself is a copy of -06, only the reference to the -06 include has been changed.\n",
      "createdAt": "2014-07-25T09:00:06Z",
      "updatedAt": "2014-07-28T11:06:40Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "aae21290cc127300775a6894a1dcaec95930abfc",
      "headRepository": "dret/I-D-1",
      "headRefName": "draft-07",
      "headRefOid": "6e72ecd19685d9a8800d298c42ce21ae58f23b96",
      "closedAt": "2014-07-28T02:09:45Z",
      "mergedAt": "2014-07-28T02:09:45Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "34bdf01db0844ac59b48beba5a47b302f0e086bd"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!\n",
          "createdAt": "2014-07-28T02:11:03Z",
          "updatedAt": "2014-07-28T02:11:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM3NDM4Nzg=",
      "title": "getting ready for -08",
      "url": "https://github.com/mnot/I-D/pull/73",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-11-03T05:47:08Z",
      "updatedAt": "2015-08-07T08:29:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "d933f62611c644d1501d6fb9e202d64c6917c298",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/08",
      "headRefOid": "1ac621709fdd7d53a5f2b2d1e1938d76bb961625",
      "closedAt": "2015-08-07T08:29:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MTYwMjc=",
      "title": "Update HTML reference",
      "url": "https://github.com/mnot/I-D/pull/75",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-11-05T16:03:32Z",
      "updatedAt": "2014-11-05T22:47:25Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "d933f62611c644d1501d6fb9e202d64c6917c298",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "7008a548ef5b2e7a57713af36a2591085fc521e4",
      "closedAt": "2014-11-05T22:47:25Z",
      "mergedAt": "2014-11-05T22:47:25Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3MDI4NDU=",
      "title": "switching HTML references from HTML4 to HTML5",
      "url": "https://github.com/mnot/I-D/pull/78",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-12-08T22:26:09Z",
      "updatedAt": "2015-08-07T08:29:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "b905c14a8723d4e86b626e03164cc692d4a1b245",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/HTML5",
      "headRefOid": "973f5ab98b9dddf28c763df446c13edb770146e3",
      "closedAt": "2015-08-07T08:29:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3MTA5MzE=",
      "title": "adding XML-related changes based on julian's review",
      "url": "https://github.com/mnot/I-D/pull/79",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-12-09T00:46:11Z",
      "updatedAt": "2015-08-07T08:29:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "b905c14a8723d4e86b626e03164cc692d4a1b245",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/julianfeedback",
      "headRefOid": "b3e5a9d4e885091ffbf9032d5ff979c95405a05a",
      "closedAt": "2015-08-07T08:29:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg3ODY1Mjg=",
      "title": "C e e",
      "url": "https://github.com/mnot/I-D/pull/80",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding some more meat.\n",
      "createdAt": "2015-02-06T05:42:06Z",
      "updatedAt": "2015-02-07T00:24:04Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "fbb2ab0b495ccb9a0a30a8e8c77edf6fd678a29d",
      "headRepository": "martinthomson/I-D",
      "headRefName": "c-e-e",
      "headRefOid": "6a0fccbcf03f50405c19fcac5ebff1cdc42129dd",
      "closedAt": "2015-02-07T00:24:04Z",
      "mergedAt": "2015-02-07T00:24:04Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4NTQxNTU=",
      "title": "Adding SHA-256 ref since I had one lying around",
      "url": "https://github.com/mnot/I-D/pull/81",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-07T00:37:18Z",
      "updatedAt": "2015-02-09T01:04:14Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "0b7963ae2ffbff37c809d6978079739627622e64",
      "headRepository": "martinthomson/I-D",
      "headRefName": "sha256ref",
      "headRefOid": "a66c40d9aaaa4a2789cba6336290004891442ae9",
      "closedAt": "2015-02-09T01:04:14Z",
      "mergedAt": "2015-02-09T01:04:14Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c65e7a9d6cd3f08cabfb3caa317590f2be1971a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4OTA3NDc=",
      "title": "Remove IV from the C-E",
      "url": "https://github.com/mnot/I-D/pull/82",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "And use a counter directly.\n",
      "createdAt": "2015-02-09T00:57:28Z",
      "updatedAt": "2015-02-09T01:04:26Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "0b7963ae2ffbff37c809d6978079739627622e64",
      "headRepository": "martinthomson/I-D",
      "headRefName": "removeiv",
      "headRefOid": "fe83e3ba6d6dbefd325bbb38d2a5a33d4e00041b",
      "closedAt": "2015-02-09T01:04:26Z",
      "mergedAt": "2015-02-09T01:04:26Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4OTU1ODI=",
      "title": "Cleanup in preparation for submission",
      "url": "https://github.com/mnot/I-D/pull/83",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This has a lot of changes.\n\nI've removed the requirement for P-256, since this should be implied by the key identifier.\n\nI've added examples of actual enciphered messages.\n\nI've added more to the security considerations.\n\nBetter references and lots of tweaks.\n",
      "createdAt": "2015-02-09T04:15:02Z",
      "updatedAt": "2015-02-09T04:25:05Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "4dceb75021fc24ef18f95a69d234e8366e19341e",
      "headRepository": "martinthomson/I-D",
      "headRefName": "nocurve",
      "headRefOid": "36799a1efd2f7b81f5072d3ce47b1af3e96497a3",
      "closedAt": "2015-02-09T04:25:05Z",
      "mergedAt": "2015-02-09T04:25:05Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "dcc2bb6bcc1f4046557c1692ede92a164cbd45d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4OTU5NzA=",
      "title": "Fixing AES ref",
      "url": "https://github.com/mnot/I-D/pull/84",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-09T04:31:00Z",
      "updatedAt": "2015-02-09T04:32:58Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "055fb05327958d181f6b1979875f874106e603b2",
      "headRepository": "martinthomson/I-D",
      "headRefName": "nocurve",
      "headRefOid": "c09dddc5099831504ead35a061f2f1eb45c435ae",
      "closedAt": "2015-02-09T04:31:24Z",
      "mergedAt": "2015-02-09T04:31:24Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MDEzNzU=",
      "title": "Minor editorial changes.",
      "url": "https://github.com/mnot/I-D/pull/85",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See also my e-mail containing some more detailed comments.\n\nI've attempted to clarify the blocksize, with the understanding that each record consists of:\n- bs bytes of ciphertext\n- 16 bytes of auth tag.\n\nSo that, say, a 2000-byte plaintext with bs=1000, turns into 2032 bytes of data on the wire.\nIf that's wrong, more clarification will be needed.\n",
      "createdAt": "2015-02-09T07:39:10Z",
      "updatedAt": "2015-02-09T23:52:54Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "d61be0c7d79f88333b0dcf101f87c8013558a6e2",
      "headRepository": "ekr/mnot-I-D",
      "headRefName": "EKR_editorial",
      "headRefOid": "f50ca8cc3ca6bc43380aebd44030ad5f5459160d",
      "closedAt": "2015-02-09T23:52:54Z",
      "mergedAt": "2015-02-09T23:52:54Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "4c3edeb37db054ebeec76991f09103eb95e2663f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5NzA3NDI=",
      "title": "Noting the uniqueness requirement for nonces",
      "url": "https://github.com/mnot/I-D/pull/86",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-10T00:33:01Z",
      "updatedAt": "2015-02-10T02:32:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "1f250f7bf3793ec6623488c164aef92c4f0f00b9",
      "headRepository": "martinthomson/I-D",
      "headRefName": "nonce_unique",
      "headRefOid": "3492712ad8eb82628baf9e5c7a52d1455d0e2f1c",
      "closedAt": "2015-02-10T01:31:37Z",
      "mergedAt": "2015-02-10T01:31:37Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Points noted.  I've also added a security considerations.\n",
          "createdAt": "2015-02-10T01:02:01Z",
          "updatedAt": "2015-02-10T01:02:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5NzYzNDA=",
      "title": "Explaining why other formats aren't suitable",
      "url": "https://github.com/mnot/I-D/pull/87",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-10T02:33:14Z",
      "updatedAt": "2015-02-11T05:15:17Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "f24b351f541234265a7fe023292c91f8d77d6daa",
      "headRepository": "martinthomson/I-D",
      "headRefName": "whynot",
      "headRefOid": "f6f12c77f6c1a3e567dd7f988ab4bc6c7421c10e",
      "closedAt": "2015-02-10T03:10:01Z",
      "mergedAt": "2015-02-10T03:10:01Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, forgot to add refs, don't merge yet.\n",
          "createdAt": "2015-02-10T02:33:44Z",
          "updatedAt": "2015-02-10T02:33:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK.\n",
          "createdAt": "2015-02-10T02:40:17Z",
          "updatedAt": "2015-02-10T02:40:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@msporny, I don't know what alignment means here, unless you mean that you would like to remove \"algorithm\".\n",
          "createdAt": "2015-02-11T00:28:19Z",
          "updatedAt": "2015-02-11T00:28:19Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "@martinthomson I mean more do we use \"keyid\" or \"keyId\" (note the capitalized I in the latter form). Your comment did make me go back and look at the Content-Encoding: aesgcm-128 part and made me wonder if we wouldn't want to go the other way. Add \"algorithm\" to the http-encryption-encoding spec, so you'd have something like this, instead:\n\n```\nContent-Encoding: encrypted, gzip\nEncryption: keyid=\"http://example.org/bob/keys/123\";\n            algorithm=\"aesgcm-128\";\n            nonce=\"XZwpw6o37R-6qoZjw6KwAw\"\n```\n\nI realize that doing that might be a bit of an abuse of the Content-Encoding field, but having something that's a bit more flexible would probably be a good thing.\n",
          "createdAt": "2015-02-11T02:18:51Z",
          "updatedAt": "2015-02-11T02:19:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@msporny, that sort of flexibility is a strict non-goal for us here.\n",
          "createdAt": "2015-02-11T02:25:31Z",
          "updatedAt": "2015-02-11T02:25:31Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "@martinthomson Why? Is this explained somewhere?\n",
          "createdAt": "2015-02-11T02:40:18Z",
          "updatedAt": "2015-02-11T02:40:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll explain here.  Mark and I have both had a lot of experience with developing or maintaining protocol frameworks with multiple extension points.  Those are significantly harder to get right than you initially think, every time.  The biggest costs usually only surface several years after the spec is complete, usually in the form of interop failure as a result of divergent interpretations of some spec ambiguity.\n\nUnless you have a strong need for it, don't provide extensibility.  Use existing, well-tested extension points.  A high-level discriminator - such as our \"aesgcm-128\" C-E tag - uses the existing Content-Encoding extension scheme.  A replacement can use the same point easily.  It's also a pattern that has worked very well elsewhere.  Other than your basic extension point, design the minimum possible thing that could possibly work.\n\nThis is exactly the same design philosophy that has been applied in HTTP/2, though for that we had to design a new extension point to get what we wanted.  And ALPN was NOT easy to do, nor are we yet entirely certain it is correct or error free.\n\nSo, when we want to do an AEAD based on ChaCha20 and Poly1305, we will define a new content encoding, and maybe the pieces that work from this one, if there are any.\n",
          "createdAt": "2015-02-11T04:55:59Z",
          "updatedAt": "2015-02-11T04:55:59Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "@martinthomson thanks for taking the time to explain. What you're saying makes sense in that we've kinda-sorta taken that approach wrt. the digital signature \"algorithm agility\" stuff in the Linked Data Signatures work (https://web-payments.org/specs/source/ld-signatures/#message-signature-algorithm). That is, we try to just bundle all the crypto settings into a single identifier (GraphSignature2012) vs. enabling a ton of variability in the crypto settings.\n\nMy only concern is the speed at which crypto is broken and moves on... you may find that this spec only survives for 5 years and needs to be replaced, and the replacement spec effectively is a copy-paste of what you have now w/ a minimally different aead-chacha20-poly1305 C-E scheme.\n\nI'll think about what you say above and try and apply the thinking to the Signing HTTP Messages spec wrt. removing 'algorithm'. Thanks again for the explanation. :)\n",
          "createdAt": "2015-02-11T05:11:22Z",
          "updatedAt": "2015-02-11T05:15:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwNzAxNzU=",
      "title": "5116",
      "url": "https://github.com/mnot/I-D/pull/88",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Editorial update to reference RFC 5116, which defines AES-GCM far more cleanly and explicitly than anything we could do.\n",
      "createdAt": "2015-02-11T06:11:26Z",
      "updatedAt": "2015-02-11T11:47:08Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "49d025a82c47c1605358b0bd853dc0250ba78628",
      "headRepository": "martinthomson/I-D",
      "headRefName": "5116",
      "headRefOid": "294e67bd4b7e715111e7e8d1223b9144b84031c6",
      "closedAt": "2015-02-11T11:47:08Z",
      "mergedAt": "2015-02-11T11:47:08Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c4e42deaa08e4bd4ed18a11b6858982e1b49b16a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwNzA2ODU=",
      "title": "Updating integrity section",
      "url": "https://github.com/mnot/I-D/pull/89",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Builds on #88, since there was a collision there.  House of cards, yeah.\n",
      "createdAt": "2015-02-11T06:30:45Z",
      "updatedAt": "2015-02-11T11:47:33Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "49d025a82c47c1605358b0bd853dc0250ba78628",
      "headRepository": "martinthomson/I-D",
      "headRefName": "integrity",
      "headRefOid": "60ca0b3a10a4a16f5c4bf75e47a5e5f5a877cf2c",
      "closedAt": "2015-02-11T11:47:33Z",
      "mergedAt": "2015-02-11T11:47:33Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMzExMzA=",
      "title": "Explaining the extension properties of this design",
      "url": "https://github.com/mnot/I-D/pull/94",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "...and why it is that way.\n",
      "createdAt": "2015-02-13T00:42:35Z",
      "updatedAt": "2015-02-13T01:19:13Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "c723463eb770faf601cc5665397e3137b505b2fe",
      "headRepository": "martinthomson/I-D",
      "headRefName": "extension",
      "headRefOid": "7fcfe25855579988c43010f0b7dd90054dee5cd1",
      "closedAt": "2015-02-13T01:19:13Z",
      "mergedAt": "2015-02-13T01:19:13Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "d2fec50a393b0b4bba38dfa0604f7f83839b0558"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMzExMzk=",
      "title": "Expanding the explanation of ECDH parameters.  Closes #93.",
      "url": "https://github.com/mnot/I-D/pull/95",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-13T00:42:44Z",
      "updatedAt": "2015-02-13T01:19:45Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "c723463eb770faf601cc5665397e3137b505b2fe",
      "headRepository": "martinthomson/I-D",
      "headRefName": "outofband",
      "headRefOid": "1feb84a7834ce21093e43681b1a4991dba511eaa",
      "closedAt": "2015-02-13T01:19:45Z",
      "mergedAt": "2015-02-13T01:19:45Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMzEyMzE=",
      "title": "Adding acknowledgements",
      "url": "https://github.com/mnot/I-D/pull/96",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-13T00:44:38Z",
      "updatedAt": "2015-02-13T01:20:14Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "c723463eb770faf601cc5665397e3137b505b2fe",
      "headRepository": "martinthomson/I-D",
      "headRefName": "ack",
      "headRefOid": "6302d7c5084dc82f24773e62ab19d3981d8b19b2",
      "closedAt": "2015-02-13T01:20:14Z",
      "mergedAt": "2015-02-13T01:20:14Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA0MTYzODU=",
      "title": "A fairly extensive cleanup",
      "url": "https://github.com/mnot/I-D/pull/97",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "High points:\n- Split out key determination parameters (Encryption-Key) from those that describe the encryption (Encryption) as suggested in #92.  Closes #92.\n- Moved to using HKDF (RFC 5869) for key expansion/entropy mixing.  This follows the advice we've received for TLS 1.3 and it simplifies the dependencies somewhat.  No more cherry-picking from the complicated TLS spec, HKDF is very easy to read.\n- Changed some of the parameter names:\n  *\\* \"nonce\" becomes \"salt\" matching the names used in HKDF.  This is less confusing with the RFC5116 usage.\n  *\\* \"ecdh\" becomes the more generic \"dh\", since the actual DH algorithm is entirely determined outside of this protocol.\n- Removed AAD.  This doesn't close #90, because I want to check with a cryptographer first.\n- Added some more sanity checks on inputs.  \"rs\" needs to be >=2.  \"key\" now MUST be 64 octets, like \"salt\".\n",
      "createdAt": "2015-03-03T21:52:33Z",
      "updatedAt": "2015-03-06T00:07:57Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "a8e0a1bd799c52da02e091b5c7224d83e2a6a1f9",
      "headRepository": "martinthomson/I-D",
      "headRefName": "split",
      "headRefOid": "5e6dbc4147a8a8f38d722248d12d1fa450d45fa7",
      "closedAt": "2015-03-04T23:30:35Z",
      "mergedAt": "2015-03-04T23:30:35Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "You have a chance to update your implementation yet?\n",
          "createdAt": "2015-03-04T23:30:33Z",
          "updatedAt": "2015-03-04T23:30:33Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NjA3NjA=",
      "title": "typos, links, terminology",
      "url": "https://github.com/mnot/I-D/pull/98",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-03-05T14:29:14Z",
      "updatedAt": "2015-03-06T03:18:28Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "05e052d83ec361aacbb87bb7ebf4553e68ebfb74",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "28caf1631cc908d581b01b6824eafdfebbcf7af3",
      "closedAt": "2015-03-06T03:18:28Z",
      "mergedAt": "2015-03-06T03:18:28Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "aba5d12194c0d0489617947ea60f0f59b52fe529"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2MTEyMjc=",
      "title": "Fixing date on X.692 reference",
      "url": "https://github.com/mnot/I-D/pull/99",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-03-06T00:40:03Z",
      "updatedAt": "2015-03-06T03:18:57Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "05e052d83ec361aacbb87bb7ebf4553e68ebfb74",
      "headRepository": "martinthomson/I-D",
      "headRefName": "fixref",
      "headRefOid": "fdaec423c03afa1625535e30a0aff5350c24c309",
      "closedAt": "2015-03-06T03:18:57Z",
      "mergedAt": "2015-03-06T03:18:57Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2NTk1MjQ=",
      "title": "mention not sending Content-Type as another option",
      "url": "https://github.com/mnot/I-D/pull/100",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-03-06T16:43:18Z",
      "updatedAt": "2015-03-07T01:05:35Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "e628da33fc2395b85e74455e09907f389d643746",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "36e9281d320ef0e91c8930c313e47059550fd363",
      "closedAt": "2015-03-07T01:05:35Z",
      "mergedAt": "2015-03-07T01:05:35Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 102,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE2OTI5OTU=",
      "title": "Updating examples",
      "url": "https://github.com/mnot/I-D/pull/102",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update the examples.\n\nCloses #101.\n",
      "createdAt": "2015-03-22T19:14:57Z",
      "updatedAt": "2015-03-22T19:53:14Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "1368afe9942e0719c766c6a9a5c4b61eaf4fdf89",
      "headRepository": "martinthomson/I-D",
      "headRefName": "ex",
      "headRefOid": "c5157524a8779ba6232568f4c2840b5ab059961e",
      "closedAt": "2015-03-22T19:47:52Z",
      "mergedAt": "2015-03-22T19:47:52Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNTIzMjI=",
      "title": "Dealing with a truncation attack",
      "url": "https://github.com/mnot/I-D/pull/109",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@ekr pointed this nasty one out before.  An attacker can easily truncate a series of records at the record boundary and the receiver will accept them.  That's bad.\n\nSince HTTP helps us determine the length, the cheapest approach is to require a non-full-sized record at the end of the full sequence.\n\n@ekr finds this solution a little disgusting, but it is more byte-efficient than most of the alternatives he could suggest.  The only option that doesn't spend extra bits is where you change the AAD for the last block.  That has the cost of forcing either a trial decryption or a read-ahead for indefinite length encodings, which is worse in my opinion (it also weakens the authentication tag by a bit, but I won't lose sleep over that).  Other options all steal from the padding byte, reducing the amount of padding we can describe, unless we increase the number of bytes spent on padding.\n\nCloses #108.\n",
      "createdAt": "2015-03-30T18:15:12Z",
      "updatedAt": "2015-03-30T23:00:25Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "73ebeaa46a1da560d661d05b17c9ffb9e62c2c6a",
      "headRepository": "martinthomson/I-D",
      "headRefName": "lengthbug",
      "headRefOid": "b59675925d58ad107392361433bca0ffc1fd6880",
      "closedAt": "2015-03-30T23:00:25Z",
      "mergedAt": "2015-03-30T23:00:25Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNTI0NzQ=",
      "title": "Adding JWE-based explanation",
      "url": "https://github.com/mnot/I-D/pull/110",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Explain the encoding in terms of JWE.  This should be helpful in reducing the cost of analysis.\n",
      "createdAt": "2015-03-30T18:16:57Z",
      "updatedAt": "2015-03-30T23:01:36Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "73ebeaa46a1da560d661d05b17c9ffb9e62c2c6a",
      "headRepository": "martinthomson/I-D",
      "headRefName": "jwe",
      "headRefOid": "d68e340a3e31cf49ac2a2c878977b3dd960b8dd6",
      "closedAt": "2015-03-30T23:01:36Z",
      "mergedAt": "2015-03-30T23:01:36Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjE0MzY=",
      "title": "Moving to std track",
      "url": "https://github.com/mnot/I-D/pull/111",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "WDYT?\n",
      "createdAt": "2015-04-14T02:25:18Z",
      "updatedAt": "2015-04-14T03:24:51Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "cda48d4824a71a0e17948c2bfaa9a721f44e3b26",
      "headRepository": "martinthomson/I-D",
      "headRefName": "enc-std",
      "headRefOid": "8f890675e6999223a94e48f9cd1592cfc2391a4f",
      "closedAt": "2015-04-14T02:47:30Z",
      "mergedAt": "2015-04-14T02:47:30Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Yeah, might as well, since the registry requires IETF Review.\n",
          "createdAt": "2015-04-14T02:47:27Z",
          "updatedAt": "2015-04-14T02:47:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwODYzNjg=",
      "title": "Some small changes from josephlhall",
      "url": "https://github.com/mnot/I-D/pull/113",
      "state": "MERGED",
      "author": "josephlhall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per email wayback on 25 March, here are some changes if you fancy them. I can take on more substantial authoring in the future, where needed.\n",
      "createdAt": "2015-04-24T21:08:29Z",
      "updatedAt": "2015-04-27T00:42:34Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "7c9e7eed9d5569f56048a2400d0c839e3a02a263",
      "headRepository": "josephlhall/I-D",
      "headRefName": "master",
      "headRefOid": "753d17eb3619d262a523b1277ddcaa51f08acfde",
      "closedAt": "2015-04-27T00:42:34Z",
      "mergedAt": "2015-04-27T00:42:34Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyOTIyNjI=",
      "title": "removed duplicate either",
      "url": "https://github.com/mnot/I-D/pull/120",
      "state": "MERGED",
      "author": "moonshiner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-06-23T00:59:28Z",
      "updatedAt": "2015-06-23T01:00:39Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "6282e829fa707ec9ba610e828a90f67a5720d338",
      "headRepository": null,
      "headRefName": "fix-either",
      "headRefOid": "a305a6c897d9933308e92b6cd3742b010d416892",
      "closedAt": "2015-06-23T01:00:39Z",
      "mergedAt": "2015-06-23T01:00:39Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks. Note that the canonical source is draft.md (but I'll fix that).\n",
          "createdAt": "2015-06-23T01:00:29Z",
          "updatedAt": "2015-06-23T01:00:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA1ODQ0MDI=",
      "title": "Softening some language",
      "url": "https://github.com/mnot/I-D/pull/126",
      "state": "CLOSED",
      "author": "hildjj",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a first pass; if you're ok with the direction, i'd want to do a more thorough nit review before publishing.\n",
      "createdAt": "2015-07-22T16:29:50Z",
      "updatedAt": "2015-08-07T08:29:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "4c8d4efd9ab940025cecf4b468b0a3e2f0b531a7",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "fd50e2a514ccddfb818d3e6fd714fb52d7c2dcbf",
      "closedAt": "2015-08-07T08:29:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I think I'm OK; go ahead and de-nit. Other authors will hopefully chime in.\n",
          "createdAt": "2015-07-22T19:42:59Z",
          "updatedAt": "2015-07-22T19:42:59Z"
        },
        {
          "author": "wseltzer",
          "authorAssociation": "NONE",
          "body": "OK with me too.\n",
          "createdAt": "2015-07-22T20:03:28Z",
          "updatedAt": "2015-07-22T20:03:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA4MzY2ODM=",
      "title": "Some suggested changes, especially in first half.",
      "url": "https://github.com/mnot/I-D/pull/127",
      "state": "CLOSED",
      "author": "nllz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The choice of constituent in line 116 - 118 seems a bit random, we could probably strengthen this.\n",
      "createdAt": "2015-07-25T13:08:14Z",
      "updatedAt": "2015-08-06T01:32:30Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "master",
      "baseRefOid": "f4876809d1859696bebc96651bc7d2d4ef2e0458",
      "headRepository": "nllz/I-D",
      "headRefName": "patch-1",
      "headRefOid": "0507559c1ca7133c7984d6f7d118b7792af26127",
      "closedAt": "2015-08-06T01:32:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Arg, sorry - missed the pull and made changes since. Could you re-base?\n\nThanks,\n",
          "createdAt": "2015-08-04T23:52:02Z",
          "updatedAt": "2015-08-04T23:52:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Incorporated by hand.\n",
          "createdAt": "2015-08-06T01:32:30Z",
          "updatedAt": "2015-08-06T01:32:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4Nzc0MTA=",
      "title": "Typo, effected -> affected",
      "url": "https://github.com/mnot/I-D/pull/128",
      "state": "MERGED",
      "author": "konklone",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-08-07T10:10:09Z",
      "updatedAt": "2015-08-08T02:06:11Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "f2963b743232a5ff0f414acd01f246c23ab157b1",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "3afd179ce40b990a2053e09d44461b26145da4bf",
      "closedAt": "2015-08-08T02:06:11Z",
      "mergedAt": "2015-08-08T02:06:11Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI5MzE2NjA=",
      "title": "s/circulate/circumvent/",
      "url": "https://github.com/mnot/I-D/pull/129",
      "state": "MERGED",
      "author": "squarooticus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-08-20T13:53:48Z",
      "updatedAt": "2015-08-21T00:48:54Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "0a5258d8be82a8aa183c2b328f9bf01475d3096b",
      "headRepository": "squarooticus/I-D",
      "headRefName": "patch-1",
      "headRefOid": "665331db020867c1e11e8d525189f62f0927c640",
      "closedAt": "2015-08-21T00:48:54Z",
      "mergedAt": "2015-08-21T00:48:54Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "/me wonders how that got through -- thanks!\n",
          "createdAt": "2015-08-21T00:48:50Z",
          "updatedAt": "2015-08-21T00:48:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgwMDA1OTY=",
      "title": "minor addition (mentioning the second \"extension example\")",
      "url": "https://github.com/mnot/I-D/pull/146",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "would be worthwhile to also add the \"validation error\" example to the XML section?\n",
      "createdAt": "2015-10-18T03:05:47Z",
      "updatedAt": "2016-03-02T08:11:29Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "3419a8ef01b266c59dadc8609e3759c6e89974a9",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-1",
      "headRefOid": "3c1c3025a2382f247f280b9ecbf3f701362c41c2",
      "closedAt": "2016-03-02T06:01:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Oops, this went out.\n",
          "createdAt": "2016-03-02T06:01:22Z",
          "updatedAt": "2016-03-02T06:01:22Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe add in AUTH48?\n",
          "createdAt": "2016-03-02T08:11:29Z",
          "updatedAt": "2016-03-02T08:11:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE3NzQ3MTM=",
      "title": "fix RFC3986 reference",
      "url": "https://github.com/mnot/I-D/pull/153",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-25T10:14:23Z",
      "updatedAt": "2015-11-25T22:58:32Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "77fd917764124845d7ebc9b935a0becd88292cd7",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "1d646e74926f0601ad759a7a0ceaae85e3beb3d8",
      "closedAt": "2015-11-25T22:58:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 154,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE3NzQ4NDM=",
      "title": "remove surplus bracket",
      "url": "https://github.com/mnot/I-D/pull/154",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-25T10:15:46Z",
      "updatedAt": "2015-11-25T22:58:32Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "77fd917764124845d7ebc9b935a0becd88292cd7",
      "headRepository": null,
      "headRefName": "patch-2",
      "headRefOid": "52b4c8c391c34e219843dd6abecf9612a1dff1e5",
      "closedAt": "2015-11-25T22:58:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 156,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwNjE5MDU=",
      "title": "Update rdfa reference",
      "url": "https://github.com/mnot/I-D/pull/156",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-29T13:35:54Z",
      "updatedAt": "2015-11-29T13:52:51Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "1b7196a49c4cf3fd7cc0787d8b012ea9e5f2ac73",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "443bdb4fab27fa5277121d140c13e041ddf6424f",
      "closedAt": "2015-11-29T13:52:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(request was incomplete)\n",
          "createdAt": "2015-11-29T13:52:51Z",
          "updatedAt": "2015-11-29T13:52:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwNjIzNjQ=",
      "title": "add type attributes to artwork, consistent indentation",
      "url": "https://github.com/mnot/I-D/pull/157",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-29T14:04:07Z",
      "updatedAt": "2015-11-30T00:13:45Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "1b7196a49c4cf3fd7cc0787d8b012ea9e5f2ac73",
      "headRepository": null,
      "headRefName": "gh-pages",
      "headRefOid": "3356ec7fe185f7784e46ef170e21607d62f0879a",
      "closedAt": "2015-11-30T00:13:45Z",
      "mergedAt": "2015-11-30T00:13:45Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwOTAxMTk=",
      "title": "[h2-cache-digest] Gcs fixes",
      "url": "https://github.com/mnot/I-D/pull/158",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR consists of three commits to h2-cache-digest.\n\nThe first commit (marked _bugfix_) is mandatory.  The other two commits (marked _improvement_) are not, but they simplify the logic as well as minimizes amount of data being transferred.\n",
      "createdAt": "2015-11-30T06:43:39Z",
      "updatedAt": "2015-12-01T00:12:33Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ff8fc43dcdf7eb16b397fca2228007b364ddae80",
      "headRepository": "kazuho/I-D",
      "headRefName": "gcs-fixes",
      "headRefOid": "018bac16fa38a79acd03553df9bef47b9d606075",
      "closedAt": "2015-12-01T00:12:33Z",
      "mergedAt": "2015-12-01T00:12:33Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwOTQ2MjI=",
      "title": "Update rdfa reference",
      "url": "https://github.com/mnot/I-D/pull/159",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-30T08:05:55Z",
      "updatedAt": "2015-11-30T10:08:13Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ff8fc43dcdf7eb16b397fca2228007b364ddae80",
      "headRepository": null,
      "headRefName": "patch-2",
      "headRefOid": "3655125ab22a344a46040338b54c444a41b3139b",
      "closedAt": "2015-11-30T10:08:13Z",
      "mergedAt": "2015-11-30T10:08:13Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 160,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxMjMzMDI=",
      "title": "Change media type registration template to a proper list.",
      "url": "https://github.com/mnot/I-D/pull/160",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-11-30T13:26:41Z",
      "updatedAt": "2015-11-30T20:03:37Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "b03529a1d11b408f94d77b6a698b66b1dc1447a2",
      "headRepository": null,
      "headRefName": "gh-pages",
      "headRefOid": "fe29768243e322e6c40bab9faccfccc986a065bd",
      "closedAt": "2015-11-30T20:03:37Z",
      "mergedAt": "2015-11-30T20:03:37Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyNDIwMTA=",
      "title": "addressing julian's email about missing registration fields",
      "url": "https://github.com/mnot/I-D/pull/162",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-12-01T10:46:27Z",
      "updatedAt": "2015-12-04T16:06:40Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "b5c4b956d71e84a8e72153215682adc953ccc25f",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-2",
      "headRefOid": "4e07beada0a4d950d27aa62ca96842541c869e8f",
      "closedAt": "2015-12-01T20:24:44Z",
      "mergedAt": "2015-12-01T20:24:44Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2NDMzNjU=",
      "title": "updating contact info",
      "url": "https://github.com/mnot/I-D/pull/164",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-12-04T08:50:47Z",
      "updatedAt": "2015-12-05T07:36:41Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "f098ea74909fa8a95041c9a063b819c8c9575387",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-3",
      "headRefOid": "7ed880e149b87fc09ee566dbbd97de4655bc9a62",
      "closedAt": "2015-12-05T00:14:49Z",
      "mergedAt": "2015-12-05T00:14:49Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2NzI0NTc=",
      "title": "addressing julian's XML-related remarks",
      "url": "https://github.com/mnot/I-D/pull/165",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-12-04T14:04:20Z",
      "updatedAt": "2015-12-05T07:36:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "f098ea74909fa8a95041c9a063b819c8c9575387",
      "headRepository": "dret/I-D-1",
      "headRefName": "dret/XML-issues",
      "headRefOid": "69c39606c4087c53710695124cdb9020a5438ac3",
      "closedAt": "2015-12-05T00:13:41Z",
      "mergedAt": "2015-12-05T00:13:41Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "f43fa629d1b34235a3354b95e60390d6b7adc3b8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYyOTY5MTY=",
      "title": "Refine the calculation of GCS",
      "url": "https://github.com/mnot/I-D/pull/166",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes small changes to how the GCS is calculated, specifically:\n- truncate the hash value (instead of calculating the modulo)\n- emit N and P in 5 bits, so that `hash-values` can always be represented using a 64-bit value type\n- split the emissions of N and P to separate steps to avoid confusion\n\nThe changes were suggested by Martin Thomson (https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0026.html), and Alex Rousskov (https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0025.html).\n",
      "createdAt": "2016-01-18T02:45:56Z",
      "updatedAt": "2016-01-31T04:53:34Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "fd975adcfa9c1f17fd81a65a0e7552b04ced7ecc",
      "headRepository": "kazuho/I-D",
      "headRefName": "h2-cache-digest/restrict-size-of-digest-value",
      "headRefOid": "c0480a5a3f123e44b464369f31617b6dd41b4579",
      "closedAt": "2016-01-31T04:53:34Z",
      "mergedAt": "2016-01-31T04:53:34Z",
      "mergedBy": "mnot",
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "LGTM. Sorry for the delay, been on holiday.\n",
          "createdAt": "2016-01-31T04:53:31Z",
          "updatedAt": "2016-01-31T04:53:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYyOTc5NTU=",
      "title": "use a HTTP header to convey the digest",
      "url": "https://github.com/mnot/I-D/pull/167",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "h2-cache-digest"
      ],
      "body": "This PR changes the conveyer of the cache digest from a HTTP/2 frame to a HTTP request header.\n\nThere are several merits in doing so.  By defining it as a header,\n- a cache-digest can be sent by ServiceWorker\n- a cache-digest can easily be transferred to application servers over HTTP/1\n- client connecting through an cache-digest-unaware proxy can benefit from push\n\nThe downside had been considered that including a cache-digest in every HTTP request might consume too much upstream bandwidth (when compared to using a HTTP/2 frame), but I have concluded that by sending multiple cache-digest headers we can earn effective compression by HPACK so that the overhead may be negligible.\n\nFor example, a client can send in the first HTTP request after establishing an HTTP/2 connection a cache-digest header containing the entire digest:\n\n```\ncache-digest: fresh=ABC...xyz    # entire cache digest\n```\n\nand in the following HTTP requests, send the same big header (which will be compressed to 1 to 2 bytes by HPACK) and a second header containing a small delta since the first request.\n\n```\ncache-digest: fresh=ABC...xyz    # entire cache digest\ncache-digest: fresh=0uec         # small delta\n```\n\nThe ABNF has been generalized to use set of name-value pairs in order to give room for future extensions.\n\nSome relevant mails regarding the topic:\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0076.html\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0081.html\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0095.html\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0096.html\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0120.html\n",
      "createdAt": "2016-01-18T03:10:46Z",
      "updatedAt": "2016-05-10T05:35:06Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "694f4c081679fd9e386ff388c2a2a6aac8d11330",
      "headRepository": "kazuho/I-D",
      "headRefName": "h2-cache-digest/header",
      "headRefOid": "ef07fb4ca4f7c6230fa2d7c353fcfbff7f1c21d6",
      "closedAt": "2016-05-10T05:33:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry please consider this PR as WIP; we need to:\n- move semantics out from ABNF (https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0130.html)\n- consider adding `path` (https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0127.html)\n- change `authority` to `domain` or `host` (https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0132.html)\n",
          "createdAt": "2016-01-19T00:49:48Z",
          "updatedAt": "2016-01-19T16:25:05Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": ":+1:  excited to see this!\n",
          "createdAt": "2016-01-19T15:49:02Z",
          "updatedAt": "2016-01-19T15:49:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "My .02 - \n\nI think it's fine to define a header for this; like you say, there are some good use cases for it.\n\nHowever, why are we removing the HTTP/2 frame? It has a number of benefits:\n- The UA can complete the first request as quickly as possible, without fate-sharing between the digest and it.\n- The UA can update/replace the server's digest state without a request being issued\n- The digest state is explicitly connection-specific and hop-by-hop\n- The digest doesn't take up limited HPACK dictionary space\n",
          "createdAt": "2016-01-31T05:06:46Z",
          "updatedAt": "2016-01-31T05:06:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your sensible response.\n\nLet's consider how we should define both the frame and the header so that they can be kept in sync.\n\nMy idea was that we could just use the HTTP header for simplicity, but I agree that it might be helpful to keep the frame definition as well.  Specifically, I hadn't considered the possibility of the digest header taking up HPACK dictionary space; considering the fact that the default size is 4K, I agree that we should better provide a way that does not use a header.\n\nI think the best way to proceed is to first agree on the basic design regarding syntax and semantics.  After that I can update this PR (if you want me to), and move on to discussing the details.\n\n## Syntax\n\nI see three options here:\n- a) use the frame definition as the base, and define the header as the base64-encoded form of the frame\n- b) use the header definition as the base and define the frame as the non-base64-encoded form of the digest-value plus the parameters conveyed as a string\n- c) same as b, but encode the parameters using a binary notation\n\nI do not have a strong opinion here, but my weak preference is b, which would state:\n\n```\n+----------------------+\n| Parameters-Len? (16) |\n+------------------+---+\n| Digest-Value (*) |\n+----------------+-+\n| Parameters (*) |\n+----------------+\n\nDigest-Value is the non-base64-encoded digest, and the length is: length-of-frame - Parameters-Len\nParameters contain the parameters (in string) defined for the `cache-digest` header\n```\n\n## Semantics\n\nDo you agree that we should add `host`, `path` and `type` parameters to the cache digest?\n\nIf yes, we would need to state that a frame replaces the previous one with same values assigned for the three parameters.\n",
          "createdAt": "2016-02-01T22:19:46Z",
          "updatedAt": "2016-02-01T22:19:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "(b) seems reasonable to me.\n\nRegarding the parameters - \n- `host` seems pretty reasonable, although we should probably specify it in terms of origins, for clarity.\n- `path` seems a bit odd. What does it imply to the server? It seems to me that really it's an identifier for the digest so that it can be replaced in the future. i.e., a server can consult any digest that's valid for the origin (taking account of `host` restrictions), and can have multiple applicable digests for a given origin, but this `identifier` (not the name I'd suggest :) tells it when to replace and when to consider it a different digest. That way, you can even change the scope of `host` on a digest if you want to, over time.\n- `type` seems reasonable, except as soon as we have more than one value, we'll need some way for the server to request a particular type from the client. Not sure what to do here, except default `type` to what we define, and really try to get it right the first time; the big win for cache digests is sending them right after the first request on a connection, so if there are too many formats (i.e., it fills more than 1RT), the advantage is lost.\n",
          "createdAt": "2016-02-05T04:56:07Z",
          "updatedAt": "2016-02-05T04:56:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the response.\n\n> - `path` seems a bit odd. What does it imply to the server?\n\nIt implies that the server should use the cache-digest only for determining the cache state of resources that belong to the specified path.\n\nThe addition was suggested by @martinthomson, and my understanding is that the primary use-case of the attribute is SW-based implementations.\n\nFor a SW-based cache implementation, it would be natural to implement a cache that only retains files under certain path (e.g. `/scripts` or `/css`), considering the fact that the size of SW cache may be pretty small.  In such case, the client needs to notify the server that the cache-digest being sent only covers those paths, that the server should not use the cache-digest to determine if a response that does not fall under the cached path is already cached.\n\n> - `type` seems reasonable, except as soon as we have more than one value, we'll need some way for the server to request a particular type from the client.\n\nAgreed.  The only reason for defining the `type` attribute is for keeping the specification open for future extensions.\n",
          "createdAt": "2016-02-09T07:56:14Z",
          "updatedAt": "2016-02-09T07:56:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "WRT `path` - imagine a server has set digests with `path=/foo` and `path=/foo/bar`. Does this mean that the server should only consult the latter digest for `/foo/bar/baz`, or should it consult both?\n\nWhat I was suggesting was something like `id=abc`, purely as a mechanism for there to be multiple active digests for a given origin, and to allow individual digests to be updated. \n\nThat way, we're not tying the life cycle of a digest to a specific path on the server. \n\n@martinthomson WDYT?\n",
          "createdAt": "2016-02-10T03:22:09Z",
          "updatedAt": "2016-02-10T03:22:09Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \n\n> WRT `path` - imagine a server has set digests with `path=/foo` and `path=/foo/bar`. Does this mean that the server should only consult the latter digest for `/foo/bar/baz`, or should it consult both?\n\nIt should consult both (I agree that for `path` it seems a bit odd, but we would anyways have the same issue for `host`).\n\nIMO specifying that a server should consult all the active cache-digests that match the scope (i.e. host and path attributes) is a natural thing to do, considering the fact that for HPACK efficiency of header-conveyed digests we need to allow splitting a digest covering single scope into multiple cache-digest entries for HPACK efficiency (discussed in [these lines](https://gist.github.com/kazuho/238de4ab8a964c9c927c#file-index-txt-L161-L184) of the PR).\n\n> What I was suggesting was something like id=abc, purely as a mechanism for there to be multiple active digests for a given origin, and to allow individual digests to be updated. \n> \n> That way, we're not tying the life cycle of a digest to a specific path on the server. \n\nThe issue is that without `path` attribute it is impossible for a client to send a cache-digest for a small part of the server.\n\nConsider the case when a client sends a cache-digest only containing the digests for files under `/scripts`.  When a server considers if it should push `/img/foo.jpg`, it should not refer to the digest, since the digest does not cover the file.  Without `path` attribute, a server cannot make such distinction; it would estimate that the image file is not being cached by the client, and push the file to the client every time it receives a new request (since the image will never become the part of the cache-digest that only covers files under `/scripts`).\n\nIn other words, having `path` attribute defined is a must if we are to allow a client to send a digest covering only a specific portion of a host, regardless of whether we should provide a mechanism to update part of the digest (by using `id` or something alike).\n\nAnd regarding if we should define a way to update part of a digest, I wonder what the use-case would be.\n\nFor H2 frame-based digest, a server can make a good guess of the client's cache state, since the server knows what it has sent.  OTOH for the header-based digest, we should not provide a way to _update_ a previously sent digest, since many HTTP client APIs (e.g. Fetch) does not provide a guarantee that multiple requests will be sent over a single HTTP/2 connection.\n",
          "createdAt": "2016-02-10T05:55:36Z",
          "updatedAt": "2016-02-10T05:55:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's always possible to send a digest over a small slice of the server, just include resources that are in that slice.  That leaves the main advantage of including a path to be one of reducing the chance of a false positive.  That is, if `/foo/1` ends up colliding with `/bar/55`, then including `path=/bar` will avoid that collision.\n\nIt's a small thing, and in retrospect, it's probably not worth the bits that it saves.  Better to spend those bits on making the false positive rate lower by giving the digest more bits.\n",
          "createdAt": "2016-02-10T08:26:56Z",
          "updatedAt": "2016-02-10T08:26:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Stepping back, there are a few possible ways that this can work:\n1. Every digest received on a connection is valid. That means that the server consults them all, and treats all as current. If the browser clears its cache, evicts, etc., it has no way to invalidate them except to drop the connection.\n2. Only the most recent digest on a connection is valid. That means that there is only one \"current\" digest, and so multiple digest sources can't co-exist on the same origin.\n3. We have some sort of digest identifier (with a sensible default), so that the browser can either create a new digest or replace an existing one on the server at will.\n\n`path` seemed like a confusing version of (c) to me; it conflated digest version management with scoping. I was proposing something like `id=foo` for (c).\n\n@martinthomson it sounds like you're leaning towards (a) above, correct?\n",
          "createdAt": "2016-02-16T05:45:28Z",
          "updatedAt": "2016-02-16T05:45:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Reconsidering the syntax discussion above, my personal preference (which is not a demand :) is (a), because in the long term, we'd hope that browsers create digests natively; the header is for experimentation. The canonical form should be the one that's the most used.\n\nYMMV, just my .02.\n",
          "createdAt": "2016-02-16T05:47:34Z",
          "updatedAt": "2016-02-16T05:47:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes,  (a) makes the most sense to me too. Almost. All requests are potential sources of useful information, but there is a risk of destroying stateless request handling. \n\nThink of it as having the digest on the request determining what you push for that request. The server probably should not infer that a request without a digest has anything cached, even if the previous request had the header.  We should try to avoid making inter-request state a real thing, even for cases like this where inference is key. \n\nSome inference is inevitable, but no need to codify it. \n",
          "createdAt": "2016-02-16T07:18:25Z",
          "updatedAt": "2016-02-16T07:18:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot @martinthomson Sorry for the delay.\n\n> Reconsidering the syntax discussion above, my personal preference (which is not a demand :) is (a)\n\nNo objections.  Moving one step forward, how should we encode the attributes (e.g. origin)?  My preference goes to something like below.\n\nBy using the first octet to contain flags to indicate what extensions are being used, we can keep the spec. open to future extensions (e.g. the `path` attribute, sending digest for stale resources).\n\n```\n+--------------+----------------+\n| Reserved (7) | Has-Origin (1) |\n+--------------+---+------------+\n| Origin-Len? (16) |\n+------------------+\n|   Origin? (*)    |\n+------------------+--------------------------------------------+\n|         Digest-Value? (*)                    ...\n+---------------------------------------------------------------+\n\nThe CACHE_DIGEST frame payload has the following fields:\n\n* Reserved: Reserved bits. Clients MUST set the bits to zero. Servers MUST ignore CACHE_DIGEST frames that have any of the reserved bits being set.\n* Has-Origin: A flag indicating if Origin-Len and Origin fields exist.\n* Origin-Len: An unsigned, 16-bit integer indicating the length, in octets, of the Origin field.\n* Origin: Scope of Digest-Value\n* Digest-Value: An optional sequence of octets containing the digest as computed in {{computing}}.\n```\n",
          "createdAt": "2016-02-23T03:37:13Z",
          "updatedAt": "2016-02-23T03:37:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \n\n> Stepping back, there are a few possible ways that this can work:\n> 1. Every digest received on a connection is valid. That means that the server consults them all, and treats all as current. If the browser clears its cache, evicts, etc., it has no way to invalidate them except to drop the connection.\n> 2. Only the most recent digest on a connection is valid. That means that there is only one \"current\" digest, and so multiple digest sources can't co-exist on the same origin.\n> 3. We have some sort of digest identifier (with a sensible default), so that the browser can either create a new digest or replace an existing one on the server at will.\n> \n> `path` seemed like a confusing version of (c) to me; it conflated digest version management with scoping. I was proposing something like `id=foo` for (c).\n\nThank you for the explanation.  That is a good point.\n\nI'd assume we would have the same issue for the Origin attribute as well.\n\nConsider a case where a server is authoritative for `*.example.com`.  A client might first send a request for `a.example.com` and a cache digest with its `origin` attribute set to `a.example.com`, then send a request for `b.example.com` and another cache digest with its `origin` set to `b.example.com`.\n\nIn this case, I believe that the server should retain both digests, and replace either of them when a client sends a new cache digest with same `origin` value.  In other words, to me it seems natural to conflate the scope and version management (and my understanding was that we should do the same for `path`).\n",
          "createdAt": "2016-02-23T03:39:55Z",
          "updatedAt": "2016-02-23T03:39:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho, I think that a header field could just include the origin as a parameter.  It will encode more efficiently that way:\n\n```\nCache-Digest: d=goihsgosihdfoih, o=https://example.com:8443\n```\n\nNoting of course that paying attention to origin only reduces false positive rate because servers won't test the digest against resources on other origins.  That makes the o= attribute ignoreable.\n",
          "createdAt": "2016-02-23T16:40:22Z",
          "updatedAt": "2016-02-23T16:40:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \n\n> @kazuho, I think that a header field could just include the origin as a parameter. It will encode more efficiently that way:\n> \n> ```\n> Cache-Digest: d=goihsgosihdfoih, o=https://example.com:8443\n> ```\n\nI agree that it would be more natural (and easy to use from sender's standpoint) if we use parameters for header fields.  The downside would be that on the server side there needs to be two decoders for the attributes (one for the header and one for the frame), and that we would need to keep the definitions for the two in sync.\n\nTherefore, I'd be happy if we could just include the name=value pairs in the frame as they are in the HTTP/2 frame in case we are going to use name=value pairs for the header definition (and that was the intention of (b)).\n\n> Noting of course that paying attention to origin only reduces false positive rate because servers won't test the digest against resources on other origins. That makes the o= attribute ignoreable.\n\nI think we have a disagreement here.\n\nIn my view, client's cache state of a resource from server's viewpoint has three states: _unknown_, _cached_, _not-cached_.  State of any resource is _unknown_ until a client sends a cache-digest.  When a client sends a cache-digest for a specific origin, then the cache states of the resources belonging to the origin switches to either _cached_ or _not-cached_.  Cache states of resources _not_ belonging to the origin continue to be _unknown_.\n\nHow should a server use the information for optimizing content delivery?  IMO a server should:\n- for _cached_ resources, do not push\n- for _not-cached_ resources, always push\n- for _unknown_ resources, push if the resource is tiny (or do not push at all)\n\nAs you can see, the strategy is different between _not-cached_ and _unknown_.  In other words, distinguishing between the two states by using the origin attribute is highly recommended; we are likely to see false-_negatives_ if we permit the servers to ignore the attribute.\n",
          "createdAt": "2016-02-23T21:14:38Z",
          "updatedAt": "2016-02-23T21:15:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wasn't aware that you were still pursuing the frame.\n\nAs for the tri-state, yes, I can see that failing to narrow the scope does cause the unknown set to be eliminated.  Maybe default origin to that of the request and allow it to be overridden.  Note that in that case, a path (or maybe a combined origin and path, i.e., a URL prefix) does make sense.\n",
          "createdAt": "2016-02-24T15:12:49Z",
          "updatedAt": "2016-02-24T15:12:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \n\n> I wasn't aware that you were still pursuing the frame.\n\nIt seems likely that I was not clear enough when I stated: _a) use the frame definition as the base, and define the header as the base64-encoded form of the frame_, to which we have agreed.\n\nRereading the comments on this PR, I think we have an agreement that the frame definition should be defined as the base (and to define the header as a variant to the frame definition), but do not have a clear agreement on how to encode the attributes (e.g. origin) when either of the frame or the header is used.\n\n@mnot, @martinthomson Therefore, would you mind confirming your preference in how to encode the attributes in the frame and the header.  Sorry for the fuss.\n\nAs said, my weak preference is to use _name=value_ pairs (defined using ABNF) in both cases.  In case of CACHE_DIGEST frame, the pairs should be embedded as a string.  Pros of the approach is that the spec. would be simple (since at least the syntactical definition of the attributes can be 100% shared) and that the header would be easy to understand.  Size of the frame can be kept small if we choose short names for pre-defined attributes (e.g. use `o=https://...` to represent the origin attribute).\n\n>  Maybe default origin to that of the request and allow it to be overridden.\n\n+1\n\n> Note that in that case, a path (or maybe a combined origin and path, i.e., a URL prefix) does make sense.\n\nI Agree that we need path.\n\nWhether we should combine origin host and path into a single attribute containing a URL prefix IMO depends on how much the pushed contents are scattered across the domains.  If it is typical to have a website that scatters CSS and/or JavaScript files to tens of hosts under a single domain, you would likely want to use a wild-card hostname to specify the origin of the cache-digest under the premise that the server uses a wild-card certificate.  And if we are to support wild-card hostnames with the origin attribute, we should define origin and path attributes separately, since a URL prefix including a wild-card hostname (e.g. `https://*.example.com/foo`) is confusing.\n",
          "createdAt": "2016-02-25T05:11:44Z",
          "updatedAt": "2016-02-25T05:46:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I don't have strong opinions on the encoding inside the frame; I'd suggest as long as it's sensible (e.g., there's no unnecessary encoding), that should be fine. \n\nRegarding origin -- yes, that potentially limits the scope too. \n\nI'm not so sure of the tri-state. The draft currently says: \n\n> A client MAY choose a subset of the available stored responses to include in the set.\n\nThis is to allow it limit the size of the digest (e.g., if it has thousands or more cached responses, with a long heavy tail).\n\nSo, the server can't really assume that once it has a digest, any non-matching URLs are _not-cached_.\n\nWe could introduce a flag from the client to indicate that it's a complete digest for the origin if we think that's an important distinction. Without that, _path_ doesn't make sense to me still (sorry). Even with it, I think that _path_ is potentially more complex than it's worth (sorry again), because I suspect Web server operators won't be segmenting their resources into separate paths for different digests, but instead there will be overlap.\n\nI also sometimes wonder if we should have a _fresh_ flag to indicate whether a cached representation is fresh, so the serve can choose to optimistically push a 304 (which is really cheap).\n",
          "createdAt": "2016-03-02T06:12:02Z",
          "updatedAt": "2016-03-02T06:12:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for your answer, and thank you for pointing out that the current draft allows clients to send a digest that does not cover all the fresh resources.\n\n> We could introduce a flag from the client to indicate that it's a complete digest for the origin if we think that's an important distinction.\n\nDue to the reasons stated below, I think we should introduce such flag, or else prohibit the clients from sending incomplete digests.\n\nIt is typical to see cases where the RTT from a client to the application server is much greater than the RTT to the edge server.\n\nThe bandwidth an edge server can utilize for pushing assets before starting to serve a response from an origin server is exponentially proportional to the ratio between the RTTs of the two.  It is exponential because the TCP send window multiplies by 2x every round-trip.  If the RTT to the application server is 4x of that to the edge server, the bandwidth available for push is 3 round-trips (~100KB).  If the ratio is 5x, available bandwidth would be 4 round-trips (~200KB).\n(see the figure on http://blog.kazuhooku.com/2015/12/optimizing-performance-of-multi-tiered.html)\n\nHowever, I doubt if we would typically want to use that much of a bandwidth for pushing resources that _might_ be cached, considering the fact that not all users are subscribing to their carriers with a fixed-rate plan.\n\nIn other words, IMO to fully utilize the bandwidth available for server-push, being able to distinguish between _unknown_ and _not-cached_ is a must.\n\n> I also sometimes wonder if we should have a fresh flag to indicate whether a cached representation is fresh, so the serve can choose to optimistically push a 304 (which is really cheap).\n\nI've always been eager to have this.  And I agree on using a a flag to indicate whether a digest (conveyed in a H2 frame or a HTTP header) is for fresh resources or for stale ones.\n\nThe obstacle here is that there has not yet been an agreement between HTTP/2 implementers how to push a 304.  Neither Chrome nor Firefox correctly implement support for pushed 304s (see https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0222.html) or do they recognize a push using `HEAD` method.\n",
          "createdAt": "2016-03-02T07:10:38Z",
          "updatedAt": "2016-03-02T07:18:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thinking about this, one thing that strikes me is that the use cases for the frame vs. the header are subtly different.\n\nI suspect the frame is always (or nearly always) going to be generated by the HTTP cache of the client, not application code, and the header is going to be generated by application code, not the HTTP cache.\n\nThe HTTP cache has a definitive view of all responses it holds for the origin, and it doesn't have any concept of application boundaries within the origin. Therefore, I think that the `path` parameter doesn't make much sense for the frame type, and it's probably safe to always make the origin that of the associated stream. I'm not necessarily against defining these parameters for the frame, but I suspect they won't get used much.\n\nOn the other hand, the header is going to be used by ServiceWorker, and that has a definite \"footprint\" on the origin that is useful to describe with `path`. \n\nSending an incomplete digest is very important for the HTTP cache / frame use case, because the client wants to send enough digest to be useful, but not so much as to require the server to pause before starting to push, because it's still consuming the digest (remembering that if the connection is new, filling the initial congestion window is a risk for a cache holding even ~700 responses for the origin). Remember, the HTTP cache can't make rational decisions about how to segment up the origin into paths.\n\nIt's not nearly as important for the service worker case, since the SW has application knowledge, and is not (usually) handling the complete origin.\n",
          "createdAt": "2016-03-11T06:26:00Z",
          "updatedAt": "2016-03-11T06:26:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Regarding pushing 304s -- we should write an I-D :)\n",
          "createdAt": "2016-03-11T06:26:22Z",
          "updatedAt": "2016-03-11T06:26:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot I agree with your view that `path` is unlikely be to used with a frame.\n\nAnd I think it might be better for us to (at least for the time being) step back from trying to determine what is right for SW, considering the fact that having a spec. is not essential for a SW-based cache digest implementation.\n\nThere is no need to define every aspect of the cache-digest that will be used by an SW-based implementation, considering the fact that a SW is fully controlled by its origin.  It is safe for every origin to use their own variant of _cache-digest_.   Actually, users of a SW-based implementation might want to use more application-specific information than `path` as a key for determining whether if a resource should be part of the digest.  For example, it might be a good idea to use the content-type.\n\nTherefore, I think in the next revision we should try to define:\n- how to express origin within the H2 frame\n- how to express a partial digest\n- how to make the frame extensible (so that we could add support for digest of stale resources, etc.)\n\nWe could potentially discuss how it should be encoded as a H1 header, but I do not think it is necessary (due to the reasons explained).\n",
          "createdAt": "2016-03-16T06:16:43Z",
          "updatedAt": "2016-03-16T06:16:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Regarding your comment on the necessity of a partial digest, I agree that we should have a flag to express that.\n\nOTOH I assume that a cache-digest sent within INITCWND can be much larger than for 700 resources (this might be a knit pick, I'm sorry).  If P is 256 (i.e. probability of false positive is 1/256), then the space consumed by a single resource will be 8 bits, which means that you could store a digest of 1,400 resources within the first packet, or a digest of 14,000 resources within INITCWND (in case INITCWND is 10).\n\nAlso, I would suggest a client to cut down the value of P to cram more resources into a cache digest before starting to send a partial digest.  IMO a cache digest with P=2 still has merit.  Consider a case where a client is not in possession of 10 resources that are required to render a document it requested.  Even in case of P=2, we would be at average able to determine 5 resources that are _not-cached_, and start pushing them.\n\nPS. In case P=2, the required space for a digest will be slightly above 2 bits per resource, which means that you can send a digest of ~5000 resources within a single packet (1,400 octets).\n",
          "createdAt": "2016-03-16T06:30:09Z",
          "updatedAt": "2016-03-16T06:32:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@kazuho I was assuming that client-side INITCWND is still largely around 3, not 10. I've looked for data on this, but haven't found much; do you know of any? @igrigorik any idea?\n",
          "createdAt": "2016-03-16T06:36:43Z",
          "updatedAt": "2016-03-16T06:36:43Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "I don't have conclusive data either but, FWIW, in the experiments I've run in the past (against ~top 1K) the majority were 10.. Part of the problem is that there is no definite way to test this.\n",
          "createdAt": "2016-03-21T23:55:46Z",
          "updatedAt": "2016-03-21T23:55:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "@igrigorik not servers (which \"top 1K\" sounds like) -- clients (e.g,. OSX, Windows, iOS). Since the client is sending the cache digest, that's what's important here.\n",
          "createdAt": "2016-03-21T23:59:46Z",
          "updatedAt": "2016-03-21T23:59:46Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "Doh, misread that -- yes, I was referring to server. I don't have any good data for clients.. and I'd love to get my hands on it.\n",
          "createdAt": "2016-03-22T00:19:56Z",
          "updatedAt": "2016-03-22T00:19:56Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "NONE",
          "body": "> Regarding pushing 304s -- we should write an I-D :)\n\nFWIW, I started this a while back: https://groups.google.com/a/chromium.org/d/msg/net-dev/yfkW4mkWIPU/5RckmfktJgAJ - check out the linked doc, would love to hear your thoughts.\n\nAnd yes, we probably should.. Assuming we agree on what the behavior should be.\n",
          "createdAt": "2016-03-22T00:22:12Z",
          "updatedAt": "2016-03-22T00:22:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \n\n> I was assuming that client-side INITCWND is still largely around 3, not 10. I've looked for data on this, but haven't found much; do you know of any?\n\nThat's a good question!  Hadn't thought that the numbers could be different bet. server and client.\n\nThat said, regardless of how large INITCWND on the client side is, I have no objection is having a flag to indicate a _partial_ digest.  Having _some_ information is definitely better than having none.\n\n@igrigorik \n\n> > Regarding pushing 304s -- we should write an I-D :)\n> \n> FWIW, I started this a while back: https://groups.google.com/a/chromium.org/d/msg/net-dev/yfkW4mkWIPU/5RckmfktJgAJ - check out the linked doc, would love to hear your thoughts.\n> \n> And yes, we probably should.. Assuming we agree on what the behavior should be.\n\nYeah.  Now I remember leaving a comment on the linked doc pointing out that cache validators can be pushed without using 304, which we discussed in detail in https://github.com/h2o/h2o/issues/447.  But the workaround described in the issue is a _hack_, and I would definitely love to see the method of pushing a cache validator being formalized.\n\nAnd for the matter, my two cents go to pushing a HEAD request for the purpose.\n",
          "createdAt": "2016-03-22T00:59:58Z",
          "updatedAt": "2016-03-22T00:59:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wondering what would be the right strategy for a web server to take if it receives a partial cache digest, I am starting to think that using a 1xx response is the best way to do it.\n\nWhat I am suggesting is, that if a server receives a partial digest it should:\n- push tiny resources that are not known to be cached\n- for larger resources not known to be cached, send `Link: rel=preload` using 1xx as an early metadata indication\n\nRegarding the use of a 1xx response for the purpose, I agree to @reschke's [comment](https://github.com/w3c/preload/issues/38#issuecomment-200236033) that we need to define a new status code.\n\nI also agree with @mnot's [comment](https://github.com/w3c/preload/issues/38#issuecomment-193532723) that we should be careful of interoperability issues when using 1xx on the open web, and in case of early metadata indication, I believe we could make it a opt-in from the client-side (e.g. `Expect: 1xx-early-metadata` or something), or just limit the feature to HTTP/2 over TLS.\n\nsee also: https://github.com/w3c/preload/issues/38\n",
          "createdAt": "2016-04-06T05:59:05Z",
          "updatedAt": "2016-04-06T05:59:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "I chatted with Jana about this in B-A, who asserted that client-side INITCWND is often 10.\n\nI've created some issues to cover what I think there's agreement upon above.\n\n@kazuho, above you mention wanting to define \"how to express origin within the H2 frame.\" What's the use case for that? In the current draft, the origin of the digest is linked to the stream that the digest is sent on. Is there a case where we'd want to send a digest before any requests are sent to an origin?\n",
          "createdAt": "2016-05-04T06:30:27Z",
          "updatedAt": "2016-05-04T06:30:27Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the INITCWND info and for opening the issues.\n\n> above you mention wanting to define \"how to express origin within the H2 frame.\" What's the use case for that? In the current draft, the origin of the digest is linked to the stream that the digest is sent on. Is there a case where we'd want to send a digest before any requests are sent to an origin?\n\nYes for SW use-case, but I am not sure for H2 frames.\n\nIn case of SW with prior knowledge of how the web-site is deployed, the client may want to send a digest that covers other hosts than the origin (if the server presents a wild-card certificate).  This would be useful for websites that serve resources files (e.g. JS, CSS) from a separate hostname.\n\nOTOH, for H2 (without the prior knowledge) it would be less likely to see such use.\n\nSo under the premise that the draft would mainly focus on defining H2 frame (i.e. evade from defining the `path` attribute), I do not think there's a strong need for an attribute to overwrite the origin.\n",
          "createdAt": "2016-05-04T22:41:32Z",
          "updatedAt": "2016-05-04T22:41:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "OK, that makes sense. I think we can close this pull request (if I have that wrong, please re-open!), and we can focus on those issues and getting a new draft out.\n",
          "createdAt": "2016-05-10T05:33:13Z",
          "updatedAt": "2016-05-10T05:33:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> OK, that makes sense. I think we can close this pull request (if I have that wrong, please re-open!), and we can focus on those issues and getting a new draft out.\n\n:+1:\n",
          "createdAt": "2016-05-10T05:35:06Z",
          "updatedAt": "2016-05-10T05:35:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3MDQ3MjA=",
      "title": "Capport problem suggestions",
      "url": "https://github.com/mnot/I-D/pull/168",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Feel free to cherry-pick from this.  BTW, I didn't build.\n",
      "createdAt": "2016-02-09T04:46:42Z",
      "updatedAt": "2016-02-09T05:23:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "3813863663db071e8e490c2927127d6c1359539f",
      "headRepository": "martinthomson/I-D",
      "headRefName": "capport-problem-suggestions",
      "headRefOid": "dd366cea98406ee3af52cc1a7118f2815eadec67",
      "closedAt": "2016-02-09T05:23:53Z",
      "mergedAt": "2016-02-09T05:23:53Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "5a2bfec9267fd157a7f0e299a177c1b4a93e3d29"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3ODk5MzY=",
      "title": "Proposed changes",
      "url": "https://github.com/mnot/I-D/pull/169",
      "state": "CLOSED",
      "author": "thomas-mangin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello Mark, \n\nI would like to propose the following changes:\n- explicitly indicate that the strings are in UTF-8 ( allowing messages in the local language )\n- explicitly allowing error code 451 ( this would make lots of sense as it is one of the reason one may need to block some content )\n- disallow the use of URLs. It is too easy for a attacker to spoof a local proxy and reply on its behalf, therefore leading the end user to click a link redirecting toward a nefarious site (for example using a redirection service where the end URL is obfuscated)\n\nAs I am not a native english speaker, feel free to change my suggested wording.\n\nSincerely,\n\nThomas\n",
      "createdAt": "2016-02-09T18:39:27Z",
      "updatedAt": "2016-02-17T00:35:31Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "b1a3c4613c3f96165fd6e2c251937f77f0e0aa74",
      "headRepository": null,
      "headRefName": "gh-pages",
      "headRefOid": "4deff2204d99b5872638acb19b3b13c157c0b951",
      "closedAt": "2016-02-17T00:35:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "See latest revision, happy to take more input if you have it.\n",
          "createdAt": "2016-02-17T00:35:31Z",
          "updatedAt": "2016-02-17T00:35:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxMTA3OTE=",
      "title": "[h2-cache-digest] fix off-by-one normalizing N",
      "url": "https://github.com/mnot/I-D/pull/186",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I am sorry but I was not precise in how we should fix #183.\n\nThis PR proposes what I believe would be the correct way to calculate the digest.\n",
      "createdAt": "2016-06-01T01:33:40Z",
      "updatedAt": "2016-06-01T02:03:49Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "550345a672174a5f1b86160697e10695953ab13b",
      "headRepository": "kazuho/I-D",
      "headRefName": "h2-cache-digest/off-by-one-refix",
      "headRefOid": "ec7aecea6393cac05b1a36a059049c702be51250",
      "closedAt": "2016-06-01T02:03:49Z",
      "mergedAt": "2016-06-01T02:03:49Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "20805388beb20f91c289624d30af6f8ff950165c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxMjMwNTc=",
      "title": "padding must be the unterminated q-part of the encoded value",
      "url": "https://github.com/mnot/I-D/pull/187",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The bits used in the unary encoding has been reversed in b276101.  That means that we should also reverse the bits used for the padding.\n\nThe padding needs to be a partial q-part of the encoded value, or a decoder might erroneously decode values from the padding.\n",
      "createdAt": "2016-06-01T05:01:17Z",
      "updatedAt": "2016-06-01T05:02:10Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "20805388beb20f91c289624d30af6f8ff950165c",
      "headRepository": "kazuho/I-D",
      "headRefName": "kazuho/padding-quontient",
      "headRefOid": "fb674605920a0a9ea7fa5599ca719a6580f6798d",
      "closedAt": "2016-06-01T05:02:10Z",
      "mergedAt": "2016-06-01T05:02:10Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "9dd5fc0aa9fd12479f9eecfd0f0599bc5f7cfcda"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "/me hits head. of course.\n",
          "createdAt": "2016-06-01T05:02:06Z",
          "updatedAt": "2016-06-01T05:02:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxMjM1ODg=",
      "title": "Fix misuses of `stale`",
      "url": "https://github.com/mnot/I-D/pull/188",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The first paragraph discusses about fresh digests.\n\nThe second paragraph _is_ discussing about stale digests.  But when we say `last STALE CACHE_DIGEST`, `STALE` doesn't refer to the flag defined in the CACHE_DIGEST frame.  It rather refers to the term defined in RFC 7234.  Therefore, it might be better to spell them in lowercase.\n",
      "createdAt": "2016-06-01T05:11:30Z",
      "updatedAt": "2016-06-01T05:18:27Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "9dd5fc0aa9fd12479f9eecfd0f0599bc5f7cfcda",
      "headRepository": "kazuho/I-D",
      "headRefName": "kazuho/paragraph-about-fresh",
      "headRefOid": "1df2b0d33689013b64558d982313cceb12000959",
      "closedAt": "2016-06-01T05:18:27Z",
      "mergedAt": "2016-06-01T05:18:27Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "53b22732ecc61309bd1fbd42b588c0cbbea12962"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Originally reported in a [commit comment](https://github.com/mnot/I-D/commit/f23216be34be42ccf0010795d25eb8e92af63efa#commitcomment-17673981), but opened as a PR here.\n\nI'm afraid it was too hard to notice and track.\n",
          "createdAt": "2016-06-01T05:13:42Z",
          "updatedAt": "2016-06-01T05:13:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks :)\n",
          "createdAt": "2016-06-01T05:18:25Z",
          "updatedAt": "2016-06-01T05:18:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIxMjM5NzY=",
      "title": "define flags using bit-mask values",
      "url": "https://github.com/mnot/I-D/pull/189",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My understanding is that in RFC 7540 the flags are defined as bit-mask values.  This PR aligns the flags defined in the draft to that convention.\n\nIn other words, the flags are now given values: `0x1`, `0x2`, `0x4`, `0x8` (instead of `0x1`, `0x2`, `0x3`, `0x4`).\n",
      "createdAt": "2016-06-01T05:18:39Z",
      "updatedAt": "2016-06-07T07:00:46Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "53b22732ecc61309bd1fbd42b588c0cbbea12962",
      "headRepository": "kazuho/I-D",
      "headRefName": "kazuho/flags-are-bitmasks",
      "headRefOid": "b5261fc991bf729f7573cfb19a4697de4933c6f0",
      "closedAt": "2016-06-07T07:00:44Z",
      "mergedAt": "2016-06-07T07:00:44Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "ab601a8bce9b7ab1dd664d13129a54d90ddf4287"
      },
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Originally reported in [a commit comment](https://github.com/mnot/I-D/commit/f23216be34be42ccf0010795d25eb8e92af63efa#commitcomment-17673997).\n",
          "createdAt": "2016-06-01T05:19:52Z",
          "updatedAt": "2016-06-01T05:19:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Good catch, thanks. \n",
          "createdAt": "2016-06-07T07:00:46Z",
          "updatedAt": "2016-06-07T07:00:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0NzU3NDE4Nzc=",
      "title": "Fix encoder issues in h2-cache-digest-01",
      "url": "https://github.com/mnot/I-D/pull/195",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@tatsuhiro-t has found following two issues in the encoding process described in h2-cache-digest-01.\n\nChange `log2(\"P\"5) bits` to `log2(\"P\") bits`. It's unclear why but an unnecessary character `5` has somehow crept into the draft. Commit a997046 removes it.\n\nOff-by-one error between the coder and encoder. This is because the smallest hash value being encoded by the described process is `hashvalue - 1`, whereas the decoder expects the value to be `hashvalue`. This is obviously a bug in the encoding process. In step 3, the smallest value inserted to `hash-values` should have been `-1`, but the draft errorneously specified it to be `0` (note that without it being specified as `-1`, it is impossible to encode a hash-value of zero).\n\nCommit 7a39203 is a minimal fix to the issue. Commit 1e1d6f2 refactors the algorithm for simplicity at the same time achieving more commonality with the decoding process being described.\n\n@tatsuhiro-t could you please take a look to see if these fixes resolve your issues?\n",
      "createdAt": "2016-06-30T00:06:28Z",
      "updatedAt": "2016-07-07T07:30:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "9064788c1b9581400c4248592e86d515780fc5eb",
      "headRepository": "kazuho/I-D",
      "headRefName": "kazuho/h2-cache-digest/encoder-bugs-in-01",
      "headRefOid": "7822c9c7c300a6861aced1ccac2dd8e392f39553",
      "closedAt": "2016-07-07T07:30:53Z",
      "mergedAt": "2016-07-07T07:30:53Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "80812c82cf45c5a527275d7a40c7b5897f965c4a"
      },
      "comments": [
        {
          "author": "tatsuhiro-t",
          "authorAssociation": "NONE",
          "body": "Thank you for quick fixes.  Will check this tonight.\n",
          "createdAt": "2016-06-30T00:28:10Z",
          "updatedAt": "2016-06-30T00:28:10Z"
        },
        {
          "author": "tatsuhiro-t",
          "authorAssociation": "NONE",
          "body": "Everything else looks good to me.\n",
          "createdAt": "2016-06-30T14:30:50Z",
          "updatedAt": "2016-06-30T14:30:50Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tatsuhiro-t Thank you for checking. Fixed in the commit above.\n",
          "createdAt": "2016-07-01T04:15:12Z",
          "updatedAt": "2016-07-01T04:15:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0OTI4MjAyMDQ=",
      "title": "Link header parsing algorithm - suggested tweaks",
      "url": "https://github.com/mnot/I-D/pull/203",
      "state": "MERGED",
      "author": "alexpeattie",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "First of all, thanks for providing such a detailed specimen algorithm in the spec @mnot  \ud83d\ude0a ! I just finished implementing a pretty thorough Link header parser in Ruby ([alexpeattie/nitlink](/alexpeattie/nitlink)) which sticks to the spec as closely as possible - during the dev process I came spotted a couple of points which the spec might not cover, or where it could be clearer:\r\n\r\n* The algorithm states that `field_value` should be split <br><br><blockquote>on \",\" characters, excepting \",\" characters within quoted strings as per RFC7230, Section 3.2.6</blockquote>\r\nbut presumably it should also avoid splitting on \",\" characters which form part of the `URI-Reference` - e.g. `</pages=2,3>; rel=\"next\"`\r\n\r\n* In many languages (e.g. JS, python, Ruby) splitting a `rest` such as `\";rel=next\"` on the character \";\" will yield a collection of two items - an empty string (`\"\"`) and `\"rel=next\"`. To avoid ambiguity it might be worth clarifying that empty `parameter` should be skipped\r\n\r\n* I wasn't sure how to represent an \"anonymous\" link context? In my implementation I just used `nil` (i.e. null), but it would be handy if the algo gave a recommended approach\r\n\r\n* Following 6.4.1, duplicate occurrences of \"media\", \"title\", \"title*\" or \"type\" should be ignored, so I added a step to 3.12\r\n\r\nOne last question - based on my reading of the spec, any arbitrary text can precede the opening \"<\" character, and still be parseable? Is that correct/the intention?",
      "createdAt": "2016-11-08T17:12:52Z",
      "updatedAt": "2016-11-16T06:45:14Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "3622ca3126b661e0abf3fd0d17023bfbad9daa3a",
      "headRepository": null,
      "headRefName": "rfc-5988-parsing-algo-tweaks",
      "headRefOid": "181510836ae26e730cc4fc8f6f9f83fcb4ad1e39",
      "closedAt": "2016-11-16T06:45:10Z",
      "mergedAt": "2016-11-16T06:45:10Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "09571511252ba99c05efeea2f4fc0276770a85eb"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!\n",
          "createdAt": "2016-11-16T06:45:14Z",
          "updatedAt": "2016-11-16T06:45:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA4NTU1MjU2",
      "title": "adding \"Discovery\" section",
      "url": "https://github.com/mnot/I-D/pull/214",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "as discussed in #41 ",
      "createdAt": "2017-03-01T15:00:04Z",
      "updatedAt": "2017-03-06T06:15:24Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "713ed9ce3bd7497023c58e7576e52f10c1021ee5",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-2",
      "headRefOid": "a505f7b07f5e0cf7a9615024bb11d66f28a64c58",
      "closedAt": "2017-03-06T06:15:24Z",
      "mergedAt": "2017-03-06T06:15:24Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "84e4151b1b5228f2c396bb2d4eeb1d43504836df"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA4NTYwMzY5",
      "title": "adjusting spelling to convention",
      "url": "https://github.com/mnot/I-D/pull/215",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-01T15:23:26Z",
      "updatedAt": "2017-03-06T06:16:42Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "713ed9ce3bd7497023c58e7576e52f10c1021ee5",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-3",
      "headRefOid": "9a2bd197242d01ae791190d6db390a3f0f6deb30",
      "closedAt": "2017-03-06T06:16:42Z",
      "mergedAt": "2017-03-06T06:16:42Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "18f6553384f02713938c3eaee5eb2f3a6b3880ce"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA4NTYwODEz",
      "title": "adjusting terminology",
      "url": "https://github.com/mnot/I-D/pull/216",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-01T15:25:22Z",
      "updatedAt": "2017-03-06T06:16:20Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "713ed9ce3bd7497023c58e7576e52f10c1021ee5",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-4",
      "headRefOid": "14bd051efbf314ba410500791df5166f5612e46d",
      "closedAt": "2017-03-06T06:16:20Z",
      "mergedAt": "2017-03-06T06:16:20Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "4d72b55f1cb8f5a679ccd0932b38a3d41503f66e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA5Mjc2NTUy",
      "title": "fixing typo",
      "url": "https://github.com/mnot/I-D/pull/217",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-06T15:02:37Z",
      "updatedAt": "2017-03-06T23:40:29Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "18f6553384f02713938c3eaee5eb2f3a6b3880ce",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-5",
      "headRefOid": "1c52134acc84f5ab84ede25b7ac310539202f917",
      "closedAt": "2017-03-06T23:40:29Z",
      "mergedAt": "2017-03-06T23:40:29Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "06823117537fc6609922a72eda22933f8913db35"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0MTEwNjIxOTcy",
      "title": "adding reference to HTTP Accept-Post header field",
      "url": "https://github.com/mnot/I-D/pull/218",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-14T13:36:16Z",
      "updatedAt": "2017-03-27T17:11:01Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "9cc277a27b979c5c80081b75e2c3f1d77531efb2",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-6",
      "headRefOid": "e1ba05802c770f2a5cf12d2123d3cf63b7001dec",
      "closedAt": "2017-03-27T17:11:01Z",
      "mergedAt": "2017-03-27T17:11:01Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "6a6c8bcbc2e26bf5796c6378c66b3ec0ac7e2172"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0MTExNDA0Njc0",
      "title": "Fix typo",
      "url": "https://github.com/mnot/I-D/pull/219",
      "state": "MERGED",
      "author": "gustafnk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-18T10:09:47Z",
      "updatedAt": "2017-03-19T02:25:25Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "9cc277a27b979c5c80081b75e2c3f1d77531efb2",
      "headRepository": "gustafnk/I-D",
      "headRefName": "patch-1",
      "headRefOid": "4e56d9e4242b3c5e049d13090511322da7fe85e4",
      "closedAt": "2017-03-19T02:25:25Z",
      "mergedAt": "2017-03-19T02:25:25Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "69fb46b57d4087415731b6d0dbded0faabb3d3bb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0MTEyODk4NTQw",
      "title": "Fix typo",
      "url": "https://github.com/mnot/I-D/pull/220",
      "state": "MERGED",
      "author": "gustafnk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-28T06:31:55Z",
      "updatedAt": "2017-03-28T20:32:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "6a6c8bcbc2e26bf5796c6378c66b3ec0ac7e2172",
      "headRepository": "gustafnk/I-D",
      "headRefName": "patch-2",
      "headRefOid": "f19ea301c5767381136a6d29f3e388d965a58006",
      "closedAt": "2017-03-28T20:32:49Z",
      "mergedAt": "2017-03-28T20:32:49Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "afb1be9517dee0402d51d6d54b6810af9489e3d5"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2017-03-28T20:32:53Z",
          "updatedAt": "2017-03-28T20:32:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0MTMwMDUxMTg1",
      "title": "typo",
      "url": "https://github.com/mnot/I-D/pull/235",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-07-12T04:00:52Z",
      "updatedAt": "2017-07-12T04:55:22Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "984c413258bbd4f7dd7376300beca0a3cdd10df8",
      "headRepository": "martinthomson/I-D",
      "headRefName": "patch-1",
      "headRefOid": "302e3c99ef1c1a633550fe2694e249fdd7905146",
      "closedAt": "2017-07-12T04:55:22Z",
      "mergedAt": "2017-07-12T04:55:22Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "bbd8e334081e0b3b8450b3c825d00ac665f85921"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0MTMwMDU2MTk1",
      "title": "Missed one",
      "url": "https://github.com/mnot/I-D/pull/236",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-07-12T05:07:41Z",
      "updatedAt": "2017-07-12T05:38:09Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "bbd8e334081e0b3b8450b3c825d00ac665f85921",
      "headRepository": "martinthomson/I-D",
      "headRefName": "patch-2",
      "headRefOid": "57328d2de172103e7c920834c77cf00827b6f094",
      "closedAt": "2017-07-12T05:38:09Z",
      "mergedAt": "2017-07-12T05:38:09Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e5885e3b809f2afbeb04441c7fb952d8b6fea7d1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0OTk3NzQ1",
      "title": "clarifying that `rel` must be present on each link",
      "url": "https://github.com/mnot/I-D/pull/244",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-08-09T21:46:01Z",
      "updatedAt": "2017-08-09T22:58:28Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "3f1855d8b3a34d47ed485702541f27ef8c1c473e",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-8",
      "headRefOid": "faf041e70e992280d6d3b7e81cf38958fca991f9",
      "closedAt": "2017-08-09T22:58:28Z",
      "mergedAt": "2017-08-09T22:58:28Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "b1041b865ce1e34dea7ea4eb790cfa7eb2440698"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNDQ5ODE4",
      "title": "Fix typo",
      "url": "https://github.com/mnot/I-D/pull/249",
      "state": "MERGED",
      "author": "machawk1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-09-27T17:07:18Z",
      "updatedAt": "2017-09-28T00:10:42Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "e3e7ccd779dd3d5ddc4fdc94b5662b0bae8f48ee",
      "headRepository": "machawk1/I-D",
      "headRefName": "patch-1",
      "headRefOid": "a0e8c24c76ef7156484430928bd8a35a1ddc1f5b",
      "closedAt": "2017-09-28T00:09:34Z",
      "mergedAt": "2017-09-28T00:09:34Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "7aac3d78ca9bf3283f75dc790647e2f5e33777f6"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "thx!",
          "createdAt": "2017-09-28T00:09:38Z",
          "updatedAt": "2017-09-28T00:09:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNDUxMTMw",
      "title": "Typo: \"new new\"",
      "url": "https://github.com/mnot/I-D/pull/251",
      "state": "MERGED",
      "author": "machawk1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Please verify that \"the\" replacing the first \"new\" is what was intended to be expressed.",
      "createdAt": "2017-09-27T17:13:24Z",
      "updatedAt": "2017-09-28T00:10:26Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "e3e7ccd779dd3d5ddc4fdc94b5662b0bae8f48ee",
      "headRepository": "machawk1/I-D",
      "headRefName": "patch-2",
      "headRefOid": "8ab51a07ff9583933e1f3a412196e9fc5a21e076",
      "closedAt": "2017-09-28T00:09:09Z",
      "mergedAt": "2017-09-28T00:09:09Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "2c0156a9bf325ad229f7a3944c13e2bfbdc47521"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "thx!",
          "createdAt": "2017-09-28T00:09:13Z",
          "updatedAt": "2017-09-28T00:09:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNTczMzEy",
      "title": "fixing name",
      "url": "https://github.com/mnot/I-D/pull/252",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-09-28T07:25:26Z",
      "updatedAt": "2017-09-28T23:54:57Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "2b473710470bab4669b3c5453c078713f9488ea4",
      "headRepository": "dret/I-D-1",
      "headRefName": "patch-9",
      "headRefOid": "b9761f13064d7ecad71a522ce8b1417924fbe5f2",
      "closedAt": "2017-09-28T23:54:53Z",
      "mergedAt": "2017-09-28T23:54:53Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "9db4328f85b4093ff32e1e871da1199426942ced"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thx!",
          "createdAt": "2017-09-28T23:54:57Z",
          "updatedAt": "2017-09-28T23:54:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ2MDQ4MjIx",
      "title": "s/te/the",
      "url": "https://github.com/mnot/I-D/pull/255",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-10-11T20:04:07Z",
      "updatedAt": "2017-10-11T20:09:55Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "5fc8199b8328fe88e0bb03ffc7fb74c4ffe016d4",
      "headRepository": "LPardue/I-D",
      "headRefName": "patch-1",
      "headRefOid": "0a01d0a131b24a95d49395461d6960518053e3ce",
      "closedAt": "2017-10-11T20:09:55Z",
      "mergedAt": "2017-10-11T20:09:54Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "13ce68d12f8c7c63dde64c4a417edd12bb2eddba"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ2MDUzNzI3",
      "title": "Reference CORS spec in place of Fetch",
      "url": "https://github.com/mnot/I-D/pull/256",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Seems a more general resource than Fetch description of CORS, ignore if you disagree.",
      "createdAt": "2017-10-11T20:29:09Z",
      "updatedAt": "2018-01-29T07:27:20Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "13ce68d12f8c7c63dde64c4a417edd12bb2eddba",
      "headRepository": "LPardue/I-D",
      "headRefName": "patch-2",
      "headRefOid": "5bce7e1b74ff7a6deb29c2ed8934d5c9ce32a950",
      "closedAt": "2018-01-29T07:27:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "This has been discussed a fair amount, Fetch is the correct reference (even if it's less reader-friendly).",
          "createdAt": "2018-01-29T07:27:20Z",
          "updatedAt": "2018-01-29T07:27:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ2MDU4NjYx",
      "title": "bcp56bis: Status code reason phrase",
      "url": "https://github.com/mnot/I-D/pull/258",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "* Replace `status phrase` with `reason phrase` to better align with terms used in RFC 7231 and RFC 7540.\r\n* Add comment that H2 doesn't even define a way to carry the version or reason phrase.",
      "createdAt": "2017-10-11T20:50:52Z",
      "updatedAt": "2018-01-29T07:26:40Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "13ce68d12f8c7c63dde64c4a417edd12bb2eddba",
      "headRepository": "LPardue/I-D",
      "headRefName": "patch-3",
      "headRefOid": "59c6a0aa7db065052af15bac850b40aedd9dd218",
      "closedAt": "2018-01-29T07:26:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Hey - thanks, but this is in the httpwg/http-extensions now; port over to there?",
          "createdAt": "2018-01-29T07:26:40Z",
          "updatedAt": "2018-01-29T07:26:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ5NDMyNzEx",
      "title": "Fix reference to parameterized",
      "url": "https://github.com/mnot/I-D/pull/261",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-10-30T04:08:33Z",
      "updatedAt": "2017-10-31T11:33:59Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "d4dc0b1fdf4c2392b1e72be3cb010a7a99328075",
      "headRepository": "martinthomson/I-D",
      "headRefName": "parameterized",
      "headRefOid": "31dc462a835233a782543c36341e354a942d8d32",
      "closedAt": "2017-10-30T04:28:11Z",
      "mergedAt": "2017-10-30T04:28:11Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "f05fc00e27f0d834b6c4ecf52fb0a865d3f4a6e2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMDEzMjkw",
      "title": "Grammar tweak",
      "url": "https://github.com/mnot/I-D/pull/282",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was a little awkward.",
      "createdAt": "2018-08-22T03:49:13Z",
      "updatedAt": "2018-08-23T04:13:31Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "fed558ceeb8f14d509b648ab2a8db6c7702194e5",
      "headRepository": "martinthomson/I-D",
      "headRefName": "patch-3",
      "headRefOid": "8a99236d0e6cf0310d54a827ca54f8453c173edf",
      "closedAt": "2018-08-23T04:13:31Z",
      "mergedAt": "2018-08-23T04:13:31Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "12fd622959d059c5b56daf3389ad56be6571f681"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ5ODY2Mzcx",
      "title": "Fix typos.",
      "url": "https://github.com/mnot/I-D/pull/287",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Please merge either this or #288.",
      "createdAt": "2019-02-03T09:43:37Z",
      "updatedAt": "2019-02-04T23:46:43Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ad7abe4ecb8bcfa6a136f23949edd9fe754e551c",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "fix_typos",
      "headRefOid": "a48d8b7c61e76fe9c18768442ade9475ab1228b8",
      "closedAt": "2019-02-04T23:46:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ5ODY2Mzc0",
      "title": "Either remove \"forward\" or replace it with \"destination\".",
      "url": "https://github.com/mnot/I-D/pull/288",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Please merge either this or #287.",
      "createdAt": "2019-02-03T09:43:41Z",
      "updatedAt": "2019-02-04T23:46:36Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ad7abe4ecb8bcfa6a136f23949edd9fe754e551c",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "no_forward",
      "headRefOid": "1c3d1bde056539a20ad21a3a6ee20efb88fbf108",
      "closedAt": "2019-02-04T23:46:36Z",
      "mergedAt": "2019-02-04T23:46:36Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "ea75c2a1f2f91f63ece3f258928bdab02ed70129"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 289,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNDE2MzU5",
      "title": "Style, fixes and typos.",
      "url": "https://github.com/mnot/I-D/pull/289",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-15T12:44:12Z",
      "updatedAt": "2019-02-18T00:35:31Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ed7274f67525d331d6bc26b76a5e6a5ee5f1cccd",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "style",
      "headRefOid": "407ab1bca564a5957ba5d4c275f9573d626f8a69",
      "closedAt": "2019-02-18T00:35:31Z",
      "mergedAt": "2019-02-18T00:35:31Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "c8a358c5216b1c676511dcbd3584d198462e6b41"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 290,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNDE2NDM2",
      "title": "Add HTTP Response Timeout.",
      "url": "https://github.com/mnot/I-D/pull/290",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-15T12:44:26Z",
      "updatedAt": "2019-02-18T00:42:30Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "ed7274f67525d331d6bc26b76a5e6a5ee5f1cccd",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "http_response_timeout",
      "headRefOid": "c5aff44eeb076ed01724594d8631f3408773ae2c",
      "closedAt": "2019-02-18T00:42:30Z",
      "mergedAt": "2019-02-18T00:42:30Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "0ad1532cdefe00fc1e7c9cbc4e06ac93423f4772"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNDE2NjQy",
      "title": "Add more TLS errors.",
      "url": "https://github.com/mnot/I-D/pull/291",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-15T12:45:17Z",
      "updatedAt": "2019-02-18T01:22:02Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "0ad1532cdefe00fc1e7c9cbc4e06ac93423f4772",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "tls_errors",
      "headRefOid": "5399f559be351c3937d8a535623ff86a71a33180",
      "closedAt": "2019-02-18T01:22:02Z",
      "mergedAt": "2019-02-18T01:22:02Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "379948f9a639d5457f00d8f89186c5b25616ca9b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzODYxMjU0",
      "title": "Extend end-user concept a little...",
      "url": "https://github.com/mnot/I-D/pull/293",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Noting that people who aren't system account holders may nonetheless be involved here.",
      "createdAt": "2019-02-18T10:29:44Z",
      "updatedAt": "2019-02-18T22:13:58Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "39b6988cc5503eb2770f776e775aa38b94148b4f",
      "headRepository": "sftcd/I-D",
      "headRefName": "patch-1",
      "headRefOid": "4a31a85e1296f057fd8eafc668fcc751a0a23b32",
      "closedAt": "2019-02-18T22:13:37Z",
      "mergedAt": "2019-02-18T22:13:37Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "b81f8b5a6fc403120285c610dddab3a6928fe25d"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2019-02-18T22:13:58Z",
          "updatedAt": "2019-02-18T22:13:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0Mjc4MzA5",
      "title": "Add HTTP Request Denied.",
      "url": "https://github.com/mnot/I-D/pull/294",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-19T14:39:30Z",
      "updatedAt": "2019-02-20T02:52:34Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "82c34a8ec7dc5e4ad666cfe864479c4ee708ac7f",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "http_request_denied",
      "headRefOid": "2762cabf4a31765881c7d30f4131d9ce9985226a",
      "closedAt": "2019-02-20T02:52:34Z",
      "mergedAt": "2019-02-20T02:52:34Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "fe46b9b0e558bb222ca71851a9f989738c75e91b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0Mjc4MzIy",
      "title": "Add HTTP Upgrade Failed.",
      "url": "https://github.com/mnot/I-D/pull/295",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-19T14:39:32Z",
      "updatedAt": "2019-02-20T02:51:42Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "079af807ee83ace4ad5e32f963c0368df0137b4f",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "http_upgrade_failed",
      "headRefOid": "28f94cb8ba3f5d675d4770b1ddce12f8610ca581",
      "closedAt": "2019-02-20T02:51:42Z",
      "mergedAt": "2019-02-20T02:51:42Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "82c34a8ec7dc5e4ad666cfe864479c4ee708ac7f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1NzI3MzMw",
      "title": "Add Proxy Loop Detected.",
      "url": "https://github.com/mnot/I-D/pull/296",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From Kazuki Hirota.\r\n\r\nSigned-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-02-25T00:34:11Z",
      "updatedAt": "2019-02-25T22:50:18Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "8e9498ac8023a4b03599b61ea24e12f51e3894da",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "proxy_loop_detected",
      "headRefOid": "756d15429105e9372262192ce21a96751dbfb949",
      "closedAt": "2019-02-25T22:50:18Z",
      "mergedAt": "2019-02-25T22:50:18Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "fe287f42b45e4baf5b8ed4b10b25d3d391dbadf8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 299,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyMzMwNTc1",
      "title": "Rename reminding FooCDN to SomeCDN.",
      "url": "https://github.com/mnot/I-D/pull/299",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reported by Rainer Jung.\r\n\r\nSigned-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-04-22T09:52:56Z",
      "updatedAt": "2019-05-03T01:26:55Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "2672c76f56e2481924ae2d179b86b2bc9d49837c",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "foocdn",
      "headRefOid": "aa8ab1ac637292be888a8b0ac00660e08be5d912",
      "closedAt": "2019-05-03T01:26:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moved to https://github.com/httpwg/http-extensions/pull/805.",
          "createdAt": "2019-05-03T01:26:55Z",
          "updatedAt": "2019-05-03T01:26:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 300,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyMzMwNTk3",
      "title": "Remove restriction on error codes in http_response_status.",
      "url": "https://github.com/mnot/I-D/pull/300",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-04-22T09:53:02Z",
      "updatedAt": "2019-05-03T01:26:44Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "2672c76f56e2481924ae2d179b86b2bc9d49837c",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "success_path",
      "headRefOid": "1238727289399129c1e8a556b8d1dc6063eed91f",
      "closedAt": "2019-05-03T01:26:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moved to https://github.com/httpwg/http-extensions/pull/804.",
          "createdAt": "2019-05-03T01:26:43Z",
          "updatedAt": "2019-05-03T01:26:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 301,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyMzMwNjEz",
      "title": "Add Proxy Internal Response.",
      "url": "https://github.com/mnot/I-D/pull/301",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-04-22T09:53:06Z",
      "updatedAt": "2019-05-03T01:27:05Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "2672c76f56e2481924ae2d179b86b2bc9d49837c",
      "headRepository": "PiotrSikora/mnot-drafts",
      "headRefName": "proxy_internal_response",
      "headRefOid": "ebdae37b2e779681acdd9916a345571900a785be",
      "closedAt": "2019-05-03T01:27:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moved to https://github.com/httpwg/http-extensions/pull/806.",
          "createdAt": "2019-05-03T01:27:05Z",
          "updatedAt": "2019-05-03T01:27:05Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzMTkyMDg3",
      "title": "Remove accidental sexist language",
      "url": "https://github.com/mnot/I-D/pull/303",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"Good sers and madams\" is an archaic form, worse for the omission of \"madams\".\r\n\r\nNo point in getting into debates about gender here, there is already enough heat involved.",
      "createdAt": "2019-07-01T06:10:16Z",
      "updatedAt": "2019-07-01T06:30:38Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "0b2668c96097cae21f1bc66fdeff7d0e9689a2ee",
      "headRepository": "martinthomson/I-D",
      "headRefName": "patch-4",
      "headRefOid": "5d66042b5ff7811643d685ac3ddad82c15e2e22c",
      "closedAt": "2019-07-01T06:30:38Z",
      "mergedAt": "2019-07-01T06:30:38Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "f80901bfdd42e1756b3494386075d6202f519c2f"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "how horrible of me; many thanks.",
          "createdAt": "2019-07-01T06:30:32Z",
          "updatedAt": "2019-07-01T06:30:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NTYyNTA3",
      "title": "just getting my fork in order...",
      "url": "https://github.com/mnot/I-D/pull/311",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "should be zero changed files...",
      "createdAt": "2019-11-11T18:34:11Z",
      "updatedAt": "2019-11-11T21:09:27Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "34e7134eb49766b1523e6f73ad5f7d38b66ca04c",
      "headRepository": "dret/I-D-1",
      "headRefName": "master",
      "headRefOid": "e6c2920c8d56be6b3d9fcb2bcd7eee8273b44121",
      "closedAt": "2019-11-11T21:09:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1MDgxODQ0",
      "title": "Fix unquoted JSON key in draft-nottingham-link-hint-03",
      "url": "https://github.com/mnot/I-D/pull/318",
      "state": "CLOSED",
      "author": "RubenVerborgh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Fixes a typo that yields invalid JSON.",
      "createdAt": "2020-05-29T12:44:47Z",
      "updatedAt": "2021-11-25T05:22:48Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "4f6c7175b46600b601a9ef965f8a728fe8b945ef",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "eaafe978156a3ff00ecfd6c2d7267ac0d2360e7f",
      "closedAt": "2021-11-25T05:22:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4NTM3NTc1",
      "title": "discussion-recharter nits",
      "url": "https://github.com/mnot/I-D/pull/321",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-17T01:59:03Z",
      "updatedAt": "2020-08-17T04:06:09Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "66aa584dbf613f395700e49e10d6a15449ede634",
      "headRepository": "martinthomson/I-D",
      "headRefName": "dr-edit",
      "headRefOid": "7ed5bf8b942c8d67459462404d54344a8713d12e",
      "closedAt": "2020-08-17T04:06:09Z",
      "mergedAt": "2020-08-17T04:06:09Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "0ebe00b38597b6dc48f9afb93faebd49b0996089"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0OTc5NDU1",
      "title": "Few minor tweaks",
      "url": "https://github.com/mnot/I-D/pull/323",
      "state": "MERGED",
      "author": "jasnell",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a couple copy edits, otherwise it looks good with a comment...\r\n\r\nIn the good case, where `trailer-update` is indicated in the header `Cache-Control` but no subsequent trailing `Cache-Control` is provided:\r\n\r\n```http-message\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\nCache-Control: max-age=3600, trailer-update\r\n\r\n[body]\r\n```\r\n\r\nIt says that \"Caches that do not implement this specification will cache it by the header policy; caches that do implement will see no updates in the trailer and do the same.\", but that means that the `trailer-update` directive does get stored and forwarded on by the cache (since it is never removed). I'm just wanting to make sure there's no unintended down stream consequence from that. We may want to explicitly state that the presence of a `trailer-update`  directive does not *mandate* that a `Cache-Control`  trailer is present.\r\n\r\nThe only other thing that I can think of is ... when a trailing `Cache-Control` directive is received and it contains an updated timestamp (max-stale, expires, etc) ... is there any impact on the origin time from which that is calculated. Let's take an extreme example: I start streaming a resource back from the server with a max-age of 30 seconds. 20 seconds later the resource is done streaming and I update the `Cache-Control` with a max-age of 10 seconds.... Is the resource already stale (age calculated from the time the resource started to be received) or is the age calculated from the time the `Cache-Control` was updated and the resource was committed to the cache? Or does that not even matter here.",
      "createdAt": "2021-03-04T17:18:50Z",
      "updatedAt": "2021-03-04T23:40:28Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "gh-pages",
      "baseRefOid": "adee5b476b34a89706a86852e08ad365aeae3a29",
      "headRepository": "jasnell/I-D",
      "headRefName": "patch-1",
      "headRefOid": "af7bef9b698d6fd76e96e55f13fb5794a37b96a0",
      "closedAt": "2021-03-04T23:03:05Z",
      "mergedAt": "2021-03-04T23:03:05Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "59ff1823281b548a524b3cc293b4fbf067738ada"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks.\r\n\r\nI agree re: stating that `trailer-update` does not mandate a trailer; will refine it along those lines.\r\n\r\nWRT the time delta - good point. HTTP is a bit fuzzy about this, effectively treating the entire response as atomic. I feel like a reasonable default is that if the trailer updates cache-control, the time the response is received should be considered to be that point, because that's closest to when the policy was actually generated. ",
          "createdAt": "2021-03-04T23:05:17Z",
          "updatedAt": "2021-03-04T23:05:17Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I feel like a reasonable default is that if the trailer updates cache-control, the time the response is received should be considered to be that point, because that's closest to when the policy was actually generated.\r\n\r\nAgreed.",
          "createdAt": "2021-03-04T23:15:15Z",
          "updatedAt": "2021-03-04T23:15:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Looking at [age calcluation](https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html#age.calculations), it's a little more subtle than that. I think we need to say that for the purposes of calculating `resident_time`, `response_time` should be considered to be the time the trailer was received; however, for the purposes of calculating `response_delay` for `corrected_age_value`, that would be counter-productive.",
          "createdAt": "2021-03-04T23:27:44Z",
          "updatedAt": "2021-03-04T23:27:44Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm yeah... That's what had me thinking, thank you for looking that up. I think the likely safest thing to do is to simply say that the trailing Cache-Control has no impact on the age calculation, and that even with an updated Cache-Control, the age is calculated the same as it would be without the trailer. It's the only way we're going to be able to make it consistent with non-implementing endpoints and keep things simple. ",
          "createdAt": "2021-03-04T23:40:28Z",
          "updatedAt": "2021-03-04T23:40:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 326,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk1ODM1Mjg1",
      "title": "Links are for navigating resources",
      "url": "https://github.com/mnot/I-D/pull/326",
      "state": "OPEN",
      "author": "ravage84",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Links are for navigating to resources, first and foremost. As in [URL, Uniform __Resource__ Locator]( https://en.wikipedia.org/wiki/URL).\r\nLikewise, mentioning (navigating between application) state(s) and thus hinting at HATEOAS does not seem to be very relevant here.",
      "createdAt": "2021-07-23T10:23:59Z",
      "updatedAt": "2021-07-23T10:23:59Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "36eb249738de092561d4ee254b88cb9ebc42c6e2",
      "headRepository": "ravage84/I-D",
      "headRefName": "patch-1",
      "headRefOid": "ffd38dd9706602c66cdadb1e8db409b63c05dcab",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 327,
      "id": "PR_kwDOAAx9P84s3WEY",
      "title": "Hoist headings up a level",
      "url": "https://github.com/mnot/I-D/pull/327",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "IANA considerations in the introduction is bold, but probably not what\r\nyou intended.\r\n\r\nI couldn't get your makefile working for a few reasons, so I haven't touched the extraneous stuff.",
      "createdAt": "2021-10-06T23:39:03Z",
      "updatedAt": "2021-10-06T23:42:43Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "a52f0bf43331ca6afcbbd2b2eb8915e55100aed4",
      "headRepository": "martinthomson/I-D",
      "headRefName": "uplevel",
      "headRefOid": "657edf196a30f7fb99821bf9b371d6d674cc452b",
      "closedAt": "2021-10-06T23:40:33Z",
      "mergedAt": "2021-10-06T23:40:33Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "7e817a2019e32a57303ed9743992f4eacac61614"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Duh - thanks.",
          "createdAt": "2021-10-06T23:40:29Z",
          "updatedAt": "2021-10-06T23:40:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 328,
      "id": "PR_kwDOAAx9P84u_tvE",
      "title": "Rearrange for mt's i-d-template",
      "url": "https://github.com/mnot/I-D/pull/328",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-25T02:43:04Z",
      "updatedAt": "2021-11-25T02:43:19Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "2cb8fab4eb45a6f71d2fbace10cf4d353add939b",
      "headRepository": "mnot/I-D",
      "headRefName": "mtify",
      "headRefOid": "197edb5e2e0446065b0768d682429b3bf9deb6e5",
      "closedAt": "2021-11-25T02:43:15Z",
      "mergedAt": "2021-11-25T02:43:15Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "54eb79d6e2ea01e23b056375b92fc7cd677992d9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 329,
      "id": "PR_kwDOAAx9P84xX0yX",
      "title": "Use \"serious conflict\" instead of \"genuine conflict\"",
      "url": "https://github.com/mnot/I-D/pull/329",
      "state": "MERGED",
      "author": "ghane",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "All conflicts are genuine, I assume.\r\n\r\nThe term used at the end of `Meeting Participants` is *serious conflicts*, and we are referred to the: `Scheduling Conflicts` section.",
      "createdAt": "2022-01-21T09:25:16Z",
      "updatedAt": "2022-01-24T21:37:41Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "eb15d11c1612f9f063db757cf3bdb650fcb3beae",
      "headRepository": "ghane/I-D",
      "headRefName": "patch-1",
      "headRefOid": "6bc2878ef1c1439229fd40f32b7ab01201570d51",
      "closedAt": "2022-01-24T21:37:35Z",
      "mergedAt": "2022-01-24T21:37:35Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "976335a71ed479bd7be4c2a321d33a821ee9f5d0"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Agreed - thanks!",
          "createdAt": "2022-01-24T21:37:41Z",
          "updatedAt": "2022-01-24T21:37:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 341,
      "id": "PR_kwDOAAx9P85TOQIi",
      "title": "Very minor edits to HTTP Cache Groups",
      "url": "https://github.com/mnot/I-D/pull/341",
      "state": "MERGED",
      "author": "sludin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-16T19:43:33Z",
      "updatedAt": "2023-06-17T06:19:27Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "0f8e10d303c90968ae1918fd453608cbc61434ff",
      "headRepository": "sludin/I-D",
      "headRefName": "main",
      "headRefOid": "416c94c88d89a0eb9e40c327bfe3994ce10b5abe",
      "closedAt": "2023-06-17T06:19:22Z",
      "mergedAt": "2023-06-17T06:19:22Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "f431fd4a9e140b94ce44e8c1641e88900e3e5396"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2023-06-17T06:19:27Z",
          "updatedAt": "2023-06-17T06:19:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 342,
      "id": "PR_kwDOAAx9P85ezELL",
      "title": "Add explanation of intent",
      "url": "https://github.com/mnot/I-D/pull/342",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-11-07T12:03:56Z",
      "updatedAt": "2023-11-11T04:09:08Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "d60e46ce4a42387c02acf1b6e454c783397d08aa",
      "headRepository": "mnot/I-D",
      "headRefName": "mnot-patch-1",
      "headRefOid": "39700a8f8b4c14edbea134c4c4721bc79d09339e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "It's 'anticipatory' (as in 'anticipation'), not 'antiparticipatory'.",
          "createdAt": "2023-11-09T09:11:21Z",
          "updatedAt": "2023-11-09T09:11:21Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I think simpler language will be better, but I'm not attached to a change here, if you like any part of these, feel free to use it:\n\n\nThese criteria are to support successful widely deployed community for formats.\n\nThese criteria are not designed to support registrations of emerging or anticipated future community formats.",
          "createdAt": "2023-11-11T04:09:08Z",
          "updatedAt": "2023-11-11T04:09:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOAAx9P85mX1RB",
          "commit": {
            "abbreviatedOid": "dc178fe"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-07T12:05:25Z",
          "updatedAt": "2023-11-07T12:05:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOAAx9P85mX1qN",
          "commit": {
            "abbreviatedOid": "dc178fe"
          },
          "author": "mnot",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-07T12:06:24Z",
          "updatedAt": "2023-11-07T12:06:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThe intent is to assure that successfully deployed community formats have registered media types. As such, the criteria are designed to preclude anticipatory registrations. The Designated Expert(s) have discretion in applying these criteria; in rare cases, they might judge it best to register an entry that fails one or more.\r\n```",
              "createdAt": "2023-11-07T12:06:25Z",
              "updatedAt": "2023-11-07T12:06:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOAAx9P85mpDgY",
          "commit": {
            "abbreviatedOid": "39700a8"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "\"preclude antiparticipatory\" is a double negative... a bit hard to understand.",
          "createdAt": "2023-11-09T09:04:37Z",
          "updatedAt": "2023-11-09T09:04:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 343,
      "id": "PR_kwDOAAx9P85oyMfH",
      "title": "Fix an indentation error on draft-nottingham-http-availability-hints.\u2026",
      "url": "https://github.com/mnot/I-D/pull/343",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026html#name-cookie algorithm\r\n\r\n",
      "createdAt": "2024-03-06T01:51:17Z",
      "updatedAt": "2024-03-06T04:28:53Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "cdd03956d2837e653793ef207d4183992c7dcbff",
      "headRepository": "nyaxt/mnot-I-D",
      "headRefName": "indent",
      "headRefOid": "4f015292f374c94f0af58fdf6251137748b0485d",
      "closedAt": "2024-03-06T04:26:36Z",
      "mergedAt": "2024-03-06T04:26:36Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "b3a1939095dafcef357c195477a3b7adc56014d5"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2024-03-06T04:28:51Z",
          "updatedAt": "2024-03-06T04:28:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 344,
      "id": "PR_kwDOAAx9P85qAntK",
      "title": "draft-nottingham-http-availability-hints: Adjust Cookie-Indices to use strings instead of tokens.",
      "url": "https://github.com/mnot/I-D/pull/344",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This:\r\n* is consistent with draft-ietf-httpbis-retrofit, which uses strings for cookie names,\r\n* allows cookie names which begin with underscores (which are common)\r\n* allows tokens to be used for future evolution",
      "createdAt": "2024-03-18T22:09:28Z",
      "updatedAt": "2024-03-19T00:01:42Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "b3a1939095dafcef357c195477a3b7adc56014d5",
      "headRepository": "jeremyroman/mnot-I-D",
      "headRefName": "cookie-indices-strings",
      "headRefOid": "30038deff82108094b0068963ec29e07c551bd9c",
      "closedAt": "2024-03-19T00:01:42Z",
      "mergedAt": "2024-03-19T00:01:42Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "0736f4b7198b3fdd5d5e1b300c11672547da734a"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Thanks!",
          "createdAt": "2024-03-19T00:01:39Z",
          "updatedAt": "2024-03-19T00:01:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 345,
      "id": "PR_kwDOAAx9P85qAobJ",
      "title": "draft-nottingham-http-availability-hints: Spell \"Cookie-Indices\" consistently.",
      "url": "https://github.com/mnot/I-D/pull/345",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change is purely editorial.",
      "createdAt": "2024-03-18T22:10:48Z",
      "updatedAt": "2024-03-19T00:03:08Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "0736f4b7198b3fdd5d5e1b300c11672547da734a",
      "headRepository": "jeremyroman/mnot-I-D",
      "headRefName": "cookie-indices-typo",
      "headRefOid": "f87443d38f15289060e867a2d4a3ebb6ddf53f96",
      "closedAt": "2024-03-19T00:03:08Z",
      "mergedAt": "2024-03-19T00:03:08Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "72babad9c3ca811544b18ef6d59ce982e91b47dd"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "OWNER",
          "body": "Doh - thanks!",
          "createdAt": "2024-03-19T00:03:03Z",
          "updatedAt": "2024-03-19T00:03:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 348,
      "id": "PR_kwDOAAx9P85xWDSM",
      "title": "draft-nottingham-http-availability-hints: Handle duplicate cookies in Cookie-Indices.",
      "url": "https://github.com/mnot/I-D/pull/348",
      "state": "MERGED",
      "author": "jeremyroman",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is possible for multiple cookies with the same name to be presented (e.g., cookies with the same name but a different Path attribute). In this case, compare sorted lists of the values.\r\n\r\nFixes #347.",
      "createdAt": "2024-06-03T20:19:50Z",
      "updatedAt": "2024-06-12T04:16:16Z",
      "baseRepository": "mnot/I-D",
      "baseRefName": "main",
      "baseRefOid": "9705dcd0d87d02fe60e6ca33715d8c37fc020959",
      "headRepository": "jeremyroman/mnot-I-D",
      "headRefName": "duplicate-cookies",
      "headRefOid": "f3364b37ce9eac60bcec42aaf12520eebede4a27",
      "closedAt": "2024-06-12T04:16:16Z",
      "mergedAt": "2024-06-12T04:16:16Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "524d0e5f6855ebd4d5fe34719f1518b1f50ccebb"
      },
      "comments": [],
      "reviews": []
    }
  ]
}