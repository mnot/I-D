<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "about:legacy-compat">
<html lang="en"><head profile="http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Key HTTP Response Header Field</title><link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      .nav-sublist {
        padding-left: 20px;
        padding-right: 10px;
        font-size: 90%;
      }
      .navbar-brand {
        padding-top: 0;
      }
      .container .nav > li > a {
        padding: 10px 7px 5px 15px;
        display: inline-block;
      }
      .container .nav > li > a + a {
        padding: 10px 15px 5px 7px;
        display: inline-block;
      }
      .nav > li > a {
        padding: 5px 10px;
      }
      .filename {
        text-align: center;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
    </style><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The “Key” Response Header Field" href="#rfc.section.2"><link rel="Chapter" title="3 IANA Considerations" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" href="#rfc.section.5" title="5 References"><link rel="Appendix" title="A Acknowledgements" href="#rfc.section.A"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Fielding, R."><meta name="dct.creator" content="Nottingham, M."><meta name="dct.identifier" content="urn:ietf:id:draft-fielding-http-key-04"><meta name="dct.issued" scheme="ISO8601" content="2015-09-24"><meta name="dct.abstract" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."><meta name="description" content="The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting."></head><body data-spy="scroll" data-target="#rfc.toc"><div class="container" id="top"><div class="row"><div class="col-md-4 col-md-push-8 hidden-sm hidden-xs" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top">Internet-Draft</a></div><br clear="all"><div class=""><div id="rfc.toc"><ul class="nav"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#examples">Examples</a></li><li><a href="#rfc.section.1.2">1.2</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#the-key-response-header-field">The “Key” Response Header Field</a><ul><li><a href="#rfc.section.2.1">2.1</a>&nbsp;&nbsp;&nbsp;<a href="#relationship-with-vary">Relationship with Vary</a></li><li><a href="#rfc.section.2.2">2.2</a>&nbsp;&nbsp;&nbsp;<a href="#calculating-a-secondary-cache-key">Calculating a Secondary Cache Key</a><ul><li><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#value">Creating a Header Field Value</a></li><li><a href="#rfc.section.2.2.2">2.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#fail-param">Failing Parameter Processing</a></li></ul></li><li><a href="#rfc.section.2.3">2.3</a>&nbsp;&nbsp;&nbsp;<a href="#key-parameters">Key Parameters</a><ul><li><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;&nbsp;&nbsp;<a href="#div">div</a></li><li><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;&nbsp;&nbsp;<a href="#partition">partition</a></li><li><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;&nbsp;&nbsp;<a href="#match">match</a></li><li><a href="#rfc.section.2.3.4">2.3.4</a>&nbsp;&nbsp;&nbsp;<a href="#substr">substr</a></li><li><a href="#rfc.section.2.3.5">2.3.5</a>&nbsp;&nbsp;&nbsp;<a href="#param">param</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#iana">IANA Considerations</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#procedure">Procedure</a></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#registrations">Registrations</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.5.1">5.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.5.2">5.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></div></div></div></div><div class="col-md-8 col-md-pull-4 main" role="main"><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="">Network Working Group</td><td class="text-right">R. Fielding</td></tr><tr><td class="">Internet-Draft</td><td class="text-right">Adobe Systems Incorporated</td></tr><tr><td class="">Intended status: Informational</td><td class="text-right">M. Nottingham</td></tr><tr><td class="">Expires: March 27, 2016</td><td class="text-right">September 24, 2015</td></tr></tbody></table><div id="rfc.title"><h1>The Key HTTP Response Header Field</h1><p class="filename">draft-fielding-http-key-04</p></div><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><p>The ‘Key’ header field for HTTP responses allows an origin server to describe the secondary cache key (<a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, section 4.1) for a resource, by conveying what is effectively a short algorithm that can be used upon later requests to determine if a stored response is reusable for a given request.</p><p>Key has the advantage of avoiding an additional round trip for validation whenever a new request differs slightly, but not significantly, from prior requests.</p><p>Key also informs user agents of the request characteristics that might result in different content, which can be useful if the user agent is not sending request header fields in order to reduce the risk of fingerprinting.</p></div><h2 id="rfc.note.1"><a href="#rfc.note.1">Note to Readers</a></h2><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/key">https://github.com/mnot/I-D/labels/key</a>.</p><div id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p><p>This Internet-Draft will expire on March 27, 2016.</p></div><div id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright © 2015 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div><div id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>In HTTP caching <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, the Vary response header field effectively modifies the key used to store and access a response to include information from the request’s headers. This “secondary cache key” allows proactive content negotiation <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a> to work with caches.</p></div><div id="rfc.section.1.p.2"><p>Vary’s operation is generic; it works well when caches understand the semantics of the selecting headers. For example, the Accept-Language request header field has a well-defined syntax for expressing the client’s preferences; a cache that understands this header field can select the appropriate response (based upon its Content-Language header field) and serve it to a client, without any knowledge of the underlying resource.</p></div><div id="rfc.section.1.p.3"><p>Vary does not work as well when the criteria for selecting a response are specific to the resource. For example, if the nature of the response depends upon the presence or absence of a particular Cookie (<a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a>) in a request, Vary doesn’t have a mechanism to offer enough fine-grained, resource-specific information to aid a cache’s selection of the appropriate response.</p></div><div id="rfc.section.1.p.4"><p>This document defines a new response header field, “Key”, that allows resources to describe the secondary cache key in a fine-grained, resource-specific manner, leading to improved cache efficiency when responses depend upon such headers.</p></div><div id="examples"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#examples">Examples</a></h3><div id="rfc.section.1.1.p.1" class="avoidbreakafter"><p>For example, this response header field:</p></div><div id="rfc.figure.u.1"><pre>
  Key: cookie;param=_sess;param=ID
</pre></div><div id="rfc.section.1.1.p.2"><p>indicates that the selected response depends upon the “_sess” and “ID” cookie values.</p></div><div id="rfc.section.1.1.p.3" class="avoidbreakafter"><p>This Key:</p></div><div id="rfc.figure.u.2"><pre>
  Key: user-agent;substr=MSIE
</pre></div><div id="rfc.section.1.1.p.4"><p>indicates that there are two possible secondary cache keys for this resource; one for requests whose User-Agent header field contains “MSIE”, and another for those that don’t.</p></div><div id="rfc.section.1.1.p.5" class="avoidbreakafter"><p>A more complex example:</p></div><div id="rfc.figure.u.3"><pre>
  Key: user-agent;substr=MSIE;Substr="mobile", Cookie;param="ID"
</pre></div><div id="rfc.section.1.1.p.6"><p>indicates that the selected response depends on the presence of two strings in the User-Agent request header field, as well as the value of the “ID” cookie request header field.</p></div></div><div id="notational-conventions"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.2.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p></div><div id="rfc.section.1.2.p.2"><p>This document uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a> (including the DQUOTE rule), and the list rule extension defined in <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7. It includes by reference the field-name, quoted-string and quoted-pair rules from that document, and the parameter rule from <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>.</p></div></div></div><div id="the-key-response-header-field"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#the-key-response-header-field">The “Key” Response Header Field</a></h2><div id="rfc.section.2.p.1"><p>The “Key” response header field describes the portions of the request that the resource currently uses to select representations.</p></div><div id="rfc.section.2.p.2"><p>As such, its semantics are similar to the “Vary” response header field, but it allows more fine-grained description, using “key parameters”.</p></div><div id="rfc.section.2.p.3"><p>Caches can use this information as part of determining whether a stored response can be used to satisfy a given request. When a cache knows and fully understands the Key header field for a given resource, it MAY ignore the Vary response header field in any stored responses for it.</p></div><div id="rfc.section.2.p.4"><p>Additionally, user agents can use Key to discover if additional request header fields might influence the resource’s selection of responses.</p></div><div id="rfc.section.2.p.5"><p>The Key field-value is a comma-delimited list of selecting header fields (similar to Vary), with zero to many parameters each, delimited by semicolons. Whitespace is not allowed in the field-value between each field-name and its parameter set.</p></div><div id="rfc.figure.u.4"><pre>
  Key = 1#field-name *( ";" parameter )
</pre></div><div id="rfc.section.2.p.6"><p>Note that, as per <a href="#RFC7231"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content">[RFC7231]</cite></a>, parameter names are case-insensitive, and parameter values can be double-quoted strings (potentially with “"-escaped characters inside).</p></div><div id="rfc.section.2.p.7" class="avoidbreakafter"><p>The following header fields have the same effect:</p></div><div id="rfc.figure.u.5"><pre>
  Vary: Accept-Encoding, Cookie
  Key: Accept-Encoding, Cookie
</pre></div><div id="rfc.section.2.p.8" class="avoidbreakafter"><p>However, Key’s use of parameters allows:</p></div><div id="rfc.figure.u.6"><pre>
  Key: Accept-Encoding, Cookie;param=foo
</pre></div><div id="rfc.section.2.p.9"><p>to indicate that the secondary cache key depends upon the Accept-Encoding header field and the “foo” Cookie.</p></div><div id="rfc.section.2.p.10"><p>One important difference between Vary and Key is how they are applied. Vary is specified to be specific to the response it occurs within, whereas Key is specific to the resource (as identified by the request URL) it is associated with. The most recent key you receive for a given resource is applicable to all responses from that resource.</p></div><div id="rfc.section.2.p.11"><p>This difference allows more efficient implementation (and reflects practices that many caches use in implementing Vary already).</p></div><div id="rfc.section.2.p.12"><p>This specification defines a selection of Key parameters to address common use cases such as selection upon individual Cookie header fields, User-Agent substrings and numerical ranges. Future parameters may define further capabilities.</p></div><div id="relationship-with-vary"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a href="#relationship-with-vary">Relationship with Vary</a></h3><div id="rfc.section.2.1.p.1"><p>Origin servers SHOULD still send Vary when using Key, to ensure backwards compatibility.</p></div><div id="rfc.section.2.1.p.2"><p>For example,</p></div><div id="rfc.figure.u.7"><pre>
  Vary: User-Agent
  Key: User-Agent;substr="mozilla"
</pre></div><div id="rfc.section.2.1.p.3"><p>Note that, in some cases, it may be better to explicitly use “Vary: *” if clients and caches don’t have any practical way to use the Vary header field’s value. For example,</p></div><div id="rfc.figure.u.8"><pre>
  Vary: *
  Key: Cookie;param="ID"
</pre></div><div id="rfc.section.2.1.p.4"><p>Except when Vary: * is used, the set of headers used in Key SHOULD reflect the same request header fields as Vary does, even if they don’t have parameters. For example,</p></div><div id="rfc.figure.u.9"><pre>
  Vary: Accept-Encoding, User-Agent
  Key: Accept-Encoding, User-Agent;substr="mozilla"
</pre></div><div id="rfc.section.2.1.p.5"><p>Here, Accept-Encoding is included in Key without parameters; caches MAY treat these as they do values in the Vary header, relying upon knowledge of their generic semantics to select an appropriate response.</p></div></div><div id="calculating-a-secondary-cache-key"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a href="#calculating-a-secondary-cache-key">Calculating a Secondary Cache Key</a></h3><div id="rfc.section.2.2.p.1"><p>When used by a cache to determine whether a stored response can be used to satisfy a presented request, each field-name in Key identifies a potential request header, just as with the Vary response header field.</p></div><div id="rfc.section.2.2.p.2"><p>However, each of these can have zero to many key parameters that change how the response selection process (as defined in <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.3)) works.</p></div><div id="rfc.section.2.2.p.3"><p>In particular, when a cache fully implements this specification, it creates a secondary cache key for every request by following the instructions in the Key header field, ignoring the Vary header for this purpose.</p></div><div id="rfc.section.2.2.p.4"><p>Then, when a new request is presented, the secondary cache key generated for that request can be compared to the stored one to find the appropriate response, to determine if it can be selected.</p></div><div id="rfc.section.2.2.p.5" class="avoidbreakafter"><p>To generate a secondary cache key for a given request (including that which is stored with a response) using Key, the following steps are taken:</p></div><div id="rfc.section.2.2.p.6"><dl><dt>1)</dt><dd>If the Key header field is not present on the most recent cacheable (as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 3)) response seen for the resource, abort this algorithm (i.e., fall back to using Vary to determine the secondary cache key).</dd><dt>2)</dt><dd>Let <tt>key_value</tt> be the most recently seen Key header field value for the resource, as the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>).</dd><dt>3)</dt><dd>Let <tt>secondary_key</tt> be an empty string.</dd><dt>4)</dt><dd>Create <tt>key_list</tt> by splitting <tt>key_value</tt> on “,” characters.</dd><dt>5)</dt><dd>For <tt>key_item</tt> in <tt>key_list</tt>: <dl><dt>6)</dt><dd>Remove any leading and trailing WSP from <tt>key_item</tt>.</dd><dt>7)</dt><dd>If <tt>key_item</tt> does not contain a “;” character, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <tt>key_item</tt>.</dd><dt>8)</dt><dd>Let <tt>field_name</tt> be the string before the first “;” character in <tt>key_item</tt>.</dd><dt>9)</dt><dd>Let <tt>field_value</tt> be the result of Creating a Header Field Value (<a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>) with <tt>field_name</tt> as the <tt>target_field_name</tt> and the request header list as <tt>header_list</tt>.</dd><dt>10)</dt><dd>Let <tt>parameters</tt> be the string after the first “;” character in <tt>key_item</tt>.</dd><dt>11)</dt><dd>Create <tt>param_list</tt> by splitting <tt>parameters</tt> on “;” characters, excepting “;” characters within quoted strings, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> Section 3.2.6.</dd><dt>12)</dt><dd>For <tt>parameter</tt> in <tt>param_list</tt>: <dl><dt>13)</dt><dd>If <tt>parameter</tt> does not contain a “=”, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <tt>key_item</tt>.</dd><dt>14)</dt><dd>Let <tt>param_name</tt> be the string before the first “=” character in <tt>parameter</tt>, case-normalized to lowercase.</dd><dt>15)</dt><dd>If <tt>param_name</tt> does not identify a Key parameter processing algorithm that is implemented, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>) and skip to the next <tt>key_item</tt>.</dd><dt>16)</dt><dd>Let <tt>param_value</tt> be the string after the first “=” character in <tt>parameter</tt>.</dd><dt>17)</dt><dd>If the first and last characters of <tt>param_value</tt> are both DQUOTE: <dl><dt>18)</dt><dd>Remove the first and last characters of <tt>param_value</tt>.</dd><dt>19)</dt><dd>Replace quoted-pairs within <tt>param_value</tt> with the octet following the backslash, as per <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a> Section 3.2.6.</dd></dl></dd><dt>20)</dt><dd>If <tt>param_value</tt> does not conform to the syntax defined for it by the parameter definition, fail parameter processing <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a> and skip to the next <tt>key_item</tt>.</dd><dt>21)</dt><dd>Run the identified processing algorithm on <tt>field_value</tt> with the <tt>param_value</tt>, and append the result to <tt>secondary_key</tt>. If parameter processing fails <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>, skip to the next <tt>key_item</tt>.</dd><dt>22)</dt><dd>Append a separator character (e.g., NULL) to <tt>secondary_key</tt>.</dd></dl></dd></dl></dd><dt>23)</dt><dd>Return <tt>secondary_key</tt>.</dd></dl></div><div id="rfc.section.2.2.p.7"><p>Note that this specification does not require that exact algorithm to be implemented. However, implementations’ observable behavior MUST be identical to running it. This includes parameter processing algorithms; implementations MAY use different internal artefacts for secondary cache keys, as long as the results are the same.</p></div><div id="rfc.section.2.2.p.8" class="avoidbreakafter"><p>Likewise, while the secondary cache key associated with both stored and presented requests is required to use the most recently seen Key header field for the resource in question, this can be achieved using a variety of implementation strategies, including (but not limited to):</p></div><div id="rfc.section.2.2.p.9"><ul><li>Generating a new secondary cache key for every stored response associated with the resource upon each request.</li><li>Caching the secondary cache key with the stored request/response pair and re-generating it when the Key header field is observed to change.</li><li>Caching the secondary cache key with the stored response and invalidating the stored response(s) when the Key header field is observed to change.</li></ul></div><div id="value"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1</a>&nbsp;<a href="#value">Creating a Header Field Value</a></h4><div id="rfc.section.2.2.1.p.1" class="avoidbreakafter"><p>Given a header field name <tt>target_field_name</tt> and <tt>header_list</tt>, a list of (<tt>field_name</tt>, <tt>field_value</tt>) tuples:</p></div><div id="rfc.section.2.2.1.p.2"><dl><dt>24)</dt><dd>Let <tt>target_field_values</tt> be an empty list.</dd><dt>25)</dt><dd>For each (<tt>field_name</tt>, <tt>field_value</tt>) tuple in <tt>header_list</tt>: <dl><dt>26)</dt><dd>If <tt>field_name</tt> does not match <tt>target_field_name</tt>, skip to the next tuple.</dd><dt>27)</dt><dd>Strip leading and trailing WSP from <tt>field_value</tt> and append it to <tt>target_field_values</tt>.</dd></dl></dd><dt>28)</dt><dd>If <tt>target_field_values</tt> is empty, return an empty string.</dd><dt>29)</dt><dd>Return the concatenation of <tt>target_field_values</tt>, separating each with “,” characters.</dd></dl></div></div><div id="fail-param"><h4 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2</a>&nbsp;<a href="#fail-param">Failing Parameter Processing</a></h4><div id="rfc.section.2.2.2.p.1"><p>In some cases, a key parameter cannot determine a secondary cache key corresponding to its nominated header field value. When this happens, Key processing needs to fail safely, so that the correct behavior is observed.</p></div><div id="rfc.section.2.2.2.p.2"><p>When this happens, implementations MUST either behave as if the Key header was not present, or assure that the nominated header fields being compared match, as per <a href="#RFC7234"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Caching">[RFC7234]</cite></a>, Section 4.1.</p></div></div></div><div id="key-parameters"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3</a>&nbsp;<a href="#key-parameters">Key Parameters</a></h3><div id="rfc.section.2.3.p.1"><p>A Key parameter associates a name with a specific processing algorithm that takes two inputs; a HTTP header value “header_value” (as described in <a href="#value" title="Creating a Header Field Value">Section&nbsp;2.2.1</a>), and “parameter_value”, a string that indicates how the identified header should be processed.</p></div><div id="rfc.section.2.3.p.2" class="avoidbreakafter"><p>The set of key parameters (and their associated processing algorithms) is extensible; see <a href="#iana" title="IANA Considerations">Section&nbsp;3</a>. This document defines the following key parameters:</p></div><div id="div"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1</a>&nbsp;<a href="#div">div</a></h4><div id="rfc.section.2.3.1.p.1"><p>The “div” parameter normalizes positive integer header values into groups by dividing them by a configured value.</p></div><div id="rfc.section.2.3.1.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.10"><pre>
div    = 1*DIGIT
</pre></div><div id="rfc.section.2.3.1.p.3" class="avoidbreakafter"><p>To process a set of header fields against a div parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.1.p.4"><dl><dt>30)</dt><dd>If <tt>parameter_value</tt> is “0”, fail parameter processing <a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>.</dd><dt>31)</dt><dd>If <tt>header_value</tt> is the empty string, return “none”.</dd><dt>32)</dt><dd>If <tt>header_value</tt> contains a “,”, remove it and all subsequent characters.</dd><dt>33)</dt><dd>Remove all WSP characters from <tt>header_value</tt>.</dd><dt>34)</dt><dd>If <tt>header_value</tt> does not match the div ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</dd><dt>35)</dt><dd>Return the quotient of <tt>header_value</tt> / <tt>parameter_value</tt> (omitting the modulus).</dd></dl></div><div id="rfc.section.2.3.1.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.11"><pre>
Key: Bar;div=5
</pre></div><div id="rfc.section.2.3.1.p.6" class="avoidbreakafter"><p>indicates that the “Bar” header’s field value should be partitioned into groups of 5. Thus, the following field values would be considered the same (because, divided by 5, they all result in 1):</p></div><div id="rfc.figure.u.12"><pre>
Bar: 1
Bar: 3 , 42
Bar: 4, 1
</pre></div><div id="rfc.section.2.3.1.p.7"><p>whereas these would be considered to be in a different group (because, divided by 5, they all result in 2);</p></div><div id="rfc.figure.u.13"><pre>
Bar: 12
Bar: 10
Bar: 14, 1
</pre></div></div><div id="partition"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2</a>&nbsp;<a href="#partition">partition</a></h4><div id="rfc.section.2.3.2.p.1"><p>The “partition” parameter normalizes positive numeric header values into pre-defined segments.</p></div><div id="rfc.section.2.3.2.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.14"><pre>
partition = [ segment ] *( ":" [ segment ] )
segment   = [ 0*DIGIT "." ] 1*DIGIT
</pre></div><div id="rfc.section.2.3.2.p.3" class="avoidbreakafter"><p>To process a set of header fields against a partition parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.2.p.4"><dl><dt>36)</dt><dd>If <tt>header_value</tt> is the empty string, return “none”.</dd><dt>37)</dt><dd>If <tt>header_value</tt> contains a “,”, remove it and all subsequent characters.</dd><dt>38)</dt><dd>Remove all WSP characters from <tt>header_value</tt>.</dd><dt>39)</dt><dd>If <tt>header_value</tt> does not match the segment ABNF rule, fail parameter processing (<a href="#fail-param" title="Failing Parameter Processing">Section&nbsp;2.2.2</a>).</dd><dt>40)</dt><dd>Let <tt>segment_id</tt> be 0.</dd><dt>41)</dt><dd>Create a list <tt>segment_list</tt> by splitting <tt>parameter_value</tt> on “:” characters.</dd><dt>42)</dt><dd>For each <tt>segment_value</tt> in <tt>segment_list</tt>: <dl><dt>43)</dt><dd>If <tt>header_value</tt> is less than <tt>segment_value</tt> when they are numerically compared, skip to step 7.</dd><dt>44)</dt><dd>Increment <tt>segment_id</tt> by 1.</dd></dl></dd><dt>45)</dt><dd>Return <tt>segment_id</tt>.</dd></dl></div><div id="rfc.section.2.3.2.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.15"><pre>
Key: Foo;partition=20:30:40
</pre></div><div id="rfc.section.2.3.2.p.6" class="avoidbreakafter"><p>indicates that the “Foo” header’s field value should be divided into four segments:</p></div><div id="rfc.section.2.3.2.p.7"><ul><li>less than 20</li><li>20 to less than 30</li><li>30 to less than 40</li><li>forty or greater</li></ul></div><div id="rfc.section.2.3.2.p.8" class="avoidbreakafter"><p>Thus, the following headers would all be normalized to the first segment:</p></div><div id="rfc.figure.u.16"><pre>
Foo: 1
Foo: 0
Foo: 4, 54
Foo: 19.9
</pre></div><div id="rfc.section.2.3.2.p.9" class="avoidbreakafter"><p>whereas the following would fall into the second segment:</p></div><div id="rfc.figure.u.17"><pre>
Foo: 20
Foo: 29.999
Foo:  24   , 10
</pre></div></div><div id="match"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3</a>&nbsp;<a href="#match">match</a></h4><div id="rfc.section.2.3.3.p.1"><p>The “match” parameter is used to determine if an exact value occurs in a list of header values. It is case-sensitive.</p></div><div id="rfc.section.2.3.3.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.18"><pre>
match  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.3.p.3" class="avoidbreakafter"><p>To process a set of header fields against a match parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.3.p.4"><dl><dt>46)</dt><dd>If <tt>header_value</tt> is the empty string, return “none”.</dd><dt>47)</dt><dd>Create <tt>header_list</tt> by splitting <tt>header_value</tt> on “,” characters.</dd><dt>48)</dt><dd>For each <tt>header_item</tt> in <tt>header_list</tt>: <dl><dt>49)</dt><dd>Remove leading and trailing WSP characters in <tt>header_item</tt>.</dd><dt>50)</dt><dd>If the value of <tt>header_item</tt> is character-for-character identical to <tt>parameter_value</tt>, return “1”.</dd></dl></dd><dt>51)</dt><dd>Return “0”.</dd></dl></div><div id="rfc.section.2.3.3.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.19"><pre>
Key: Baz;match="charlie"
</pre></div><div id="rfc.section.2.3.3.p.6" class="avoidbreakafter"><p>Would return “1” for the following header field values:</p></div><div id="rfc.figure.u.20"><pre>
Baz: charlie
Baz: foo, charlie
Baz: bar, charlie     , abc
</pre></div><div id="rfc.section.2.3.3.p.7" class="avoidbreakafter"><p>and “0” for these:</p></div><div id="rfc.figure.u.21"><pre>
Baz: theodore
Baz: joe, sam
Baz: "charlie"
Baz: Charlie
Baz: cha rlie
Baz: charlie2
</pre></div></div><div id="substr"><h4 id="rfc.section.2.3.4"><a href="#rfc.section.2.3.4">2.3.4</a>&nbsp;<a href="#substr">substr</a></h4><div id="rfc.section.2.3.4.p.1"><p>The “substr” parameter is used to determine if a value occurs as a substring of an item in a list of header values. It is case-sensitive.</p></div><div id="rfc.section.2.3.4.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.22"><pre>
substr  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.4.p.3" class="avoidbreakafter"><p>To process a set of header fields against a substr parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.4.p.4"><dl><dt>52)</dt><dd>If <tt>header_value</tt> is the empty string, return “none”.</dd><dt>53)</dt><dd>Create <tt>header_list</tt> by splitting <tt>header_value</tt> on “,” characters.</dd><dt>54)</dt><dd>For each <tt>header_item</tt> in <tt>header_list</tt>: <dl><dt>55)</dt><dd>Remove leading and trailing WSP characters in <tt>header_item</tt>.</dd><dt>56)</dt><dd>If the value of <tt>parameter_value</tt> is character-for-character present as a substring of <tt>header_value</tt>, return “1”.</dd></dl></dd><dt>57)</dt><dd>Return “0”.</dd></dl></div><div id="rfc.section.2.3.4.p.5" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.23"><pre>
Key: Abc;substr=bennet
</pre></div><div id="rfc.section.2.3.4.p.6" class="avoidbreakafter"><p>Would return “1” for the following header field values:</p></div><div id="rfc.figure.u.24"><pre>
Abc: bennet
Abc: foo, bennet
Abc: abennet00
Abc: bar, 99bennet     , abc
Abc: "bennet"
</pre></div><div id="rfc.section.2.3.4.p.7" class="avoidbreakafter"><p>and “0” for these:</p></div><div id="rfc.figure.u.25"><pre>
Abc: theodore
Abc: joe, sam
Abc: Bennet
Abc: Ben net
</pre></div></div><div id="param"><h4 id="rfc.section.2.3.5"><a href="#rfc.section.2.3.5">2.3.5</a>&nbsp;<a href="#param">param</a></h4><div id="rfc.section.2.3.5.p.1"><p>The “param” parameter considers the request header field as a list of key=value parameters, and uses the nominated key’s value as the secondary cache key.</p></div><div id="rfc.section.2.3.5.p.2" class="avoidbreakafter"><p>Its value’s syntax is:</p></div><div id="rfc.figure.u.26"><pre>
param  = ( token / quoted-string )
</pre></div><div id="rfc.section.2.3.5.p.3" class="avoidbreakafter"><p>To process a list of header fields against a param parameter, follow these steps (or their equivalent):</p></div><div id="rfc.section.2.3.5.p.4"><dl><dt>58)</dt><dd>Let <tt>header_list</tt> be an empty list.</dd><dt>59)</dt><dd>Create <tt>header_list_tmp1</tt> by splitting header_value on “,” characters.</dd><dt>60)</dt><dd>For each <tt>header_item_tmp1</tt> in <tt>header_list_tmp1</tt>: <dl><dt>61)</dt><dd>Create <tt>header_list_tmp2</tt> by splitting <tt>header_item_tmp1</tt> on “;” characters.</dd><dt>62)</dt><dd>For each <tt>header_item_tmp2</tt> in <tt>header_list_tmp2</tt>: <dl><dt>63)</dt><dd>Remove leading and trailing WSP from <tt>header_item_tmp2</tt>.</dd><dt>64)</dt><dd>Append <tt>header_item_tmp2</tt> to header_list.</dd></dl></dd></dl></dd><dt>65)</dt><dd>For each <tt>header_item</tt> in <tt>header_list</tt>: <dl><dt>66)</dt><dd>If the “=” character does not occur within <tt>header_item</tt>, skip to the next <tt>header_item</tt>.</dd><dt>67)</dt><dd>Let <tt>item_name</tt> be the string occurring before the first “=” character in <tt>header_item</tt>.</dd><dt>68)</dt><dd>If <tt>item_name</tt> does not case-insensitively match <tt>parameter_value</tt>, skip to the next <tt>header_item</tt>.</dd><dt>69)</dt><dd>Return the string occurring after the first “=” character in <tt>header_item</tt>.</dd></dl></dd><dt>70)</dt><dd>Return the empty string.</dd></dl></div><div id="rfc.section.2.3.5.p.5"><p>Note that steps 2 and 3 accommodate semicolon-separated values, so that it can be used with the Cookie request header field.</p></div><div id="rfc.section.2.3.5.p.6" class="avoidbreakafter"><p>For example, the Key:</p></div><div id="rfc.figure.u.27"><pre>
Key: Def;param=liam
</pre></div><div id="rfc.section.2.3.5.p.7" class="avoidbreakafter"><p>The following headers would return the string (surrounded in single quotes) indicated:</p></div><div id="rfc.figure.u.28"><pre>
Def: liam=123           // '123'
Def: mno=456            // ''
Def:                    // ''
Def: abc=123; liam=890  // '890'
Def: liam="678"         // '"678"'
</pre></div></div></div></div><div id="iana"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#iana">IANA Considerations</a></h2><div id="rfc.section.3.p.1"><p>This specification defines the HTTP Key Parameter Registry, maintained at <a href="http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key">http://www.iana.org/assignments/http-parameters/http-parameters.xhtml#key</a>.</p></div><div id="procedure"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#procedure">Procedure</a></h3><div id="rfc.section.3.1.p.1" class="avoidbreakafter"><p>Key Parameter registrations MUST include the following fields:</p></div><div id="rfc.section.3.1.p.2"><ul><li>Parameter Name: [name]</li><li>Reference: [Pointer to specification text]</li></ul></div><div id="rfc.section.3.1.p.3"><p>Values to be added to this namespace require IETF Review (see Section 4.1 of [RFC5226]) and MUST conform to the purpose of content coding defined in this section.</p></div></div><div id="registrations"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#registrations">Registrations</a></h3><div id="rfc.section.3.2.p.1" class="avoidbreakafter"><p>This specification makes the following entries in the HTTP Key Parameter Registry:</p></div><div id="rfc.table.u.1"><table class="table full text-center" cellpadding="3" cellspacing="0"><thead><tr><th class="left">Parameter Name</th><th class="left">Reference</th></tr></thead><tbody><tr><td class="left">div</td><td class="left"><a href="#div" title="div">Section&nbsp;2.3.1</a></td></tr><tr><td class="left">partition</td><td class="left"><a href="#partition" title="partition">Section&nbsp;2.3.2</a></td></tr><tr><td class="left">match</td><td class="left"><a href="#match" title="match">Section&nbsp;2.3.3</a></td></tr><tr><td class="left">substr</td><td class="left"><a href="#substr" title="substr">Section&nbsp;2.3.4</a></td></tr><tr><td class="left">param</td><td class="left"><a href="#param" title="param">Section&nbsp;2.3.5</a></td></tr></tbody></table></div></div></div><div id="security-considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.4.p.1"><p>Because Key is an alternative to Vary, it is possible for caches to behave differently based upon whether they implement Key. Likewise, because support for any one Key parameter is not required, it is possible for different implementations of Key to behave differently. In both cases, an attacker might be able to exploit these differences.</p></div><div id="rfc.section.4.p.2"><p>This risk is mitigated by the requirement to fall back to Vary when unsupported parameters are encountered, coupled with the requirement that servers that use Key also include a relevant Vary header.</p></div><div id="rfc.section.4.p.3"><p>An attacker with the ability to inject response headers might be able to perform a cache poisoning attack that tailors a response to a specific user (e.g., by Keying to a Cookie that’s specific to them). While the attack is still possible without Key, the ability to tailor is new.</p></div><div id="rfc.section.4.p.4"><p>When implemented, Key might result in a larger number of stored responses for a given resource in caches; this, in turn, might be used to create an attack upon the cache itself. Good cache replacement algorithms and denial of service monitoring in cache implementations are reasonable mitigations against this risk.</p></div></div><h2 id="rfc.references"><a id="rfc.section.5" href="#rfc.section.5">5.</a> References</h2><h3 id="rfc.references.1"><a href="#rfc.section.5.1" id="rfc.section.5.1">5.1</a> Normative References</h3><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top">Bradner, S., “<a href="http://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC5234">[RFC5234]</b></td><td class="top">Crocker, D., Ed. and P. Overell, “<a href="http://www.rfc-editor.org/info/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>”, STD&nbsp;68, RFC&nbsp;5234, <a href="http://dx.doi.org/10.17487/RFC5234">DOI&nbsp;10.17487/RFC5234</a>, January&nbsp;2008, &lt;<a href="http://www.rfc-editor.org/info/rfc5234">http://www.rfc-editor.org/info/rfc5234</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7230">[RFC7230]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7230">http://www.rfc-editor.org/info/rfc7230</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7231">[RFC7231]</b></td><td class="top">Fielding, R., Ed. and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>”, RFC&nbsp;7231, <a href="http://dx.doi.org/10.17487/RFC7231">DOI&nbsp;10.17487/RFC7231</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7231">http://www.rfc-editor.org/info/rfc7231</a>&gt;.</td></tr><tr><td class="reference"><b id="RFC7234">[RFC7234]</b></td><td class="top">Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., “<a href="http://www.rfc-editor.org/info/rfc7234">Hypertext Transfer Protocol (HTTP/1.1): Caching</a>”, RFC&nbsp;7234, <a href="http://dx.doi.org/10.17487/RFC7234">DOI&nbsp;10.17487/RFC7234</a>, June&nbsp;2014, &lt;<a href="http://www.rfc-editor.org/info/rfc7234">http://www.rfc-editor.org/info/rfc7234</a>&gt;.</td></tr></table><h3 id="rfc.references.2"><a href="#rfc.section.5.2" id="rfc.section.5.2">5.2</a> Informative References</h3><table><tr><td class="reference"><b id="RFC6265">[RFC6265]</b></td><td class="top">Barth, A., “<a href="http://www.rfc-editor.org/info/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="http://www.rfc-editor.org/info/rfc6265">http://www.rfc-editor.org/info/rfc6265</a>&gt;.</td></tr></table><div id="acknowledgements"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.A.p.1"><p>Thanks to Ilya Grigorik, Amos Jeffries and Yoav Weiss for their feedback.</p></div></div><div class="avoidbreakinside"><h2 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h2><p><b>Roy T. Fielding</b><br>Adobe Systems Incorporated<br>EMail: <a href="mailto:fielding@gbiv.com">fielding@gbiv.com</a><br>URI: <a href="http://roy.gbiv.com/">http://roy.gbiv.com/</a></p><p><b>Mark Nottingham</b><br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="http://www.mnot.net/">http://www.mnot.net/</a></p></div></div></div></div><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script><script type="text/javascript">
          /* This is a workaround for https://github.com/twbs/bootstrap/issues/14285 */
          $('.nav a').on('click', function(a) {$(a.target.dataset.target.replace( /(:|\.|\[|\])/g, "\\$1" )).collapse('toggle')})
        </script></body></html>