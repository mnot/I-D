<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfc2629xslt/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-pushopedia-00" category="info">

  <front>
    <title abbrev="HTTP/2 Pushing">Defining HTTP/2 Server Push More Carefully</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization></organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date year="2016"/>

    <area>General</area>
    
    <keyword>push</keyword>

    <abstract>


<t>This document explores the use and implementation of HTTP/2 Server Push, in order to forumlate
recommendations about use and implementation.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP/2 <xref target="RFC7540"/> defines Server Push as a mechanism for servers to “push” request/response pairs
to clients.</t>

<t>The initial use case for Server Push is saving a round trip of latency when additional content is
referenced. For example, when a HTML page references CSS and JavaScript resources, the browser
needs to receive the HTML response before it can fetch those resources. Server Push allows the
server to proactively send them, in anticipation of the browser’s imminent need.</t>

<t>Server Push is now supported by most Web browsers, and sites are starting to experiment with it. In
doing so, it’s become apparent that client handling of server push is not well-defined, leading to
divergence in browser behaviour.</t>

<t>Furthermore, it appears that some deployments tend to treat Server Push like a “magic bullet”,
pushing far more data that could usefully fill the idle time on the connection.</t>

<t>To improve this, this document explores how Server Push interacts with various HTTP features, with
recommendations both for using Server Push in servers, and handling it by clients.</t>

<t>It’s not so much of a specification, for now, as it is a collection of ideas about how Server Push
<spanx style="strong">ought</spanx> to work.</t>

<t>It also does not address other use cases for Server Push, such as store-and-forward or
publish-and-subscribe.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in
<xref target="RFC2119"/>.</t>

</section>
</section>
<section anchor="server-push-and-http-semantics" title="Server Push and HTTP Semantics">

<section anchor="method" title="HTTP Methods">

<t><xref target="RFC7540"/>, Section 8.2 requires that promised requests be cacheable, safe, and not have a request
body.</t>

<t>In practice, this means that GET and HEAD can be pushed. A few other methods are cacheable and
safe, but since a request body is prohibited (both by the HTTP/2 spec and wire format), it’s not
practical to use them.</t>

<t>GET operates as we’d expect; it makes a representation available as if it had been previously
requested and cached, roughly.</t>

<t>In theory, HEAD should operate in a similar fashion; it would be as if the client had performed a
HEAD and used the pushed response to update the cache, as per <xref target="RFC7234"/>, Section 4.3.5
(“Freshening Responses via HEAD”). This might be useful, for example, to update the metadata of
that response. However, the same effect can also be achieved by using a conditional request; see
<xref target="conditional"/>.</t>

<t>Of other status codes, perhaps the most interesting would be OPTIONS, because of its use by CORS
(<xref target="WHATWG.fetch"/>). See <xref target="cors"/>.</t>

</section>
<section anchor="status" title="HTTP Status Codes">

<t>In principle, any HTTP status code can be pushed in a response. Success (2xx), redirection (300,
301, 302, 303, 307, 308) and eror (4xx and 5xx) status codes all have the same caching semantics,
described in <xref target="RFC7234"/>.</t>

<t>This implies that if they are pushed to the client, any of these status codes should behave as if
the client had requested them previously and stored the response. For example, a 403 (Forbidden)
can be pushed and stored just as a 200 (OK) – even if this would be of very limited use.</t>

<t>There are a few complications to consider, however.</t>

<t><list style="symbols">
  <t>304 (Not Modified) has special interaction with caches and validation that is described in 
<xref target="conditional"/>.</t>
  <t>Other 3xx Redirection codes indicate, when pushed, that if the client were to make that request,
it will be redirected. That does not mean that the <spanx style="verb">Location</spanx> header’s URL should be followed
immediately; it is only upon an actual request from the client that it should be acted upon.
Therefore, the caching semantics of 3xx redirects take effect.</t>
  <t>1xx Informational codes don’t make much sense as a Push payload, because the headers they convey
are lost in most implementations (to be subsumed by the headers in the final response). For
example, the headers on a 100 (Continue) response are a no-op; effectively, it’s a one-bit “go
ahead” signal. Since HTTP/2 already has protocol-level signalling mechanisms, it’s probably best
to say that 1xx responses SHOULD NOT be sent in Server Push, and MUST be ignored when received.</t>
  <t>401 (Unauthenticated) and 407 (Proxy-Authenticate) are covered in <xref target="auth"/>.</t>
  <t>Many other 4xx and 5xx status codes don’t have any practical use in Server Push; e.g., 405
(Method Not Allowed), 408 (Request Timeout), 411 (Length Required) and 414 (URI Too Long) are all
reactions to problems with the request. Since the server has sent that request, their use is
somewhat self-defeating; however, this does not mean that a client encountering them should
generate an error, or fail to use the response. At the very least, if the response is available
in devtools, debugging will be easier; additionally, someone might find a creative, appropriate
use for them some day.</t>
</list></t>

</section>
<section anchor="conditional" title="Conditional Requests">

<section anchor="if-match-if-unmodified-since" title="If-Match / If-Unmodified-Since">

<t>If the server has immediate access to the response being pushed (e.g., if the server is authoritative for it, or it is fresh in cache), it might want to send conditional headers in the <spanx style="verb">PUSH_PROMISE</spanx> request.</t>

<t>For example, a request can be sent with <spanx style="verb">If-Match</spanx> and/or <spanx style="verb">If-Unmodified-Since</spanx> to give the client
the earliest possible chance to send a <spanx style="verb">RST_STREAM</spanx> on the promise, without the server starting the
pushed response.</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/1234.jpg
Host: www.example.com
If-Match: "abcdef"
]]></artwork></figure>

<t>Here, when a client receives these headers in a <spanx style="verb">PUSH_PROMISE</spanx>, it can send a <spanx style="verb">RST_STREAM</spanx> if it
has a fresh cached response for <spanx style="verb">https://www.example.com/images/1234.jpg</spanx> with the <spanx style="verb">ETag</spanx> “abcdef”.
If it does not do so, the server will continue to push the successful (<spanx style="verb">2xx</spanx>) response (since the
<spanx style="verb">ETag</spanx> does in fact match what is pushed).</t>

</section>
<section anchor="if-none-match-if-modified-since" title="If-None-Match / If-Modified-Since">

<t>If the server does not have a fresh local copy of the response, but does have access to a stale one
(in the meaning of <xref target="RFC7234"/>), it can <spanx style="verb">PUSH_PROMISE</spanx> with <spanx style="verb">If-None-Match</spanx> and/or
<spanx style="verb">If-Modified-Since</spanx>:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/5678.jpg
Host: www.example.com
If-None-Match: "lmnop"
]]></artwork></figure>

<t>That way, the client again has an opportunity to send <spanx style="verb">RST_STREAM</spanx> if it already has a fresh copy
in cache.</t>

<t>Once the server has obtained a fresh (possibly validated) response, it can either push a <spanx style="verb">304 (Not
Modified)</spanx> response in the case that the <spanx style="verb">ETag</spanx> hasn’t changed, or a successful (<spanx style="verb">2xx</spanx>) response if
it has.</t>

<t>Note that if the client has a fresh copy in cache, but the server does not, the client can still
use the fresh copy; it has not been invalidated just because the server has not kept its copy fresh.</t>

</section>
<section anchor="not-modified-without-a-conditional" title="304 (Not Modified) without a Conditional">

<t>If the server believes that the client does have a stale but valid copy in its cache (e.g., through
the use of a cache digest; see <xref target="I-D.ietf-httpbis-cache-digest"/>), it can send a <spanx style="verb">PUSH_PROMISE</spanx>
followed by a pushed <spanx style="verb">304 (Not Modified)</spanx> response to revalidate that cached response, thereby
making it fresh in the client’s cache.</t>

<t>If the server has a local copy of the response that it wishes to use, it can send the PUSH_PROMISE
with an <spanx style="verb">If-None-Match</spanx> and/or <spanx style="verb">If-Modified-Since</spanx> conditional, as above.</t>

<t>However, if it does not, it will still be desirable to generate the <spanx style="verb">PUSH_PROMISE</spanx> as soon as
possible, so as to avoid the race described in <xref target="RFC7540"/>, Section 8.2.1.</t>

<t>To allow this, a request without a conditional can be sent:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/9012.jpg
Host: www.example.com
]]></artwork></figure>

<t>When the response body is available to the server, it can send a <spanx style="verb">304 (Not Modified)</spanx> if it
believes that the client already holds a copy (fresh or stale); however, it MUST include the
validators to allow the client to confirm this. For example:</t>

<figure><artwork><![CDATA[
:status: 304
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600
]]></artwork></figure>

<t>In this case, if the client’s cached response does not have the same <spanx style="verb">ETag</spanx> it SHOULD re-issue the
request to obtain a fresh response.</t>

<t>On the other hand, if the server determines that the client does not have the appropriate cached response, it can send the full, successful (<spanx style="verb">2xx</spanx>) response:</t>

<figure><artwork><![CDATA[
:status: 200
ETag: "abc123"
Date: Tue, 3 Sep 2016 04:34:12 GMT
Content-Type: image/jpeg
Cache-Control: max-age=3600

[ body ]
]]></artwork></figure>

<t><spanx style="strong">EDITOR’S NOTE</spanx>: This approach relies upon an <spanx style="emph">implicit conditional</spanx> in the PUSH_PROMISE request.
If felt necessary, this can be made explicit, for example by defining a new conditional header
<spanx style="verb">If-In-Digest</spanx>.</t>

</section>
</section>
<section anchor="conneg" title="Content Negotiation">

<t>The interaction of Content Negotiation and Server Push is tricky, because it requires the server to
guess what the client would have sent, in order to negotiate upon it.</t>

<t>However, it becomes much simpler if we assume that the client SHOULD NOT check a <spanx style="verb">PUSH_PROMISE</spanx> request’s headers to see whether or not it would have sent that request.</t>

<t>This means, for example, that if you <spanx style="verb">PUSH_PROMISE</spanx> the “wrong” <spanx style="verb">User-Agent</spanx>, <spanx style="verb">Accept-Encoding</spanx>,
<spanx style="verb">User-Agent</spanx> or even <spanx style="verb">Cookie</spanx> header field, the client SHOULD still use the pushed response; all
they’re looking for is a matching request method and URL.</t>

<t>However, this does imply a few things:</t>

<t><list style="symbols">
  <t>The pushed request and response MUST still “agree”; i.e., if you’re using gzip encoding, <spanx style="verb">Accept-Encoding</spanx> and <spanx style="verb">Content-Encoding</spanx> should be pushed with appropriate values.</t>
  <t>The pushed response MUST have an appropriate <spanx style="verb">Vary</spanx> header field, if it is cacheable. This is so that the cache operates properly.</t>
</list></t>

<t>Additionally, the server needs to know what the base capabilities and preferences of the client
are, to allow it to select the appropriate responses to push. To aid this, we suggest that servers
create a response by copying the values of the request header fields mentioned in the <spanx style="verb">Vary</spanx>
response header field from the request that is identified by the <spanx style="verb">PUSH_PROMISE</spanx> frame’s Stream ID.</t>

<t>So, for example, if the first request for a page had the following headers:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /
User-Agent: FooAgent/1.0
Accept-Encoding: gzip, br
Accept-Language: en, fr
Accept: text/html,s application/example, image/*
Cookie: abc=123
]]></artwork></figure>

<t>and the server wishes to push these response headers for <spanx style="verb">/images/123.png</spanx>:</t>

<figure><artwork><![CDATA[
:status: 200
Vary: Accept-Encoding
Content-Type: image/png
Cache-Control: max-age=3600
]]></artwork></figure>

<t>then it should use these headers for the <spanx style="verb">PUSH_PROMISE</spanx>:</t>

<figure><artwork><![CDATA[
:method: GET
:scheme: https
:authority: www.example.com
:path: /images/123.png
Accept-Encoding: gzip, br
Vary: Accept-Encoding
]]></artwork></figure>

<t>This approach has its limits. For example, use of <xref target="I-D.ietf-httpbis-client-hints"/> might not be
practical with server push (since in some circumstances, hints might change between the base page
request and the request for what’s been pushed).</t>

</section>
<section anchor="cache" title="Caching">

<t>Server Push has a strong tie to HTTP caching (<xref target="RFC7234"/>).</t>

<section anchor="scope" title="Caching and Scope of Server Push">

<t>Currently, browser implementations of Server Push will not inject the pushed response into the HTTP
cache until there is a reference to it from the stream that the PUSH_PROMISE was sent upon.</t>

<t>This is not specified behaviour, and it has confused some. Reportedly, Firefox ties the affinity of
a push to a “load group”, whereas Edge is using a “navigation handle.”</t>

<t>Effectively, doing so creates yet another kind of HTTP-ish cache in the browser. See also
<eref target="https://github.com/whatwg/fetch/issues/354">https://github.com/whatwg/fetch/issues/354</eref>.</t>

<t>Discussion about why these implementations feel this is necessary would be helpful. Possible
reasons that have been posited include:</t>

<t><list style="symbols">
  <t>Avoiding cache flooding. However, sites already have many ways to flood a cache with responses.</t>
  <t>Avoiding cache poisoning. However, an attacker that has the ability to send a push for an origin can also (presumably) get that push referenced by content there.</t>
  <t>Restricting use of push. Some developers want to push not only the assets for a given page to the client, but also push the next page that they might navigate to. This can be seen as abuse, but again, it’s already possible to fetch that into the cache in the background.</t>
</list></t>

</section>
<section anchor="matching-pushes-to-cache-entries" title="Matching Pushes to Cache Entries">

<t>Canonicalisation of request URLs is not specified for server push; presumably, limited
canonicalisation (e.g., removing default ports, case-normalising the scheme and authority) are
reasonable.</t>

<t>This might be specified in terms of origins in <xref target="RFC6454"/>, since that already specifies a match
algorithm that’s believed to conform with reality (roughly).</t>

<t>It can be derived from the various specifications, but it would also be good to explicitly say that
pushed URLs MUST NOT contain a fragment identifier.s</t>

</section>
<section anchor="pushing-uncacheable-content" title="Pushing Uncacheable Content">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made
available to the application separately.</t>
</list></t>

<t>As a result, any response that cannot be stored as per the rules in <xref target="RFC7234"/>, Section 3 cannot
be stored by a receiving cache.</t>

<t>“Being made available to the application separately” could mean many things. It could be that a
truly uncacheable response (e.g., with <spanx style="verb">Cache-Control: no-store</spanx>) would bypass the HTTP cache but
then be stored by the application in anticipation of a future request, but this might lead to some
surprising results for Web developers, because it’s effectively specifying yet another kind of
browser caching (see <xref target="scope"/>).</t>

<t>However, they might still be usable if a browser API for Server Push emerges. See
<eref target="https://github.com/whatwg/fetch/issues/51">https://github.com/whatwg/fetch/issues/51</eref>.</t>

</section>
<section anchor="pushing-with-max-age0-no-cache" title="Pushing with max-age=0, no-cache">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>Pushed responses are considered successfully validated on the origin server (e.g., if the “no-cache” cache response directive is present (<xref target="RFC7234"/>, Section 5.2.2)) while the stream identified by the promised stream ID is still open.</t>
</list></t>

<t>This implies that, while that stream is open, the pushed response can be considered fresh, even
when it contains any (or all) of the following cache directives:</t>

<t><list style="symbols">
  <t>max-age=0</t>
  <t>no-cache</t>
  <t>s-maxage=0 (for shared caches)</t>
</list></t>

<t>The underlying principle here is that while the response stream is still open, it’s semantically
equivalent to a “normal” response. So, this would also naturally apply to <spanx style="verb">Expires</spanx> when the value
matches that of the <spanx style="verb">Date</spanx> header. It’s less clear whether it would apply to pushed responses with
a positive <spanx style="verb">Age</spanx> header, or <spanx style="verb">Expires</spanx> in the past, but on general principles they SHOULD be
considered as just revalidated on the server, and therefore useable without revalidation.</t>

<t>This means that the client can:
* Pass the response on to the application for consumption
* Store the response as stale in the cache</t>

<t>Note that HTTP does not put constraints on <spanx style="emph">how</spanx> the application uses that response; it might use
it multiple times (e.g., an image might occur more than once on a page, or more than one downstream
client might have made the request). It’s just that this reuse isn’t in the context of a HTTP
cache’s operation.</t>

</section>
<section anchor="pushing-stale-content" title="Pushing Stale Content">

<t>How client caches should handle a pushed stale response (e.g., with some combination of <spanx style="verb">Expires</spanx>,
<spanx style="verb">Date</spanx>, <spanx style="verb">Cache-Control</spanx> and <spanx style="verb">Age</spanx> that results in it being considered not fresh, as per
<xref target="RFC7234"/>, Section 4.2) is not defined by HTTP/2.</t>

<t>This also applies to content that was fresh when it was pushed, but has become stale since that
stream closed.</t>

<t>Strictly interpreting the specifications, it would be necessary to issue a revalidation request for
that response. While this seems counter-intuitive at first, it might be interesting to consider
doing so as a way of optimistically pre-fetching content into cache, while still giving the server
control when it is actually used; if the server wants to permit its use, it can send a simple 304 (Not Modified). Otherwise, it can send a different response.</t>

</section>
<section anchor="pushing-and-invalidation" title="Pushing and Invalidation">

<t>When a server wants to remove the contents of a client’s cache for a given URL, but doesn’t know
what it’s to be replaced with yet, it needs to invalidate.</t>

<t>The only native HTTP mechanism for cache invalidation is described in <xref target="RFC7234"/>, Section 4.4:</t>

<t><list style='empty'>
  <t>A cache MUST invalidate the effective Request URI (Section 5.5 of <xref target="RFC7230"/>) as well as the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.</t>
</list></t>

<t>Since it is triggered by unsafe request methods (like POST), this can’t be used in Server Push.</t>

<t>We <spanx style="emph">could</spanx> use this loophole a bit further down:</t>

<t><list style='empty'>
  <t>A cache MUST invalidate the effective request URI (Section 5.5 of <xref target="RFC7230"/>) when it receives a non-error response to a request with a method whose safety is unknown.</t>
</list></t>

<t>… by defining a method that is defined to have a method whose safety is unknown (since if it’s defined, it either won’t be pushable, or won’t trigger invalidation). E.g.</t>

<figure><artwork><![CDATA[
:method: INVALIDATE
:scheme: https
:authority: www.example.com
:path: /thing
]]></artwork></figure>

<t>However, doing that might cause problems with IANA, since we’d have to pick a value to register.</t>

<t>Another approach would be to push a 404 (Not Found) or 410 (Gone) to trigger invalidation. However,
Such a push would need to be uncacheable (e.g,. with <spanx style="verb">Cache-Control: no-store</spanx>) to assure that the
error response wasn’t returned; however, this falls afoul of HTTP/2’s requirement that uncacheable
responses not interact with the HTTP cache.</t>

<t>If invalidation is an important use case, we’ll need to change one of these specifications, or
invent a new protocol mechanism. Maybe a <spanx style="verb">CACHE_INVALIDATE</spanx> frame?</t>

</section>
</section>
<section anchor="partial" title="Partial Content">

<t>Conceivably, it might be interesting to push partial content (<xref target="RFC7233"/>) to make some kinds of
content available to the client, when pushing the entire response would consume too much bandwidth;
e.g.:</t>

<t><list style="symbols">
  <t>The index portion of a PDF file</t>
  <t>The first segments or a video or audio file (and, in some formats, the last)</t>
  <t>The header of an image file, as it might contain layout-critical metadata</t>
</list></t>

<t>However, it’s believed that support for partial content in many caches (in particular, browser
caches) is poor.</t>

</section>
<section anchor="auth" title="Authentication">

<t>401 (Unauthorized) has the side effect of prompting the user for their credentials. Again, this
does not mean that the User Agent ought to do so when receiving a pushed 401; rather, this could be
seen as a mechanism to avoid the round trip that would otherwise be required – just as in other
intended uses of Server Push.</t>

<t>Presumably, the PUSH_PROMISE for such a request would omit the <spanx style="verb">Authentication</spanx> header field.</t>

<t>407 (Proxy Authenticate) is probably best not to push, since it’s confusing authority of the
network vs. the origin. Clients SHOULD ignore such pushes.</t>

</section>
<section anchor="headers" title="Push and Other HTTP Headers">

<t><xref target="RFC7540"/>, Section 8.2.1 says:</t>

<t><list style='empty'>
  <t>If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the :method pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</t>
</list></t>

<t>“Complete” in this context is a bit fuzzy. The strictest reading would be that it MUST include the required pseudo-headers, along with any request headers specified by a later <spanx style="verb">Vary</spanx> (as discussed in <xref target="conneg"/>).</t>

<t>There are a few headers that are interesting to consider, however.</t>

<t>Use of the <spanx style="verb">Host</spanx> request header field is discouraged in HTTP/2, and SHOULD be omitted.</t>

<t>The following request headers could be copied from the parent Stream ID’s request, but are unlikely to be useful (unless specified in <spanx style="verb">Vary</spanx>), and SHOULD be omitted otherwise:
* <spanx style="verb">User-Agent</spanx> 
* <spanx style="verb">Cookie</spanx>
* <spanx style="verb">DNT</spanx></t>

<t>The <spanx style="verb">Referer</spanx> header could be copied from the parent Stream ID’s request, but in most cases this would be a waste of bytes; it SHOULD be omitted.</t>

<t><spanx style="verb">Expect</spanx> doesn’t make much sense in a push, as discussed in <xref target="status"/>; it SHOULD be omitted.</t>

<t><spanx style="verb">Origin</spanx> is discussed in <xref target="cors"/>.</t>

<t>As described in <xref target="conneg"/>, none of these headers should cause a client to ignore the push or generate an error.</t>

</section>
<section anchor="cors" title="CORS">

<t><xref target="WHATWG.fetch"/> defines CORS, which uses the OPTIONS method to pre-flight certain requests to
assure that the server has opted into them, as well as discover what headers and methods are
allowed on such a request.</t>

<t>OPTIONS is safe and (in this case) does not have a request body (although technically, it has a
zero-length body, that can probably be overlooked).</t>

<t>Pushing OPTIONS as a means of pre-seeding CORS information would only work in very limited
circumstances; because CORS is, by nature, cross-origin, the two origins in question would need
some way of coordinating the push; the first origin would effectively tell the second origin that a
request is imminent, so it should initiate a push.</t>

<t>This seems fairly unlikely, unless the origins have an unusually close relationship. Conceivably,
this might be possible if the origins are coalesced onto the same connection, since they would be
represented by the same server.</t>

<t>Whether or not it’s worth the specification and implementation work remains a separate question,
especially when conveying site-wide CORS information via other mechanisms is under discussion.</t>

<t>CORS also defines the use of several headers to control the reuse of content across origins.
Presumably these would operate the same way whether or not they are pushed. Notably, the <spanx style="verb">Origin</spanx>
request header is used to determine where the content that originated the request is from.</t>

<t>For example, a HTML page at <spanx style="verb">https://www.example.com/thing</spanx> would send:</t>

<t><list style='empty'>
  <t>Origin: https://www.example.com/</t>
</list></t>

<t>when loading content from <spanx style="verb">https://other.example.net/foo</spanx>.</t>

<t>If the returned content has a header:</t>

<t><list style='empty'>
  <t>Access-Control-Allow-Origin: https://www.example.com/</t>
</list></t>

<t>then the browser will allow the page to have access to that content.</t>

<t>It’s not clear how this interacts with server push. Presumably, it will ignore the value of any
<spanx style="verb">Origin</spanx> header in the PUSH_PROMISE, synthesising an appropriate value.</t>

<t>However, the PUSH_PROMISE might still need to send an Origin header value, if the response contains
<spanx style="verb">Vary: Origin</spanx>; otherwise, a cached response might be incorrectly used for another origin’s request.</t>

</section>
<section anchor="h2" title="Interaction with HTTP/2 Features">

<section anchor="priority" title="Priorities">

<t>See recent discussion on-list.</t>

</section>
<section anchor="coalesce" title="Connection Coalescing">

<t><xref target="RFC7540"/>, Section 8.2 says:</t>

<t><list style='empty'>
  <t>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</t>
</list></t>

<t>Interestingly, it does not say anything about the relationship of the authority of the stream which
a PUSH_PROMISE appears upon and its embedded request. Is it valid (and a good idea) for a stream
from <spanx style="verb">foo.example.com</spanx> to push a stream to <spanx style="verb">bar.example.net</spanx> (for example)?</t>

</section>
<section anchor="refusing-pushes" title="Refusing Pushes">

<t><xref target="RFC7540"/>, Section 8.2.2 says:</t>

<t><list style='empty'>
  <t>Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed.
If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream’s identifier.</t>
</list></t>

<t>Unfortunately, this doesn’t give the server much information about why the push was refused. New HTTP error codes are collected below, in an attempt to start to give this information.</t>

<section anchor="pushiscached" title="PUSH_IS_CACHED">

<t><list style="symbols">
  <t>Name: PUSH_IS_CACHED</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the sender already had a fresh cached response, and did not need to update it.</t>
  <t>Specification: [this document]</t>
</list></t>

</section>
<section anchor="pushunauthoritative" title="PUSH_UNAUTHORITATIVE">

<t><list style="symbols">
  <t>Name: PUSH_UNAUTHORITATIVE</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the server is not considered authoritative for the origin of the pushed request.</t>
  <t>Specification: [this document]</t>
</list></t>

<t>Note that this would need to overrule the following requirement in <xref target="RFC7540"/>, Section 8.2:</t>

<t><list style='empty'>
  <t>The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.</t>
</list></t>

</section>
<section anchor="pushcontentencodingnotsupported" title="PUSH_CONTENT_ENCODING_NOT_SUPPORTED">

<t><list style="symbols">
  <t>Name: PUSH_CONTENT_ENCODING_NOT_SUPPORTED</t>
  <t>Code: 0xNN</t>
  <t>Description: On a RST_STREAM sent on a pushed stream, indicates that the content-coding of the response is not supported by the client.</t>
  <t>Specification: [this document]</t>
</list></t>

</section>
</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TBD</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>Undoubtedly.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor='RFC7234' target='http://www.rfc-editor.org/info/rfc7234'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name='RFC' value='7234'/>
<seriesInfo name='DOI' value='10.17487/RFC7234'/>
</reference>



<reference  anchor='RFC6454' target='http://www.rfc-editor.org/info/rfc6454'>
<front>
<title>The Web Origin Concept</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='December' />
<abstract><t>This document defines the concept of an &quot;origin&quot;, which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named &quot;Origin&quot;, that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6454'/>
<seriesInfo name='DOI' value='10.17487/RFC6454'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor='RFC7233' target='http://www.rfc-editor.org/info/rfc7233'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='Y.' surname='Lafon' fullname='Y. Lafon' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypertext information systems.  This document defines range requests and the rules for constructing and combining responses to those requests.</t></abstract>
</front>
<seriesInfo name='RFC' value='7233'/>
<seriesInfo name='DOI' value='10.17487/RFC7233'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="WHATWG.fetch" target="https://fetch.spec.whatwg.org/">
  <front>
    <title>Fetch</title>
    <author >
      <organization>WHAT Working Group</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>




<reference anchor='I-D.ietf-httpbis-cache-digest'>
<front>
<title>Cache Digests for HTTP/2</title>

<author initials='K' surname='Oku' fullname='Kazuho Oku'>
    <organization />
</author>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<date month='July' day='8' year='2016' />

<abstract><t>This specification defines a HTTP/2 frame type to allow clients to inform the server of their cache's contents.  Servers can then use this to inform their choices of what to push to clients.  Note to Readers  Discussion of this draft takes place on the HTTP working group mailing list (ietf-http-wg@w3.org), which is archived at https://lists.w3.org/Archives/Public/ietf-http-wg/ .  Working Group information can be found at http://httpwg.github.io/ ; source code and issues list for this draft can be found at https://github.com/httpwg/http-extensions/labels/cache-digest .</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-cache-digest-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-cache-digest-00.txt' />
</reference>



<reference anchor='I-D.ietf-httpbis-client-hints'>
<front>
<title>HTTP Client Hints</title>

<author initials='I' surname='Grigorik' fullname='Ilya Grigorik'>
    <organization />
</author>

<date month='May' day='31' year='2016' />

<abstract><t>An increasing diversity of Web-connected devices and software capabilities has created a need to deliver optimized content for each device.  This specification defines a set of HTTP request header fields, colloquially known as Client Hints, to address this.  They are intended to be used as input to proactive content negotiation; just as the Accept header field allows clients to indicate what formats they prefer, Client Hints allow clients to indicate a list of device and agent specific preferences.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-client-hints-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-client-hints-01.txt' />
</reference>




    </references>



  </back>
</rfc>

